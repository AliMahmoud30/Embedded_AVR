
Inter-Task Communication.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002b78  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000022  00800060  00002b78  00002c0c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000003ba  00800082  00800082  00002c2e  2**0
                  ALLOC
  3 .stab         00000750  00000000  00000000  00002c30  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000000e7  00000000  00000000  00003380  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001a0  00000000  00000000  00003468  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003b1c  00000000  00000000  00003608  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000e9a  00000000  00000000  00007124  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001607  00000000  00000000  00007fbe  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000d44  00000000  00000000  000095c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000016b5  00000000  00000000  0000a30c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000043b3  00000000  00000000  0000b9c1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000100  00000000  00000000  0000fd74  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 c3 07 	jmp	0xf86	; 0xf86 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e7       	ldi	r30, 0x78	; 120
      68:	fb e2       	ldi	r31, 0x2B	; 43
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a2 38       	cpi	r26, 0x82	; 130
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	a2 e8       	ldi	r26, 0x82	; 130
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ac 33       	cpi	r26, 0x3C	; 60
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 1f 06 	call	0xc3e	; 0xc3e <main>
      8a:	0c 94 ba 15 	jmp	0x2b74	; 0x2b74 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <prvTestWaitCondition>:

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
      92:	44 23       	and	r20, r20
      94:	41 f4       	brne	.+16     	; 0xa6 <prvTestWaitCondition+0x14>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
      96:	68 23       	and	r22, r24
      98:	79 23       	and	r23, r25
		{
			xWaitConditionMet = pdTRUE;
      9a:	81 e0       	ldi	r24, 0x01	; 1
      9c:	61 15       	cp	r22, r1
      9e:	71 05       	cpc	r23, r1
      a0:	51 f4       	brne	.+20     	; 0xb6 <prvTestWaitCondition+0x24>
      a2:	80 e0       	ldi	r24, 0x00	; 0
      a4:	08 95       	ret
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
      a6:	9b 01       	movw	r18, r22
      a8:	28 23       	and	r18, r24
      aa:	39 23       	and	r19, r25
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
		{
			xWaitConditionMet = pdTRUE;
      ac:	81 e0       	ldi	r24, 0x01	; 1
      ae:	62 17       	cp	r22, r18
      b0:	73 07       	cpc	r23, r19
      b2:	09 f0       	breq	.+2      	; 0xb6 <prvTestWaitCondition+0x24>
      b4:	80 e0       	ldi	r24, 0x00	; 0
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
}
      b6:	08 95       	ret

000000b8 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
      b8:	cf 93       	push	r28
      ba:	df 93       	push	r29
	EventGroup_t *pxEventBits;

		/* Allocate the event group. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
      bc:	8b e0       	ldi	r24, 0x0B	; 11
      be:	90 e0       	ldi	r25, 0x00	; 0
      c0:	0e 94 92 02 	call	0x524	; 0x524 <pvPortMalloc>
      c4:	ec 01       	movw	r28, r24

		if( pxEventBits != NULL )
      c6:	00 97       	sbiw	r24, 0x00	; 0
      c8:	31 f0       	breq	.+12     	; 0xd6 <xEventGroupCreate+0x1e>
		{
			pxEventBits->uxEventBits = 0;
      ca:	fc 01       	movw	r30, r24
      cc:	11 92       	st	Z+, r1
      ce:	11 92       	st	Z+, r1
      d0:	cf 01       	movw	r24, r30
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
      d2:	0e 94 57 05 	call	0xaae	; 0xaae <vListInitialise>
		{
			traceEVENT_GROUP_CREATE_FAILED();
		}

		return ( EventGroupHandle_t ) pxEventBits;
	}
      d6:	8c 2f       	mov	r24, r28
      d8:	9d 2f       	mov	r25, r29
      da:	df 91       	pop	r29
      dc:	cf 91       	pop	r28
      de:	08 95       	ret

000000e0 <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
      e0:	af 92       	push	r10
      e2:	bf 92       	push	r11
      e4:	cf 92       	push	r12
      e6:	df 92       	push	r13
      e8:	ef 92       	push	r14
      ea:	ff 92       	push	r15
      ec:	0f 93       	push	r16
      ee:	1f 93       	push	r17
      f0:	cf 93       	push	r28
      f2:	df 93       	push	r29
      f4:	5c 01       	movw	r10, r24
      f6:	6b 01       	movw	r12, r22
      f8:	e4 2e       	mov	r14, r20
      fa:	f2 2e       	mov	r15, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
      fc:	0e 94 3e 0f 	call	0x1e7c	; 0x1e7c <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     100:	f5 01       	movw	r30, r10
     102:	c0 81       	ld	r28, Z
     104:	d1 81       	ldd	r29, Z+1	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     106:	ce 01       	movw	r24, r28
     108:	b6 01       	movw	r22, r12
     10a:	4f 2d       	mov	r20, r15
     10c:	0e 94 49 00 	call	0x92	; 0x92 <prvTestWaitCondition>

		if( xWaitConditionMet != pdFALSE )
     110:	88 23       	and	r24, r24
     112:	51 f0       	breq	.+20     	; 0x128 <xEventGroupWaitBits+0x48>
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     114:	ee 20       	and	r14, r14
     116:	01 f1       	breq	.+64     	; 0x158 <xEventGroupWaitBits+0x78>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     118:	c0 94       	com	r12
     11a:	d0 94       	com	r13
     11c:	cc 22       	and	r12, r28
     11e:	dd 22       	and	r13, r29
     120:	f5 01       	movw	r30, r10
     122:	d1 82       	std	Z+1, r13	; 0x01
     124:	c0 82       	st	Z, r12
     126:	18 c0       	rjmp	.+48     	; 0x158 <xEventGroupWaitBits+0x78>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     128:	01 15       	cp	r16, r1
     12a:	11 05       	cpc	r17, r1
     12c:	a9 f0       	breq	.+42     	; 0x158 <xEventGroupWaitBits+0x78>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     12e:	ee 20       	and	r14, r14
     130:	19 f4       	brne	.+6      	; 0x138 <xEventGroupWaitBits+0x58>
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
EventBits_t uxReturn, uxControlBits = 0;
     132:	60 e0       	ldi	r22, 0x00	; 0
     134:	70 e0       	ldi	r23, 0x00	; 0
     136:	02 c0       	rjmp	.+4      	; 0x13c <xEventGroupWaitBits+0x5c>
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     138:	60 e0       	ldi	r22, 0x00	; 0
     13a:	71 e0       	ldi	r23, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     13c:	f1 10       	cpse	r15, r1
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     13e:	74 60       	ori	r23, 0x04	; 4
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     140:	6c 29       	or	r22, r12
     142:	7d 29       	or	r23, r13
     144:	c5 01       	movw	r24, r10
     146:	02 96       	adiw	r24, 0x02	; 2
     148:	a8 01       	movw	r20, r16
     14a:	0e 94 b4 11 	call	0x2368	; 0x2368 <vTaskPlaceOnUnorderedEventList>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     14e:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
     152:	88 23       	and	r24, r24
     154:	39 f4       	brne	.+14     	; 0x164 <xEventGroupWaitBits+0x84>
     156:	04 c0       	rjmp	.+8      	; 0x160 <xEventGroupWaitBits+0x80>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     158:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <xTaskResumeAll>
     15c:	ce 01       	movw	r24, r28
     15e:	21 c0       	rjmp	.+66     	; 0x1a2 <xEventGroupWaitBits+0xc2>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     160:	0e 94 0d 07 	call	0xe1a	; 0xe1a <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     164:	0e 94 3a 13 	call	0x2674	; 0x2674 <uxTaskResetEventItemValue>
     168:	ec 01       	movw	r28, r24

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     16a:	91 fd       	sbrc	r25, 1
     16c:	18 c0       	rjmp	.+48     	; 0x19e <xEventGroupWaitBits+0xbe>
		{
			taskENTER_CRITICAL();
     16e:	0f b6       	in	r0, 0x3f	; 63
     170:	f8 94       	cli
     172:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     174:	f5 01       	movw	r30, r10
     176:	c0 81       	ld	r28, Z
     178:	d1 81       	ldd	r29, Z+1	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     17a:	ce 01       	movw	r24, r28
     17c:	b6 01       	movw	r22, r12
     17e:	4f 2d       	mov	r20, r15
     180:	0e 94 49 00 	call	0x92	; 0x92 <prvTestWaitCondition>
     184:	88 23       	and	r24, r24
     186:	49 f0       	breq	.+18     	; 0x19a <xEventGroupWaitBits+0xba>
				{
					if( xClearOnExit != pdFALSE )
     188:	ee 20       	and	r14, r14
     18a:	39 f0       	breq	.+14     	; 0x19a <xEventGroupWaitBits+0xba>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     18c:	c0 94       	com	r12
     18e:	d0 94       	com	r13
     190:	cc 22       	and	r12, r28
     192:	dd 22       	and	r13, r29
     194:	f5 01       	movw	r30, r10
     196:	d1 82       	std	Z+1, r13	; 0x01
     198:	c0 82       	st	Z, r12
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     19a:	0f 90       	pop	r0
     19c:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     19e:	ce 01       	movw	r24, r28
     1a0:	90 70       	andi	r25, 0x00	; 0
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     1a2:	df 91       	pop	r29
     1a4:	cf 91       	pop	r28
     1a6:	1f 91       	pop	r17
     1a8:	0f 91       	pop	r16
     1aa:	ff 90       	pop	r15
     1ac:	ef 90       	pop	r14
     1ae:	df 90       	pop	r13
     1b0:	cf 90       	pop	r12
     1b2:	bf 90       	pop	r11
     1b4:	af 90       	pop	r10
     1b6:	08 95       	ret

000001b8 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     1b8:	fc 01       	movw	r30, r24
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     1ba:	0f b6       	in	r0, 0x3f	; 63
     1bc:	f8 94       	cli
     1be:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     1c0:	80 81       	ld	r24, Z
     1c2:	91 81       	ldd	r25, Z+1	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     1c4:	60 95       	com	r22
     1c6:	70 95       	com	r23
     1c8:	68 23       	and	r22, r24
     1ca:	79 23       	and	r23, r25
     1cc:	71 83       	std	Z+1, r23	; 0x01
     1ce:	60 83       	st	Z, r22
	}
	taskEXIT_CRITICAL();
     1d0:	0f 90       	pop	r0
     1d2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     1d4:	08 95       	ret

000001d6 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     1d6:	fc 01       	movw	r30, r24
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
}
     1d8:	80 81       	ld	r24, Z
     1da:	91 81       	ldd	r25, Z+1	; 0x01
     1dc:	08 95       	ret

000001de <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     1de:	af 92       	push	r10
     1e0:	bf 92       	push	r11
     1e2:	cf 92       	push	r12
     1e4:	df 92       	push	r13
     1e6:	ef 92       	push	r14
     1e8:	ff 92       	push	r15
     1ea:	0f 93       	push	r16
     1ec:	1f 93       	push	r17
     1ee:	cf 93       	push	r28
     1f0:	df 93       	push	r29
     1f2:	8c 01       	movw	r16, r24
     1f4:	eb 01       	movw	r28, r22
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1f6:	0f 2e       	mov	r0, r31
     1f8:	f5 e0       	ldi	r31, 0x05	; 5
     1fa:	cf 2e       	mov	r12, r31
     1fc:	dd 24       	eor	r13, r13
     1fe:	f0 2d       	mov	r31, r0
     200:	c8 0e       	add	r12, r24
     202:	d9 1e       	adc	r13, r25
	vTaskSuspendAll();
     204:	0e 94 3e 0f 	call	0x1e7c	; 0x1e7c <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     208:	d8 01       	movw	r26, r16
     20a:	17 96       	adiw	r26, 0x07	; 7
     20c:	ed 91       	ld	r30, X+
     20e:	fc 91       	ld	r31, X
     210:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     212:	8d 91       	ld	r24, X+
     214:	9c 91       	ld	r25, X
     216:	11 97       	sbiw	r26, 0x01	; 1
     218:	8c 2b       	or	r24, r28
     21a:	9d 2b       	or	r25, r29
     21c:	11 96       	adiw	r26, 0x01	; 1
     21e:	9c 93       	st	X, r25
     220:	8e 93       	st	-X, r24

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     222:	ce 16       	cp	r12, r30
     224:	df 06       	cpc	r13, r31
     226:	c1 f1       	breq	.+112    	; 0x298 <xEventGroupSetBits+0xba>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     228:	aa 24       	eor	r10, r10
     22a:	bb 24       	eor	r11, r11
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     22c:	ff 24       	eor	r15, r15
     22e:	f3 94       	inc	r15
     230:	ee 24       	eor	r14, r14
     232:	01 c0       	rjmp	.+2      	; 0x236 <xEventGroupSetBits+0x58>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     234:	fe 01       	movw	r30, r28
		{
			pxNext = listGET_NEXT( pxListItem );
     236:	c2 81       	ldd	r28, Z+2	; 0x02
     238:	d3 81       	ldd	r29, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     23a:	80 81       	ld	r24, Z
     23c:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     23e:	bc 01       	movw	r22, r24
     240:	60 70       	andi	r22, 0x00	; 0
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     242:	9c 01       	movw	r18, r24
     244:	30 70       	andi	r19, 0x00	; 0

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     246:	92 fd       	sbrc	r25, 2
     248:	0b c0       	rjmp	.+22     	; 0x260 <xEventGroupSetBits+0x82>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     24a:	d8 01       	movw	r26, r16
     24c:	8d 91       	ld	r24, X+
     24e:	9c 91       	ld	r25, X
     250:	11 97       	sbiw	r26, 0x01	; 1
     252:	82 23       	and	r24, r18
     254:	93 23       	and	r25, r19
				{
					xMatchFound = pdTRUE;
     256:	4f 2d       	mov	r20, r15
     258:	00 97       	sbiw	r24, 0x00	; 0
     25a:	69 f4       	brne	.+26     	; 0x276 <xEventGroupSetBits+0x98>
     25c:	4e 2d       	mov	r20, r14
     25e:	0b c0       	rjmp	.+22     	; 0x276 <xEventGroupSetBits+0x98>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     260:	d8 01       	movw	r26, r16
     262:	8d 91       	ld	r24, X+
     264:	9c 91       	ld	r25, X
     266:	11 97       	sbiw	r26, 0x01	; 1
     268:	82 23       	and	r24, r18
     26a:	93 23       	and	r25, r19
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     26c:	4f 2d       	mov	r20, r15
     26e:	28 17       	cp	r18, r24
     270:	39 07       	cpc	r19, r25
     272:	09 f0       	breq	.+2      	; 0x276 <xEventGroupSetBits+0x98>
     274:	4e 2d       	mov	r20, r14
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     276:	44 23       	and	r20, r20
     278:	59 f0       	breq	.+22     	; 0x290 <xEventGroupSetBits+0xb2>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     27a:	70 ff       	sbrs	r23, 0
     27c:	02 c0       	rjmp	.+4      	; 0x282 <xEventGroupSetBits+0xa4>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     27e:	a2 2a       	or	r10, r18
     280:	b3 2a       	or	r11, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     282:	d8 01       	movw	r26, r16
     284:	6d 91       	ld	r22, X+
     286:	7c 91       	ld	r23, X
     288:	72 60       	ori	r23, 0x02	; 2
     28a:	cf 01       	movw	r24, r30
     28c:	0e 94 18 12 	call	0x2430	; 0x2430 <xTaskRemoveFromUnorderedEventList>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     290:	cc 16       	cp	r12, r28
     292:	dd 06       	cpc	r13, r29
     294:	79 f6       	brne	.-98     	; 0x234 <xEventGroupSetBits+0x56>
     296:	02 c0       	rjmp	.+4      	; 0x29c <xEventGroupSetBits+0xbe>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     298:	aa 24       	eor	r10, r10
     29a:	bb 24       	eor	r11, r11
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     29c:	c5 01       	movw	r24, r10
     29e:	80 95       	com	r24
     2a0:	90 95       	com	r25
     2a2:	f8 01       	movw	r30, r16
     2a4:	a0 80       	ld	r10, Z
     2a6:	b1 80       	ldd	r11, Z+1	; 0x01
     2a8:	a8 22       	and	r10, r24
     2aa:	b9 22       	and	r11, r25
     2ac:	b1 82       	std	Z+1, r11	; 0x01
     2ae:	a0 82       	st	Z, r10
	}
	( void ) xTaskResumeAll();
     2b0:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
     2b4:	d8 01       	movw	r26, r16
     2b6:	8c 91       	ld	r24, X
     2b8:	11 96       	adiw	r26, 0x01	; 1
     2ba:	9c 91       	ld	r25, X
     2bc:	11 97       	sbiw	r26, 0x01	; 1
     2be:	df 91       	pop	r29
     2c0:	cf 91       	pop	r28
     2c2:	1f 91       	pop	r17
     2c4:	0f 91       	pop	r16
     2c6:	ff 90       	pop	r15
     2c8:	ef 90       	pop	r14
     2ca:	df 90       	pop	r13
     2cc:	cf 90       	pop	r12
     2ce:	bf 90       	pop	r11
     2d0:	af 90       	pop	r10
     2d2:	08 95       	ret

000002d4 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     2d4:	af 92       	push	r10
     2d6:	bf 92       	push	r11
     2d8:	cf 92       	push	r12
     2da:	df 92       	push	r13
     2dc:	ef 92       	push	r14
     2de:	ff 92       	push	r15
     2e0:	0f 93       	push	r16
     2e2:	1f 93       	push	r17
     2e4:	cf 93       	push	r28
     2e6:	df 93       	push	r29
     2e8:	6c 01       	movw	r12, r24
     2ea:	eb 01       	movw	r28, r22
     2ec:	7a 01       	movw	r14, r20
     2ee:	59 01       	movw	r10, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     2f0:	0e 94 3e 0f 	call	0x1e7c	; 0x1e7c <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     2f4:	f6 01       	movw	r30, r12
     2f6:	00 81       	ld	r16, Z
     2f8:	11 81       	ldd	r17, Z+1	; 0x01

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     2fa:	c6 01       	movw	r24, r12
     2fc:	be 01       	movw	r22, r28
     2fe:	0e 94 ef 00 	call	0x1de	; 0x1de <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     302:	c0 2b       	or	r28, r16
     304:	d1 2b       	or	r29, r17
     306:	c7 01       	movw	r24, r14
     308:	8c 23       	and	r24, r28
     30a:	9d 23       	and	r25, r29
     30c:	8e 15       	cp	r24, r14
     30e:	9f 05       	cpc	r25, r15
     310:	51 f4       	brne	.+20     	; 0x326 <xEventGroupSync+0x52>
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     312:	80 95       	com	r24
     314:	90 95       	com	r25
     316:	f6 01       	movw	r30, r12
     318:	20 81       	ld	r18, Z
     31a:	31 81       	ldd	r19, Z+1	; 0x01
     31c:	82 23       	and	r24, r18
     31e:	93 23       	and	r25, r19
     320:	91 83       	std	Z+1, r25	; 0x01
     322:	80 83       	st	Z, r24
     324:	12 c0       	rjmp	.+36     	; 0x34a <xEventGroupSync+0x76>

			xTicksToWait = 0;
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     326:	a1 14       	cp	r10, r1
     328:	b1 04       	cpc	r11, r1
     32a:	61 f0       	breq	.+24     	; 0x344 <xEventGroupSync+0x70>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     32c:	b7 01       	movw	r22, r14
     32e:	75 60       	ori	r23, 0x05	; 5
     330:	c6 01       	movw	r24, r12
     332:	02 96       	adiw	r24, 0x02	; 2
     334:	a5 01       	movw	r20, r10
     336:	0e 94 b4 11 	call	0x2368	; 0x2368 <vTaskPlaceOnUnorderedEventList>
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     33a:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
     33e:	88 23       	and	r24, r24
     340:	49 f4       	brne	.+18     	; 0x354 <xEventGroupSync+0x80>
     342:	06 c0       	rjmp	.+12     	; 0x350 <xEventGroupSync+0x7c>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     344:	f6 01       	movw	r30, r12
     346:	c0 81       	ld	r28, Z
     348:	d1 81       	ldd	r29, Z+1	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     34a:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <xTaskResumeAll>
     34e:	1c c0       	rjmp	.+56     	; 0x388 <xEventGroupSync+0xb4>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     350:	0e 94 0d 07 	call	0xe1a	; 0xe1a <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     354:	0e 94 3a 13 	call	0x2674	; 0x2674 <uxTaskResetEventItemValue>

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     358:	91 fd       	sbrc	r25, 1
     35a:	14 c0       	rjmp	.+40     	; 0x384 <xEventGroupSync+0xb0>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     35c:	0f b6       	in	r0, 0x3f	; 63
     35e:	f8 94       	cli
     360:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     362:	f6 01       	movw	r30, r12
     364:	80 81       	ld	r24, Z
     366:	91 81       	ldd	r25, Z+1	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     368:	97 01       	movw	r18, r14
     36a:	28 23       	and	r18, r24
     36c:	39 23       	and	r19, r25
     36e:	2e 15       	cp	r18, r14
     370:	3f 05       	cpc	r19, r15
     372:	31 f4       	brne	.+12     	; 0x380 <xEventGroupSync+0xac>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     374:	20 95       	com	r18
     376:	30 95       	com	r19
     378:	28 23       	and	r18, r24
     37a:	39 23       	and	r19, r25
     37c:	31 83       	std	Z+1, r19	; 0x01
     37e:	20 83       	st	Z, r18
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     380:	0f 90       	pop	r0
     382:	0f be       	out	0x3f, r0	; 63
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     384:	ec 01       	movw	r28, r24
     386:	d0 70       	andi	r29, 0x00	; 0
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     388:	8c 2f       	mov	r24, r28
     38a:	9d 2f       	mov	r25, r29
     38c:	df 91       	pop	r29
     38e:	cf 91       	pop	r28
     390:	1f 91       	pop	r17
     392:	0f 91       	pop	r16
     394:	ff 90       	pop	r15
     396:	ef 90       	pop	r14
     398:	df 90       	pop	r13
     39a:	cf 90       	pop	r12
     39c:	bf 90       	pop	r11
     39e:	af 90       	pop	r10
     3a0:	08 95       	ret

000003a2 <vEventGroupDelete>:
	return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     3a2:	cf 93       	push	r28
     3a4:	df 93       	push	r29
     3a6:	ec 01       	movw	r28, r24
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

	vTaskSuspendAll();
     3a8:	0e 94 3e 0f 	call	0x1e7c	; 0x1e7c <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     3ac:	8a 81       	ldd	r24, Y+2	; 0x02
     3ae:	88 23       	and	r24, r24
     3b0:	49 f0       	breq	.+18     	; 0x3c4 <vEventGroupDelete+0x22>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     3b2:	8f 81       	ldd	r24, Y+7	; 0x07
     3b4:	98 85       	ldd	r25, Y+8	; 0x08
     3b6:	60 e0       	ldi	r22, 0x00	; 0
     3b8:	72 e0       	ldi	r23, 0x02	; 2
     3ba:	0e 94 18 12 	call	0x2430	; 0x2430 <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     3be:	8a 81       	ldd	r24, Y+2	; 0x02
     3c0:	88 23       	and	r24, r24
     3c2:	b9 f7       	brne	.-18     	; 0x3b2 <vEventGroupDelete+0x10>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     3c4:	ce 01       	movw	r24, r28
     3c6:	0e 94 32 03 	call	0x664	; 0x664 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     3ca:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <xTaskResumeAll>
}
     3ce:	df 91       	pop	r29
     3d0:	cf 91       	pop	r28
     3d2:	08 95       	ret

000003d4 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
     3d4:	ba 01       	movw	r22, r20
     3d6:	0e 94 ef 00 	call	0x1de	; 0x1de <xEventGroupSetBits>
}
     3da:	08 95       	ret

000003dc <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
     3dc:	ba 01       	movw	r22, r20
     3de:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <xEventGroupClearBits>
}
     3e2:	08 95       	ret

000003e4 <DIO_Set_Port_Direction>:


/*        SET Direction         */ 
void DIO_Set_Port_Direction(u8 Base, u8 Direction)
{
	if((Direction == OUTPUT)||(Direction==1))
     3e4:	61 30       	cpi	r22, 0x01	; 1
     3e6:	29 f4       	brne	.+10     	; 0x3f2 <DIO_Set_Port_Direction+0xe>
	{
		(*(volatile u8*)(Base+1)) = 0xFF;
     3e8:	e8 2f       	mov	r30, r24
     3ea:	f0 e0       	ldi	r31, 0x00	; 0
     3ec:	8f ef       	ldi	r24, 0xFF	; 255
     3ee:	81 83       	std	Z+1, r24	; 0x01
     3f0:	08 95       	ret
	}
	else if((Direction == INPUT)||(Direction==0))
     3f2:	66 23       	and	r22, r22
     3f4:	19 f4       	brne	.+6      	; 0x3fc <DIO_Set_Port_Direction+0x18>
	{
		(*(volatile u8*)(Base+1)) = 0x00;
     3f6:	e8 2f       	mov	r30, r24
     3f8:	f0 e0       	ldi	r31, 0x00	; 0
     3fa:	11 82       	std	Z+1, r1	; 0x01
     3fc:	08 95       	ret

000003fe <DIO_Set_Pin_Direction>:


void DIO_Set_Pin_Direction(u8 Base, u8 PIN, u8 Direction)
{

	if((Direction == OUTPUT) || (Direction == 1))
     3fe:	41 30       	cpi	r20, 0x01	; 1
     400:	79 f4       	brne	.+30     	; 0x420 <DIO_Set_Pin_Direction+0x22>
	{
		//SET_BIT((*(volatile u8*)(Base+1)),PIN);  // OUTPUT = 1
		(*(volatile u8*)(Base+1))|=(1<<PIN);
     402:	e8 2f       	mov	r30, r24
     404:	f0 e0       	ldi	r31, 0x00	; 0
     406:	21 81       	ldd	r18, Z+1	; 0x01
     408:	81 e0       	ldi	r24, 0x01	; 1
     40a:	90 e0       	ldi	r25, 0x00	; 0
     40c:	ac 01       	movw	r20, r24
     40e:	02 c0       	rjmp	.+4      	; 0x414 <DIO_Set_Pin_Direction+0x16>
     410:	44 0f       	add	r20, r20
     412:	55 1f       	adc	r21, r21
     414:	6a 95       	dec	r22
     416:	e2 f7       	brpl	.-8      	; 0x410 <DIO_Set_Pin_Direction+0x12>
     418:	ba 01       	movw	r22, r20
     41a:	62 2b       	or	r22, r18
     41c:	61 83       	std	Z+1, r22	; 0x01
     41e:	08 95       	ret
	}
	else if((Direction == INPUT) || (Direction == 0))
     420:	44 23       	and	r20, r20
     422:	79 f4       	brne	.+30     	; 0x442 <DIO_Set_Pin_Direction+0x44>
	{
		//CLR_BIT((*(volatile u8*)(Base+1)),PIN); // INPUT = 0;
		(*(volatile u8*)(Base+1))&=(~(1<<PIN)); 
     424:	e8 2f       	mov	r30, r24
     426:	f0 e0       	ldi	r31, 0x00	; 0
     428:	21 81       	ldd	r18, Z+1	; 0x01
     42a:	81 e0       	ldi	r24, 0x01	; 1
     42c:	90 e0       	ldi	r25, 0x00	; 0
     42e:	ac 01       	movw	r20, r24
     430:	02 c0       	rjmp	.+4      	; 0x436 <DIO_Set_Pin_Direction+0x38>
     432:	44 0f       	add	r20, r20
     434:	55 1f       	adc	r21, r21
     436:	6a 95       	dec	r22
     438:	e2 f7       	brpl	.-8      	; 0x432 <DIO_Set_Pin_Direction+0x34>
     43a:	ba 01       	movw	r22, r20
     43c:	60 95       	com	r22
     43e:	62 23       	and	r22, r18
     440:	61 83       	std	Z+1, r22	; 0x01
     442:	08 95       	ret

00000444 <DIO_Set_Port_Value>:


/*        SET Value         */ 
void DIO_Set_Port_Value(u8 Base, u8 Value)
{
	(*(volatile u8*)(Base+2)) = Value;
     444:	e8 2f       	mov	r30, r24
     446:	f0 e0       	ldi	r31, 0x00	; 0
     448:	62 83       	std	Z+2, r22	; 0x02
}
     44a:	08 95       	ret

0000044c <DIO_Set_Pin_Value>:

void DIO_Set_Pin_Value(u8 Base,u8 PIN, u8 Value)
{
	if((Value == HIGH) || (Value == 1))
     44c:	41 30       	cpi	r20, 0x01	; 1
     44e:	79 f4       	brne	.+30     	; 0x46e <DIO_Set_Pin_Value+0x22>
	{	//SET_BIT((*(volatile u8*)(Base+2)),PIN);
		(*(volatile u8*)(Base+2))|=(1<<PIN);
     450:	e8 2f       	mov	r30, r24
     452:	f0 e0       	ldi	r31, 0x00	; 0
     454:	22 81       	ldd	r18, Z+2	; 0x02
     456:	81 e0       	ldi	r24, 0x01	; 1
     458:	90 e0       	ldi	r25, 0x00	; 0
     45a:	ac 01       	movw	r20, r24
     45c:	02 c0       	rjmp	.+4      	; 0x462 <DIO_Set_Pin_Value+0x16>
     45e:	44 0f       	add	r20, r20
     460:	55 1f       	adc	r21, r21
     462:	6a 95       	dec	r22
     464:	e2 f7       	brpl	.-8      	; 0x45e <DIO_Set_Pin_Value+0x12>
     466:	ba 01       	movw	r22, r20
     468:	62 2b       	or	r22, r18
     46a:	62 83       	std	Z+2, r22	; 0x02
     46c:	08 95       	ret
	}
	else if((Value == LOW) || (Value == 0))
     46e:	44 23       	and	r20, r20
     470:	79 f4       	brne	.+30     	; 0x490 <DIO_Set_Pin_Value+0x44>
	{
		(*(volatile u8*)(Base+2))&=(~(1<<PIN));
     472:	e8 2f       	mov	r30, r24
     474:	f0 e0       	ldi	r31, 0x00	; 0
     476:	22 81       	ldd	r18, Z+2	; 0x02
     478:	81 e0       	ldi	r24, 0x01	; 1
     47a:	90 e0       	ldi	r25, 0x00	; 0
     47c:	ac 01       	movw	r20, r24
     47e:	02 c0       	rjmp	.+4      	; 0x484 <DIO_Set_Pin_Value+0x38>
     480:	44 0f       	add	r20, r20
     482:	55 1f       	adc	r21, r21
     484:	6a 95       	dec	r22
     486:	e2 f7       	brpl	.-8      	; 0x480 <DIO_Set_Pin_Value+0x34>
     488:	ba 01       	movw	r22, r20
     48a:	60 95       	com	r22
     48c:	62 23       	and	r22, r18
     48e:	62 83       	std	Z+2, r22	; 0x02
     490:	08 95       	ret

00000492 <DIO_Get_Port_value>:
	}
}

/*        Get Value         */ 
u8 DIO_Get_Port_value(u8 Base)
{
     492:	cf 93       	push	r28
     494:	df 93       	push	r29
     496:	0f 92       	push	r0
     498:	cd b7       	in	r28, 0x3d	; 61
     49a:	de b7       	in	r29, 0x3e	; 62
	 volatile u8 Value;
	Value = (*(volatile u8*)(Base));
     49c:	e8 2f       	mov	r30, r24
     49e:	f0 e0       	ldi	r31, 0x00	; 0
     4a0:	80 81       	ld	r24, Z
     4a2:	89 83       	std	Y+1, r24	; 0x01
	return Value;
     4a4:	89 81       	ldd	r24, Y+1	; 0x01
}
     4a6:	0f 90       	pop	r0
     4a8:	df 91       	pop	r29
     4aa:	cf 91       	pop	r28
     4ac:	08 95       	ret

000004ae <DIO_Get_Pin_value>:


u8 DIO_Get_Pin_value (u8 Base, u8 PIN)
{
     4ae:	cf 93       	push	r28
     4b0:	df 93       	push	r29
     4b2:	0f 92       	push	r0
     4b4:	cd b7       	in	r28, 0x3d	; 61
     4b6:	de b7       	in	r29, 0x3e	; 62
	volatile u8 Value;
	Value = ((*(volatile u8*)(Base))>>PIN)&1;	
     4b8:	e8 2f       	mov	r30, r24
     4ba:	f0 e0       	ldi	r31, 0x00	; 0
     4bc:	80 81       	ld	r24, Z
     4be:	90 e0       	ldi	r25, 0x00	; 0
     4c0:	9c 01       	movw	r18, r24
     4c2:	02 c0       	rjmp	.+4      	; 0x4c8 <DIO_Get_Pin_value+0x1a>
     4c4:	35 95       	asr	r19
     4c6:	27 95       	ror	r18
     4c8:	6a 95       	dec	r22
     4ca:	e2 f7       	brpl	.-8      	; 0x4c4 <DIO_Get_Pin_value+0x16>
     4cc:	b9 01       	movw	r22, r18
     4ce:	61 70       	andi	r22, 0x01	; 1
     4d0:	69 83       	std	Y+1, r22	; 0x01
	return Value;
     4d2:	89 81       	ldd	r24, Y+1	; 0x01
}
     4d4:	0f 90       	pop	r0
     4d6:	df 91       	pop	r29
     4d8:	cf 91       	pop	r28
     4da:	08 95       	ret

000004dc <DIO_Toggle_Pin>:

void DIO_Toggle_Pin(u8 Base, u8 PIN)
{
	*((volatile u8*)(Base+2))^=(1<<PIN);
     4dc:	e8 2f       	mov	r30, r24
     4de:	f0 e0       	ldi	r31, 0x00	; 0
     4e0:	22 81       	ldd	r18, Z+2	; 0x02
     4e2:	81 e0       	ldi	r24, 0x01	; 1
     4e4:	90 e0       	ldi	r25, 0x00	; 0
     4e6:	ac 01       	movw	r20, r24
     4e8:	02 c0       	rjmp	.+4      	; 0x4ee <DIO_Toggle_Pin+0x12>
     4ea:	44 0f       	add	r20, r20
     4ec:	55 1f       	adc	r21, r21
     4ee:	6a 95       	dec	r22
     4f0:	e2 f7       	brpl	.-8      	; 0x4ea <DIO_Toggle_Pin+0xe>
     4f2:	ba 01       	movw	r22, r20
     4f4:	62 27       	eor	r22, r18
     4f6:	62 83       	std	Z+2, r22	; 0x02
}
     4f8:	08 95       	ret

000004fa <DIO_SET_HIGH_Nipple_Value>:
/* Set HIGH NIPPLE */

void DIO_SET_HIGH_Nipple_Value(u8 Base, u8 Data)
{
	Data<<=4;
	(*(volatile u8*)(Base+2)) &=0x0f;  //to CLR HIGH NIPPLE Pins before write 
     4fa:	e8 2f       	mov	r30, r24
     4fc:	f0 e0       	ldi	r31, 0x00	; 0
     4fe:	82 81       	ldd	r24, Z+2	; 0x02
     500:	8f 70       	andi	r24, 0x0F	; 15
     502:	82 83       	std	Z+2, r24	; 0x02
	(*(volatile u8*)(Base+2)) ^=Data;
     504:	82 81       	ldd	r24, Z+2	; 0x02

/* Set HIGH NIPPLE */

void DIO_SET_HIGH_Nipple_Value(u8 Base, u8 Data)
{
	Data<<=4;
     506:	62 95       	swap	r22
     508:	60 7f       	andi	r22, 0xF0	; 240
	(*(volatile u8*)(Base+2)) &=0x0f;  //to CLR HIGH NIPPLE Pins before write 
	(*(volatile u8*)(Base+2)) ^=Data;
     50a:	68 27       	eor	r22, r24
     50c:	62 83       	std	Z+2, r22	; 0x02
	
} 
     50e:	08 95       	ret

00000510 <DIO_SET_LOW_Nipple_Value>:

/* Set LOW NIPPLE */

void DIO_SET_LOW_Nipple_Value(u8 Base, u8 Data)
{
	(*(volatile u8*)(Base+2)) &=0xf0;  //to CLR LOW NIPPLE before write
     510:	e8 2f       	mov	r30, r24
     512:	f0 e0       	ldi	r31, 0x00	; 0
     514:	82 81       	ldd	r24, Z+2	; 0x02
     516:	80 7f       	andi	r24, 0xF0	; 240
     518:	82 83       	std	Z+2, r24	; 0x02
	(*(volatile u8*)(Base+2)) ^=(Data & 0x0F) ;
     51a:	82 81       	ldd	r24, Z+2	; 0x02
     51c:	6f 70       	andi	r22, 0x0F	; 15
     51e:	68 27       	eor	r22, r24
     520:	62 83       	std	Z+2, r22	; 0x02
	
}
     522:	08 95       	ret

00000524 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     524:	0f 93       	push	r16
     526:	1f 93       	push	r17
     528:	cf 93       	push	r28
     52a:	df 93       	push	r29
     52c:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     52e:	0e 94 3e 0f 	call	0x1e7c	; 0x1e7c <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     532:	80 91 82 00 	lds	r24, 0x0082
     536:	88 23       	and	r24, r24
     538:	f9 f4       	brne	.+62     	; 0x578 <pvPortMalloc+0x54>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     53a:	8c e8       	ldi	r24, 0x8C	; 140
     53c:	90 e0       	ldi	r25, 0x00	; 0
     53e:	90 93 84 00 	sts	0x0084, r25
     542:	80 93 83 00 	sts	0x0083, r24
	xStart.xBlockSize = ( size_t ) 0;
     546:	10 92 86 00 	sts	0x0086, r1
     54a:	10 92 85 00 	sts	0x0085, r1

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     54e:	8f e1       	ldi	r24, 0x1F	; 31
     550:	93 e0       	ldi	r25, 0x03	; 3
     552:	90 93 8a 00 	sts	0x008A, r25
     556:	80 93 89 00 	sts	0x0089, r24
	xEnd.pxNextFreeBlock = NULL;
     55a:	e9 e8       	ldi	r30, 0x89	; 137
     55c:	f0 e0       	ldi	r31, 0x00	; 0
     55e:	12 92       	st	-Z, r1
     560:	12 92       	st	-Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     562:	90 93 8f 00 	sts	0x008F, r25
     566:	80 93 8e 00 	sts	0x008E, r24
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     56a:	f0 93 8d 00 	sts	0x008D, r31
     56e:	e0 93 8c 00 	sts	0x008C, r30
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
     572:	81 e0       	ldi	r24, 0x01	; 1
     574:	80 93 82 00 	sts	0x0082, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     578:	20 97       	sbiw	r28, 0x00	; 0
     57a:	09 f4       	brne	.+2      	; 0x57e <pvPortMalloc+0x5a>
     57c:	62 c0       	rjmp	.+196    	; 0x642 <pvPortMalloc+0x11e>
		{
			xWantedSize += heapSTRUCT_SIZE;
     57e:	9e 01       	movw	r18, r28
     580:	2c 5f       	subi	r18, 0xFC	; 252
     582:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     584:	23 96       	adiw	r28, 0x03	; 3
     586:	83 e0       	ldi	r24, 0x03	; 3
     588:	ce 31       	cpi	r28, 0x1E	; 30
     58a:	d8 07       	cpc	r29, r24
     58c:	08 f0       	brcs	.+2      	; 0x590 <pvPortMalloc+0x6c>
     58e:	5c c0       	rjmp	.+184    	; 0x648 <pvPortMalloc+0x124>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     590:	e0 91 83 00 	lds	r30, 0x0083
     594:	f0 91 84 00 	lds	r31, 0x0084

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     598:	a3 e8       	ldi	r26, 0x83	; 131
     59a:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     59c:	02 c0       	rjmp	.+4      	; 0x5a2 <pvPortMalloc+0x7e>
     59e:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     5a0:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     5a2:	82 81       	ldd	r24, Z+2	; 0x02
     5a4:	93 81       	ldd	r25, Z+3	; 0x03
     5a6:	82 17       	cp	r24, r18
     5a8:	93 07       	cpc	r25, r19
     5aa:	20 f4       	brcc	.+8      	; 0x5b4 <pvPortMalloc+0x90>
     5ac:	80 81       	ld	r24, Z
     5ae:	91 81       	ldd	r25, Z+1	; 0x01
     5b0:	00 97       	sbiw	r24, 0x00	; 0
     5b2:	a9 f7       	brne	.-22     	; 0x59e <pvPortMalloc+0x7a>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     5b4:	c0 e0       	ldi	r28, 0x00	; 0
     5b6:	e7 38       	cpi	r30, 0x87	; 135
     5b8:	fc 07       	cpc	r31, r28
     5ba:	09 f4       	brne	.+2      	; 0x5be <pvPortMalloc+0x9a>
     5bc:	48 c0       	rjmp	.+144    	; 0x64e <pvPortMalloc+0x12a>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     5be:	8d 91       	ld	r24, X+
     5c0:	9c 91       	ld	r25, X
     5c2:	11 97       	sbiw	r26, 0x01	; 1
     5c4:	8c 01       	movw	r16, r24
     5c6:	0c 5f       	subi	r16, 0xFC	; 252
     5c8:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     5ca:	80 81       	ld	r24, Z
     5cc:	91 81       	ldd	r25, Z+1	; 0x01
     5ce:	11 96       	adiw	r26, 0x01	; 1
     5d0:	9c 93       	st	X, r25
     5d2:	8e 93       	st	-X, r24

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     5d4:	82 81       	ldd	r24, Z+2	; 0x02
     5d6:	93 81       	ldd	r25, Z+3	; 0x03
     5d8:	82 1b       	sub	r24, r18
     5da:	93 0b       	sbc	r25, r19
     5dc:	89 30       	cpi	r24, 0x09	; 9
     5de:	91 05       	cpc	r25, r1
     5e0:	18 f1       	brcs	.+70     	; 0x628 <pvPortMalloc+0x104>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     5e2:	af 01       	movw	r20, r30
     5e4:	42 0f       	add	r20, r18
     5e6:	53 1f       	adc	r21, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     5e8:	da 01       	movw	r26, r20
     5ea:	13 96       	adiw	r26, 0x03	; 3
     5ec:	9c 93       	st	X, r25
     5ee:	8e 93       	st	-X, r24
     5f0:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     5f2:	33 83       	std	Z+3, r19	; 0x03
     5f4:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     5f6:	12 96       	adiw	r26, 0x02	; 2
     5f8:	2d 91       	ld	r18, X+
     5fa:	3c 91       	ld	r19, X
     5fc:	13 97       	sbiw	r26, 0x03	; 3
     5fe:	63 e8       	ldi	r22, 0x83	; 131
     600:	70 e0       	ldi	r23, 0x00	; 0
     602:	01 c0       	rjmp	.+2      	; 0x606 <pvPortMalloc+0xe2>
     604:	bd 01       	movw	r22, r26
     606:	eb 01       	movw	r28, r22
     608:	a8 81       	ld	r26, Y
     60a:	b9 81       	ldd	r27, Y+1	; 0x01
     60c:	12 96       	adiw	r26, 0x02	; 2
     60e:	8d 91       	ld	r24, X+
     610:	9c 91       	ld	r25, X
     612:	13 97       	sbiw	r26, 0x03	; 3
     614:	82 17       	cp	r24, r18
     616:	93 07       	cpc	r25, r19
     618:	a8 f3       	brcs	.-22     	; 0x604 <pvPortMalloc+0xe0>
     61a:	ea 01       	movw	r28, r20
     61c:	b9 83       	std	Y+1, r27	; 0x01
     61e:	a8 83       	st	Y, r26
     620:	db 01       	movw	r26, r22
     622:	11 96       	adiw	r26, 0x01	; 1
     624:	5c 93       	st	X, r21
     626:	4e 93       	st	-X, r20
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     628:	80 91 60 00 	lds	r24, 0x0060
     62c:	90 91 61 00 	lds	r25, 0x0061
     630:	22 81       	ldd	r18, Z+2	; 0x02
     632:	33 81       	ldd	r19, Z+3	; 0x03
     634:	82 1b       	sub	r24, r18
     636:	93 0b       	sbc	r25, r19
     638:	90 93 61 00 	sts	0x0061, r25
     63c:	80 93 60 00 	sts	0x0060, r24
     640:	08 c0       	rjmp	.+16     	; 0x652 <pvPortMalloc+0x12e>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     642:	00 e0       	ldi	r16, 0x00	; 0
     644:	10 e0       	ldi	r17, 0x00	; 0
     646:	05 c0       	rjmp	.+10     	; 0x652 <pvPortMalloc+0x12e>
     648:	00 e0       	ldi	r16, 0x00	; 0
     64a:	10 e0       	ldi	r17, 0x00	; 0
     64c:	02 c0       	rjmp	.+4      	; 0x652 <pvPortMalloc+0x12e>
     64e:	00 e0       	ldi	r16, 0x00	; 0
     650:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     652:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     656:	80 2f       	mov	r24, r16
     658:	91 2f       	mov	r25, r17
     65a:	df 91       	pop	r29
     65c:	cf 91       	pop	r28
     65e:	1f 91       	pop	r17
     660:	0f 91       	pop	r16
     662:	08 95       	ret

00000664 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     664:	0f 93       	push	r16
     666:	1f 93       	push	r17
     668:	cf 93       	push	r28
     66a:	df 93       	push	r29
     66c:	ec 01       	movw	r28, r24
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     66e:	00 97       	sbiw	r24, 0x00	; 0
     670:	39 f1       	breq	.+78     	; 0x6c0 <vPortFree+0x5c>
		before it. */
		puc -= heapSTRUCT_SIZE;

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
     672:	8c 01       	movw	r16, r24
     674:	04 50       	subi	r16, 0x04	; 4
     676:	10 40       	sbci	r17, 0x00	; 0

		vTaskSuspendAll();
     678:	0e 94 3e 0f 	call	0x1e7c	; 0x1e7c <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     67c:	f8 01       	movw	r30, r16
     67e:	22 81       	ldd	r18, Z+2	; 0x02
     680:	33 81       	ldd	r19, Z+3	; 0x03
     682:	a3 e8       	ldi	r26, 0x83	; 131
     684:	b0 e0       	ldi	r27, 0x00	; 0
     686:	01 c0       	rjmp	.+2      	; 0x68a <vPortFree+0x26>
     688:	df 01       	movw	r26, r30
     68a:	ed 91       	ld	r30, X+
     68c:	fc 91       	ld	r31, X
     68e:	11 97       	sbiw	r26, 0x01	; 1
     690:	82 81       	ldd	r24, Z+2	; 0x02
     692:	93 81       	ldd	r25, Z+3	; 0x03
     694:	82 17       	cp	r24, r18
     696:	93 07       	cpc	r25, r19
     698:	b8 f3       	brcs	.-18     	; 0x688 <vPortFree+0x24>
     69a:	24 97       	sbiw	r28, 0x04	; 4
     69c:	f9 83       	std	Y+1, r31	; 0x01
     69e:	e8 83       	st	Y, r30
     6a0:	0d 93       	st	X+, r16
     6a2:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     6a4:	80 91 60 00 	lds	r24, 0x0060
     6a8:	90 91 61 00 	lds	r25, 0x0061
     6ac:	2a 81       	ldd	r18, Y+2	; 0x02
     6ae:	3b 81       	ldd	r19, Y+3	; 0x03
     6b0:	82 0f       	add	r24, r18
     6b2:	93 1f       	adc	r25, r19
     6b4:	90 93 61 00 	sts	0x0061, r25
     6b8:	80 93 60 00 	sts	0x0060, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     6bc:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <xTaskResumeAll>
	}
}
     6c0:	df 91       	pop	r29
     6c2:	cf 91       	pop	r28
     6c4:	1f 91       	pop	r17
     6c6:	0f 91       	pop	r16
     6c8:	08 95       	ret

000006ca <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
     6ca:	80 91 60 00 	lds	r24, 0x0060
     6ce:	90 91 61 00 	lds	r25, 0x0061
     6d2:	08 95       	ret

000006d4 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* This just exists to keep the linker quiet. */
}
     6d4:	08 95       	ret

000006d6 <Keypad_4_4_Init>:
#include "HKeypad_config.h"

void Keypad_4_4_Init(void)
{
	/*set Rows as Output Pins */
	DIO_Set_Pin_Direction(ROW_0,OUTPUT);
     6d6:	83 e3       	ldi	r24, 0x33	; 51
     6d8:	60 e0       	ldi	r22, 0x00	; 0
     6da:	41 e0       	ldi	r20, 0x01	; 1
     6dc:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_Set_Pin_Direction>
	DIO_Set_Pin_Direction(ROW_1,OUTPUT);
     6e0:	83 e3       	ldi	r24, 0x33	; 51
     6e2:	61 e0       	ldi	r22, 0x01	; 1
     6e4:	41 e0       	ldi	r20, 0x01	; 1
     6e6:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_Set_Pin_Direction>
	DIO_Set_Pin_Direction(ROW_2,OUTPUT);
     6ea:	83 e3       	ldi	r24, 0x33	; 51
     6ec:	62 e0       	ldi	r22, 0x02	; 2
     6ee:	41 e0       	ldi	r20, 0x01	; 1
     6f0:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_Set_Pin_Direction>
	DIO_Set_Pin_Direction(ROW_3,OUTPUT);
     6f4:	83 e3       	ldi	r24, 0x33	; 51
     6f6:	63 e0       	ldi	r22, 0x03	; 3
     6f8:	41 e0       	ldi	r20, 0x01	; 1
     6fa:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_Set_Pin_Direction>
	
	/*set columns as Input_PULL_UP Pins */
	DIO_Set_Pin_Direction(Col_0,INPUT);
     6fe:	83 e3       	ldi	r24, 0x33	; 51
     700:	64 e0       	ldi	r22, 0x04	; 4
     702:	40 e0       	ldi	r20, 0x00	; 0
     704:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_Set_Pin_Direction>
	DIO_Set_Pin_Direction(Col_1,INPUT);
     708:	83 e3       	ldi	r24, 0x33	; 51
     70a:	65 e0       	ldi	r22, 0x05	; 5
     70c:	40 e0       	ldi	r20, 0x00	; 0
     70e:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_Set_Pin_Direction>
	DIO_Set_Pin_Direction(Col_2,INPUT);
     712:	83 e3       	ldi	r24, 0x33	; 51
     714:	66 e0       	ldi	r22, 0x06	; 6
     716:	40 e0       	ldi	r20, 0x00	; 0
     718:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_Set_Pin_Direction>
	DIO_Set_Pin_Direction(Col_3,INPUT);
     71c:	83 e3       	ldi	r24, 0x33	; 51
     71e:	67 e0       	ldi	r22, 0x07	; 7
     720:	40 e0       	ldi	r20, 0x00	; 0
     722:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_Set_Pin_Direction>
	
	DIO_Set_Pin_Value(Col_0,HIGH);
     726:	83 e3       	ldi	r24, 0x33	; 51
     728:	64 e0       	ldi	r22, 0x04	; 4
     72a:	41 e0       	ldi	r20, 0x01	; 1
     72c:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
	DIO_Set_Pin_Value(Col_1,HIGH);
     730:	83 e3       	ldi	r24, 0x33	; 51
     732:	65 e0       	ldi	r22, 0x05	; 5
     734:	41 e0       	ldi	r20, 0x01	; 1
     736:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
	DIO_Set_Pin_Value(Col_2,HIGH);
     73a:	83 e3       	ldi	r24, 0x33	; 51
     73c:	66 e0       	ldi	r22, 0x06	; 6
     73e:	41 e0       	ldi	r20, 0x01	; 1
     740:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
	DIO_Set_Pin_Value(Col_3,HIGH);
     744:	83 e3       	ldi	r24, 0x33	; 51
     746:	67 e0       	ldi	r22, 0x07	; 7
     748:	41 e0       	ldi	r20, 0x01	; 1
     74a:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
}
     74e:	08 95       	ret

00000750 <Keypad_4_4_Read>:


unsigned char Keypad_4_4_Read(void)
{
     750:	ef 92       	push	r14
     752:	ff 92       	push	r15
     754:	0f 93       	push	r16
     756:	1f 93       	push	r17
     758:	cf 93       	push	r28
     75a:	00 e0       	ldi	r16, 0x00	; 0
     75c:	10 e0       	ldi	r17, 0x00	; 0
		DIO_Set_Pin_Value(ROW_0+ROW,LOW);
		for(COL=0;COL<4;COL++)
		{	
			if(DIO_Get_Pin_value(Col_0+COL)==0)
			{
				keypad_value=keypad_chr[ROW][COL];
     75e:	0f 2e       	mov	r0, r31
     760:	f2 e6       	ldi	r31, 0x62	; 98
     762:	ef 2e       	mov	r14, r31
     764:	f0 e0       	ldi	r31, 0x00	; 0
     766:	ff 2e       	mov	r15, r31
     768:	f0 2d       	mov	r31, r0
	unsigned char COL=0;
	unsigned char keypad_value=0xFF;
	
	for(ROW=0;ROW<4;ROW++)
	{
		DIO_Set_Pin_Value(ROW_0,HIGH);
     76a:	83 e3       	ldi	r24, 0x33	; 51
     76c:	60 e0       	ldi	r22, 0x00	; 0
     76e:	41 e0       	ldi	r20, 0x01	; 1
     770:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
		DIO_Set_Pin_Value(ROW_1,HIGH);
     774:	83 e3       	ldi	r24, 0x33	; 51
     776:	61 e0       	ldi	r22, 0x01	; 1
     778:	41 e0       	ldi	r20, 0x01	; 1
     77a:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
		DIO_Set_Pin_Value(ROW_2,HIGH);
     77e:	83 e3       	ldi	r24, 0x33	; 51
     780:	62 e0       	ldi	r22, 0x02	; 2
     782:	41 e0       	ldi	r20, 0x01	; 1
     784:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
		DIO_Set_Pin_Value(ROW_3,HIGH);
     788:	83 e3       	ldi	r24, 0x33	; 51
     78a:	63 e0       	ldi	r22, 0x03	; 3
     78c:	41 e0       	ldi	r20, 0x01	; 1
     78e:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
		
		DIO_Set_Pin_Value(ROW_0+ROW,LOW);
     792:	83 e3       	ldi	r24, 0x33	; 51
     794:	60 2f       	mov	r22, r16
     796:	40 e0       	ldi	r20, 0x00	; 0
     798:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
		for(COL=0;COL<4;COL++)
     79c:	c0 e0       	ldi	r28, 0x00	; 0
	DIO_Set_Pin_Value(Col_2,HIGH);
	DIO_Set_Pin_Value(Col_3,HIGH);
}


unsigned char Keypad_4_4_Read(void)
     79e:	6c 2f       	mov	r22, r28
     7a0:	6c 5f       	subi	r22, 0xFC	; 252
		DIO_Set_Pin_Value(ROW_3,HIGH);
		
		DIO_Set_Pin_Value(ROW_0+ROW,LOW);
		for(COL=0;COL<4;COL++)
		{	
			if(DIO_Get_Pin_value(Col_0+COL)==0)
     7a2:	83 e3       	ldi	r24, 0x33	; 51
     7a4:	0e 94 57 02 	call	0x4ae	; 0x4ae <DIO_Get_Pin_value>
     7a8:	88 23       	and	r24, r24
     7aa:	71 f4       	brne	.+28     	; 0x7c8 <Keypad_4_4_Read+0x78>
			{
				keypad_value=keypad_chr[ROW][COL];
     7ac:	c8 01       	movw	r24, r16
     7ae:	88 0f       	add	r24, r24
     7b0:	99 1f       	adc	r25, r25
     7b2:	88 0f       	add	r24, r24
     7b4:	99 1f       	adc	r25, r25
     7b6:	8c 0f       	add	r24, r28
     7b8:	91 1d       	adc	r25, r1
     7ba:	f7 01       	movw	r30, r14
     7bc:	e8 0f       	add	r30, r24
     7be:	f9 1f       	adc	r31, r25
     7c0:	80 81       	ld	r24, Z
				break;
			}
		}
		if((keypad_value)!=0xFF)
     7c2:	8f 3f       	cpi	r24, 0xFF	; 255
     7c4:	21 f0       	breq	.+8      	; 0x7ce <Keypad_4_4_Read+0x7e>
     7c6:	09 c0       	rjmp	.+18     	; 0x7da <Keypad_4_4_Read+0x8a>
		DIO_Set_Pin_Value(ROW_1,HIGH);
		DIO_Set_Pin_Value(ROW_2,HIGH);
		DIO_Set_Pin_Value(ROW_3,HIGH);
		
		DIO_Set_Pin_Value(ROW_0+ROW,LOW);
		for(COL=0;COL<4;COL++)
     7c8:	cf 5f       	subi	r28, 0xFF	; 255
     7ca:	c4 30       	cpi	r28, 0x04	; 4
     7cc:	41 f7       	brne	.-48     	; 0x79e <Keypad_4_4_Read+0x4e>
     7ce:	0f 5f       	subi	r16, 0xFF	; 255
     7d0:	1f 4f       	sbci	r17, 0xFF	; 255
{
	unsigned char ROW=0;
	unsigned char COL=0;
	unsigned char keypad_value=0xFF;
	
	for(ROW=0;ROW<4;ROW++)
     7d2:	04 30       	cpi	r16, 0x04	; 4
     7d4:	11 05       	cpc	r17, r1
     7d6:	49 f6       	brne	.-110    	; 0x76a <Keypad_4_4_Read+0x1a>
     7d8:	8f ef       	ldi	r24, 0xFF	; 255
			break;
		}
		
	}
	return keypad_value;
     7da:	cf 91       	pop	r28
     7dc:	1f 91       	pop	r17
     7de:	0f 91       	pop	r16
     7e0:	ff 90       	pop	r15
     7e2:	ef 90       	pop	r14
     7e4:	08 95       	ret

000007e6 <LCD_Enable>:
	}
}

static void LCD_Enable(void)
{
	DIO_Set_Pin_Value(LCD_EN,HIGH);
     7e6:	89 e3       	ldi	r24, 0x39	; 57
     7e8:	65 e0       	ldi	r22, 0x05	; 5
     7ea:	41 e0       	ldi	r20, 0x01	; 1
     7ec:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     7f0:	8f e9       	ldi	r24, 0x9F	; 159
     7f2:	9f e0       	ldi	r25, 0x0F	; 15
     7f4:	01 97       	sbiw	r24, 0x01	; 1
     7f6:	f1 f7       	brne	.-4      	; 0x7f4 <LCD_Enable+0xe>
     7f8:	00 c0       	rjmp	.+0      	; 0x7fa <LCD_Enable+0x14>
     7fa:	00 00       	nop
	_delay_ms(2);
	DIO_Set_Pin_Value(LCD_EN,LOW);
     7fc:	89 e3       	ldi	r24, 0x39	; 57
     7fe:	65 e0       	ldi	r22, 0x05	; 5
     800:	40 e0       	ldi	r20, 0x00	; 0
     802:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
}
     806:	08 95       	ret

00000808 <LCD_send_char>:
	#endif
}	

 // sent character to LCD
 void LCD_send_char(char data)
{
     808:	cf 93       	push	r28
     80a:	c8 2f       	mov	r28, r24
		DIO_SET_HIGH_Nipple_Value(D,data);
		DIO_Set_Pin_Value(D,RS,HIGH);
		LCD_Enable();
	*/
		/*Write High Nipple */
		DIO_Set_Pin_Value(LCD_D4,GET_BIT(data,4));
     80c:	48 2f       	mov	r20, r24
     80e:	42 95       	swap	r20
     810:	4f 70       	andi	r20, 0x0F	; 15
     812:	41 70       	andi	r20, 0x01	; 1
     814:	89 e3       	ldi	r24, 0x39	; 57
     816:	60 e0       	ldi	r22, 0x00	; 0
     818:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
		DIO_Set_Pin_Value(LCD_D5,GET_BIT(data,5));
     81c:	4c 2f       	mov	r20, r28
     81e:	42 95       	swap	r20
     820:	46 95       	lsr	r20
     822:	47 70       	andi	r20, 0x07	; 7
     824:	41 70       	andi	r20, 0x01	; 1
     826:	89 e3       	ldi	r24, 0x39	; 57
     828:	61 e0       	ldi	r22, 0x01	; 1
     82a:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
		DIO_Set_Pin_Value(LCD_D6,GET_BIT(data,6));
     82e:	4c 2f       	mov	r20, r28
     830:	42 95       	swap	r20
     832:	46 95       	lsr	r20
     834:	46 95       	lsr	r20
     836:	43 70       	andi	r20, 0x03	; 3
     838:	41 70       	andi	r20, 0x01	; 1
     83a:	89 e3       	ldi	r24, 0x39	; 57
     83c:	62 e0       	ldi	r22, 0x02	; 2
     83e:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
		DIO_Set_Pin_Value(LCD_D7,GET_BIT(data,7));
     842:	4c 2f       	mov	r20, r28
     844:	44 1f       	adc	r20, r20
     846:	44 27       	eor	r20, r20
     848:	44 1f       	adc	r20, r20
     84a:	89 e3       	ldi	r24, 0x39	; 57
     84c:	63 e0       	ldi	r22, 0x03	; 3
     84e:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
		
		DIO_Set_Pin_Value(LCD_RS,HIGH);
     852:	89 e3       	ldi	r24, 0x39	; 57
     854:	64 e0       	ldi	r22, 0x04	; 4
     856:	41 e0       	ldi	r20, 0x01	; 1
     858:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
		LCD_Enable();
     85c:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <LCD_Enable>
		
		/*Write LOW Nipple */
		DIO_Set_Pin_Value(LCD_D4,GET_BIT(data,0));
     860:	4c 2f       	mov	r20, r28
     862:	41 70       	andi	r20, 0x01	; 1
     864:	89 e3       	ldi	r24, 0x39	; 57
     866:	60 e0       	ldi	r22, 0x00	; 0
     868:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
		DIO_Set_Pin_Value(LCD_D5,GET_BIT(data,1));
     86c:	4c 2f       	mov	r20, r28
     86e:	46 95       	lsr	r20
     870:	41 70       	andi	r20, 0x01	; 1
     872:	89 e3       	ldi	r24, 0x39	; 57
     874:	61 e0       	ldi	r22, 0x01	; 1
     876:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
		DIO_Set_Pin_Value(LCD_D6,GET_BIT(data,2));
     87a:	4c 2f       	mov	r20, r28
     87c:	46 95       	lsr	r20
     87e:	46 95       	lsr	r20
     880:	41 70       	andi	r20, 0x01	; 1
     882:	89 e3       	ldi	r24, 0x39	; 57
     884:	62 e0       	ldi	r22, 0x02	; 2
     886:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
		DIO_Set_Pin_Value(LCD_D7,GET_BIT(data,3));
     88a:	c6 95       	lsr	r28
     88c:	c6 95       	lsr	r28
     88e:	c6 95       	lsr	r28
     890:	4c 2f       	mov	r20, r28
     892:	41 70       	andi	r20, 0x01	; 1
     894:	89 e3       	ldi	r24, 0x39	; 57
     896:	63 e0       	ldi	r22, 0x03	; 3
     898:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>

		DIO_Set_Pin_Value(LCD_RS,HIGH);
     89c:	89 e3       	ldi	r24, 0x39	; 57
     89e:	64 e0       	ldi	r22, 0x04	; 4
     8a0:	41 e0       	ldi	r20, 0x01	; 1
     8a2:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
		LCD_Enable();
     8a6:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <LCD_Enable>
		
	 #endif
}
     8aa:	cf 91       	pop	r28
     8ac:	08 95       	ret

000008ae <LCD_send_string>:

void LCD_send_string(char *data)
{
     8ae:	cf 93       	push	r28
     8b0:	df 93       	push	r29
     8b2:	ec 01       	movw	r28, r24
	while((*data)!='\0')
     8b4:	88 81       	ld	r24, Y
     8b6:	88 23       	and	r24, r24
     8b8:	31 f0       	breq	.+12     	; 0x8c6 <LCD_send_string+0x18>
		LCD_Enable();
		
	 #endif
}

void LCD_send_string(char *data)
     8ba:	21 96       	adiw	r28, 0x01	; 1
{
	while((*data)!='\0')
	{
		LCD_send_char(*data);
     8bc:	0e 94 04 04 	call	0x808	; 0x808 <LCD_send_char>
	 #endif
}

void LCD_send_string(char *data)
{
	while((*data)!='\0')
     8c0:	89 91       	ld	r24, Y+
     8c2:	88 23       	and	r24, r24
     8c4:	d9 f7       	brne	.-10     	; 0x8bc <LCD_send_string+0xe>
	{
		LCD_send_char(*data);
		data++;
		
	}
}
     8c6:	df 91       	pop	r29
     8c8:	cf 91       	pop	r28
     8ca:	08 95       	ret

000008cc <LCD_send_cmd>:
	_delay_ms(2);
	DIO_Set_Pin_Value(LCD_EN,LOW);
}

void LCD_send_cmd(char cmd)
{
     8cc:	cf 93       	push	r28
     8ce:	c8 2f       	mov	r28, r24
	DIO_SET_HIGH_Nipple_Value(D,cmd);
	DIO_Set_Pin_Value(D,RS,LOW);
	LCD_Enable();	
	*/
	/*Write High Nipple */
	DIO_Set_Pin_Value(LCD_D4,GET_BIT(cmd,4));
     8d0:	48 2f       	mov	r20, r24
     8d2:	42 95       	swap	r20
     8d4:	4f 70       	andi	r20, 0x0F	; 15
     8d6:	41 70       	andi	r20, 0x01	; 1
     8d8:	89 e3       	ldi	r24, 0x39	; 57
     8da:	60 e0       	ldi	r22, 0x00	; 0
     8dc:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
	DIO_Set_Pin_Value(LCD_D5,GET_BIT(cmd,5));
     8e0:	4c 2f       	mov	r20, r28
     8e2:	42 95       	swap	r20
     8e4:	46 95       	lsr	r20
     8e6:	47 70       	andi	r20, 0x07	; 7
     8e8:	41 70       	andi	r20, 0x01	; 1
     8ea:	89 e3       	ldi	r24, 0x39	; 57
     8ec:	61 e0       	ldi	r22, 0x01	; 1
     8ee:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
	DIO_Set_Pin_Value(LCD_D6,GET_BIT(cmd,6));
     8f2:	4c 2f       	mov	r20, r28
     8f4:	42 95       	swap	r20
     8f6:	46 95       	lsr	r20
     8f8:	46 95       	lsr	r20
     8fa:	43 70       	andi	r20, 0x03	; 3
     8fc:	41 70       	andi	r20, 0x01	; 1
     8fe:	89 e3       	ldi	r24, 0x39	; 57
     900:	62 e0       	ldi	r22, 0x02	; 2
     902:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
	DIO_Set_Pin_Value(LCD_D7,GET_BIT(cmd,7));
     906:	4c 2f       	mov	r20, r28
     908:	44 1f       	adc	r20, r20
     90a:	44 27       	eor	r20, r20
     90c:	44 1f       	adc	r20, r20
     90e:	89 e3       	ldi	r24, 0x39	; 57
     910:	63 e0       	ldi	r22, 0x03	; 3
     912:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
			
	DIO_Set_Pin_Value(LCD_RS,LOW);
     916:	89 e3       	ldi	r24, 0x39	; 57
     918:	64 e0       	ldi	r22, 0x04	; 4
     91a:	40 e0       	ldi	r20, 0x00	; 0
     91c:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
	LCD_Enable();
     920:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <LCD_Enable>
	
	/*Write LOW Nipple */
	DIO_Set_Pin_Value(LCD_D4,GET_BIT(cmd,0));
     924:	4c 2f       	mov	r20, r28
     926:	41 70       	andi	r20, 0x01	; 1
     928:	89 e3       	ldi	r24, 0x39	; 57
     92a:	60 e0       	ldi	r22, 0x00	; 0
     92c:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
	DIO_Set_Pin_Value(LCD_D5,GET_BIT(cmd,1));
     930:	4c 2f       	mov	r20, r28
     932:	46 95       	lsr	r20
     934:	41 70       	andi	r20, 0x01	; 1
     936:	89 e3       	ldi	r24, 0x39	; 57
     938:	61 e0       	ldi	r22, 0x01	; 1
     93a:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
	DIO_Set_Pin_Value(LCD_D6,GET_BIT(cmd,2));
     93e:	4c 2f       	mov	r20, r28
     940:	46 95       	lsr	r20
     942:	46 95       	lsr	r20
     944:	41 70       	andi	r20, 0x01	; 1
     946:	89 e3       	ldi	r24, 0x39	; 57
     948:	62 e0       	ldi	r22, 0x02	; 2
     94a:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
	DIO_Set_Pin_Value(LCD_D7,GET_BIT(cmd,3));
     94e:	c6 95       	lsr	r28
     950:	c6 95       	lsr	r28
     952:	c6 95       	lsr	r28
     954:	4c 2f       	mov	r20, r28
     956:	41 70       	andi	r20, 0x01	; 1
     958:	89 e3       	ldi	r24, 0x39	; 57
     95a:	63 e0       	ldi	r22, 0x03	; 3
     95c:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>

	DIO_Set_Pin_Value(LCD_RS,LOW);
     960:	89 e3       	ldi	r24, 0x39	; 57
     962:	64 e0       	ldi	r22, 0x04	; 4
     964:	40 e0       	ldi	r20, 0x00	; 0
     966:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
	LCD_Enable();
     96a:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <LCD_Enable>
	
	#endif

}
     96e:	cf 91       	pop	r28
     970:	08 95       	ret

00000972 <LCD_inti>:
     972:	8f ef       	ldi	r24, 0xFF	; 255
     974:	91 ee       	ldi	r25, 0xE1	; 225
     976:	a4 e0       	ldi	r26, 0x04	; 4
     978:	81 50       	subi	r24, 0x01	; 1
     97a:	90 40       	sbci	r25, 0x00	; 0
     97c:	a0 40       	sbci	r26, 0x00	; 0
     97e:	e1 f7       	brne	.-8      	; 0x978 <LCD_inti+0x6>
     980:	00 c0       	rjmp	.+0      	; 0x982 <LCD_inti+0x10>
     982:	00 00       	nop
	LCD_send_cmd(ENTRY_MODE);
	_delay_ms(1);
	
    #elif defined LCD_four_bit
	// Data Pins 
	DIO_Set_Pin_Direction(LCD_D4,OUTPUT);
     984:	89 e3       	ldi	r24, 0x39	; 57
     986:	60 e0       	ldi	r22, 0x00	; 0
     988:	41 e0       	ldi	r20, 0x01	; 1
     98a:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_Set_Pin_Direction>
	DIO_Set_Pin_Direction(LCD_D5,OUTPUT);
     98e:	89 e3       	ldi	r24, 0x39	; 57
     990:	61 e0       	ldi	r22, 0x01	; 1
     992:	41 e0       	ldi	r20, 0x01	; 1
     994:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_Set_Pin_Direction>
	DIO_Set_Pin_Direction(LCD_D6,OUTPUT);
     998:	89 e3       	ldi	r24, 0x39	; 57
     99a:	62 e0       	ldi	r22, 0x02	; 2
     99c:	41 e0       	ldi	r20, 0x01	; 1
     99e:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_Set_Pin_Direction>
	DIO_Set_Pin_Direction(LCD_D7,OUTPUT);
     9a2:	89 e3       	ldi	r24, 0x39	; 57
     9a4:	63 e0       	ldi	r22, 0x03	; 3
     9a6:	41 e0       	ldi	r20, 0x01	; 1
     9a8:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_Set_Pin_Direction>
	// RS & RW & EN
	DIO_Set_Pin_Direction(LCD_EN,OUTPUT);
     9ac:	89 e3       	ldi	r24, 0x39	; 57
     9ae:	65 e0       	ldi	r22, 0x05	; 5
     9b0:	41 e0       	ldi	r20, 0x01	; 1
     9b2:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_Set_Pin_Direction>
	DIO_Set_Pin_Direction(LCD_RS,OUTPUT);
     9b6:	89 e3       	ldi	r24, 0x39	; 57
     9b8:	64 e0       	ldi	r22, 0x04	; 4
     9ba:	41 e0       	ldi	r20, 0x01	; 1
     9bc:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_Set_Pin_Direction>
	DIO_Set_Pin_Direction(LCD_RW,OUTPUT); 
     9c0:	89 e3       	ldi	r24, 0x39	; 57
     9c2:	66 e0       	ldi	r22, 0x06	; 6
     9c4:	41 e0       	ldi	r20, 0x01	; 1
     9c6:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_Set_Pin_Direction>
	DIO_Set_Pin_Value(LCD_RW,LOW);
     9ca:	89 e3       	ldi	r24, 0x39	; 57
     9cc:	66 e0       	ldi	r22, 0x06	; 6
     9ce:	40 e0       	ldi	r20, 0x00	; 0
     9d0:	0e 94 26 02 	call	0x44c	; 0x44c <DIO_Set_Pin_Value>
	// Commands
	LCD_send_cmd(RETURN_HOME);
     9d4:	82 e0       	ldi	r24, 0x02	; 2
     9d6:	0e 94 66 04 	call	0x8cc	; 0x8cc <LCD_send_cmd>
     9da:	af e1       	ldi	r26, 0x1F	; 31
     9dc:	be e4       	ldi	r27, 0x4E	; 78
     9de:	11 97       	sbiw	r26, 0x01	; 1
     9e0:	f1 f7       	brne	.-4      	; 0x9de <LCD_inti+0x6c>
     9e2:	00 c0       	rjmp	.+0      	; 0x9e4 <LCD_inti+0x72>
     9e4:	00 00       	nop
	_delay_ms(10);	
	LCD_send_cmd(FOUR_BITS);
     9e6:	88 e2       	ldi	r24, 0x28	; 40
     9e8:	0e 94 66 04 	call	0x8cc	; 0x8cc <LCD_send_cmd>
     9ec:	8f ec       	ldi	r24, 0xCF	; 207
     9ee:	97 e0       	ldi	r25, 0x07	; 7
     9f0:	01 97       	sbiw	r24, 0x01	; 1
     9f2:	f1 f7       	brne	.-4      	; 0x9f0 <LCD_inti+0x7e>
     9f4:	00 c0       	rjmp	.+0      	; 0x9f6 <LCD_inti+0x84>
     9f6:	00 00       	nop
	_delay_ms(1);
	LCD_send_cmd(display_on_cursor_on);
     9f8:	8e e0       	ldi	r24, 0x0E	; 14
     9fa:	0e 94 66 04 	call	0x8cc	; 0x8cc <LCD_send_cmd>
     9fe:	af ec       	ldi	r26, 0xCF	; 207
     a00:	b7 e0       	ldi	r27, 0x07	; 7
     a02:	11 97       	sbiw	r26, 0x01	; 1
     a04:	f1 f7       	brne	.-4      	; 0xa02 <LCD_inti+0x90>
     a06:	00 c0       	rjmp	.+0      	; 0xa08 <LCD_inti+0x96>
     a08:	00 00       	nop
	_delay_ms(1);
	LCD_send_cmd(CLR_SCREEN);
     a0a:	81 e0       	ldi	r24, 0x01	; 1
     a0c:	0e 94 66 04 	call	0x8cc	; 0x8cc <LCD_send_cmd>
     a10:	8f e1       	ldi	r24, 0x1F	; 31
     a12:	9e e4       	ldi	r25, 0x4E	; 78
     a14:	01 97       	sbiw	r24, 0x01	; 1
     a16:	f1 f7       	brne	.-4      	; 0xa14 <LCD_inti+0xa2>
     a18:	00 c0       	rjmp	.+0      	; 0xa1a <LCD_inti+0xa8>
     a1a:	00 00       	nop
	_delay_ms(10);
	LCD_send_cmd(ENTRY_MODE);
     a1c:	80 e0       	ldi	r24, 0x00	; 0
     a1e:	0e 94 66 04 	call	0x8cc	; 0x8cc <LCD_send_cmd>
     a22:	af ec       	ldi	r26, 0xCF	; 207
     a24:	b7 e0       	ldi	r27, 0x07	; 7
     a26:	11 97       	sbiw	r26, 0x01	; 1
     a28:	f1 f7       	brne	.-4      	; 0xa26 <LCD_inti+0xb4>
     a2a:	00 c0       	rjmp	.+0      	; 0xa2c <LCD_inti+0xba>
     a2c:	00 00       	nop
	_delay_ms(1);
	#endif
}	
     a2e:	08 95       	ret

00000a30 <LCD_clear>:

}

void LCD_clear(void)
{
	LCD_send_cmd(CLR_SCREEN);
     a30:	81 e0       	ldi	r24, 0x01	; 1
     a32:	0e 94 66 04 	call	0x8cc	; 0x8cc <LCD_send_cmd>
	
}
     a36:	08 95       	ret

00000a38 <LCD_move_cursor>:

void LCD_move_cursor(char row, char coloumn)
{
     a38:	cf 93       	push	r28
     a3a:	df 93       	push	r29
     a3c:	0f 92       	push	r0
     a3e:	cd b7       	in	r28, 0x3d	; 61
     a40:	de b7       	in	r29, 0x3e	; 62
	volatile char data;
	if(row==1)
     a42:	81 30       	cpi	r24, 0x01	; 1
     a44:	19 f4       	brne	.+6      	; 0xa4c <LCD_move_cursor+0x14>
	{
		data=0x80+(coloumn-1);
     a46:	61 58       	subi	r22, 0x81	; 129
     a48:	69 83       	std	Y+1, r22	; 0x01
     a4a:	0e c0       	rjmp	.+28     	; 0xa68 <LCD_move_cursor+0x30>
	}
	else if (row==2)
     a4c:	82 30       	cpi	r24, 0x02	; 2
     a4e:	19 f4       	brne	.+6      	; 0xa56 <LCD_move_cursor+0x1e>
	{
		data=0xc0+(coloumn-1);
     a50:	61 54       	subi	r22, 0x41	; 65
     a52:	69 83       	std	Y+1, r22	; 0x01
     a54:	09 c0       	rjmp	.+18     	; 0xa68 <LCD_move_cursor+0x30>
	}
	else if (row>2 || row<1 ||coloumn>16 || coloumn<1)
     a56:	81 50       	subi	r24, 0x01	; 1
     a58:	82 30       	cpi	r24, 0x02	; 2
     a5a:	20 f4       	brcc	.+8      	; 0xa64 <LCD_move_cursor+0x2c>
     a5c:	61 31       	cpi	r22, 0x11	; 17
     a5e:	10 f4       	brcc	.+4      	; 0xa64 <LCD_move_cursor+0x2c>
     a60:	66 23       	and	r22, r22
     a62:	11 f4       	brne	.+4      	; 0xa68 <LCD_move_cursor+0x30>
	{
		data=0x80;
     a64:	80 e8       	ldi	r24, 0x80	; 128
     a66:	89 83       	std	Y+1, r24	; 0x01
	}
	LCD_send_cmd(data);
     a68:	89 81       	ldd	r24, Y+1	; 0x01
     a6a:	0e 94 66 04 	call	0x8cc	; 0x8cc <LCD_send_cmd>
     a6e:	8f ec       	ldi	r24, 0xCF	; 207
     a70:	97 e0       	ldi	r25, 0x07	; 7
     a72:	01 97       	sbiw	r24, 0x01	; 1
     a74:	f1 f7       	brne	.-4      	; 0xa72 <LCD_move_cursor+0x3a>
     a76:	00 c0       	rjmp	.+0      	; 0xa78 <LCD_move_cursor+0x40>
     a78:	00 00       	nop
	_delay_ms(1);
}
     a7a:	0f 90       	pop	r0
     a7c:	df 91       	pop	r29
     a7e:	cf 91       	pop	r28
     a80:	08 95       	ret

00000a82 <lcd_print>:

void lcd_print(char *str)
{
     a82:	0f 93       	push	r16
     a84:	1f 93       	push	r17
     a86:	cf 93       	push	r28
     a88:	8c 01       	movw	r16, r24
	unsigned char i=0;
	while (str[i] |= 0)
     a8a:	fc 01       	movw	r30, r24
     a8c:	80 81       	ld	r24, Z
     a8e:	88 23       	and	r24, r24
     a90:	51 f0       	breq	.+20     	; 0xaa6 <lcd_print+0x24>
	_delay_ms(1);
}

void lcd_print(char *str)
{
	unsigned char i=0;
     a92:	c0 e0       	ldi	r28, 0x00	; 0
	while (str[i] |= 0)
	{
		LCD_send_char(str[i]);
     a94:	0e 94 04 04 	call	0x808	; 0x808 <LCD_send_char>
		i++;
     a98:	cf 5f       	subi	r28, 0xFF	; 255
}

void lcd_print(char *str)
{
	unsigned char i=0;
	while (str[i] |= 0)
     a9a:	f8 01       	movw	r30, r16
     a9c:	ec 0f       	add	r30, r28
     a9e:	f1 1d       	adc	r31, r1
     aa0:	80 81       	ld	r24, Z
     aa2:	88 23       	and	r24, r24
     aa4:	b9 f7       	brne	.-18     	; 0xa94 <lcd_print+0x12>
	{
		LCD_send_char(str[i]);
		i++;
	}
}
     aa6:	cf 91       	pop	r28
     aa8:	1f 91       	pop	r17
     aaa:	0f 91       	pop	r16
     aac:	08 95       	ret

00000aae <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     aae:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     ab0:	03 96       	adiw	r24, 0x03	; 3
     ab2:	92 83       	std	Z+2, r25	; 0x02
     ab4:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     ab6:	2f ef       	ldi	r18, 0xFF	; 255
     ab8:	3f ef       	ldi	r19, 0xFF	; 255
     aba:	34 83       	std	Z+4, r19	; 0x04
     abc:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     abe:	96 83       	std	Z+6, r25	; 0x06
     ac0:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     ac2:	90 87       	std	Z+8, r25	; 0x08
     ac4:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     ac6:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     ac8:	08 95       	ret

00000aca <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     aca:	fc 01       	movw	r30, r24
     acc:	11 86       	std	Z+9, r1	; 0x09
     ace:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     ad0:	08 95       	ret

00000ad2 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     ad2:	cf 93       	push	r28
     ad4:	df 93       	push	r29
     ad6:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     ad8:	dc 01       	movw	r26, r24
     ada:	11 96       	adiw	r26, 0x01	; 1
     adc:	cd 91       	ld	r28, X+
     ade:	dc 91       	ld	r29, X
     ae0:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     ae2:	d3 83       	std	Z+3, r29	; 0x03
     ae4:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     ae6:	2c 81       	ldd	r18, Y+4	; 0x04
     ae8:	3d 81       	ldd	r19, Y+5	; 0x05
     aea:	35 83       	std	Z+5, r19	; 0x05
     aec:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     aee:	ac 81       	ldd	r26, Y+4	; 0x04
     af0:	bd 81       	ldd	r27, Y+5	; 0x05
     af2:	13 96       	adiw	r26, 0x03	; 3
     af4:	7c 93       	st	X, r23
     af6:	6e 93       	st	-X, r22
     af8:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     afa:	7d 83       	std	Y+5, r23	; 0x05
     afc:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     afe:	91 87       	std	Z+9, r25	; 0x09
     b00:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     b02:	fc 01       	movw	r30, r24
     b04:	20 81       	ld	r18, Z
     b06:	2f 5f       	subi	r18, 0xFF	; 255
     b08:	20 83       	st	Z, r18
}
     b0a:	df 91       	pop	r29
     b0c:	cf 91       	pop	r28
     b0e:	08 95       	ret

00000b10 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     b10:	cf 93       	push	r28
     b12:	df 93       	push	r29
     b14:	ac 01       	movw	r20, r24
     b16:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     b18:	28 81       	ld	r18, Y
     b1a:	39 81       	ldd	r19, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     b1c:	8f ef       	ldi	r24, 0xFF	; 255
     b1e:	2f 3f       	cpi	r18, 0xFF	; 255
     b20:	38 07       	cpc	r19, r24
     b22:	21 f4       	brne	.+8      	; 0xb2c <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     b24:	fa 01       	movw	r30, r20
     b26:	a7 81       	ldd	r26, Z+7	; 0x07
     b28:	b0 85       	ldd	r27, Z+8	; 0x08
     b2a:	0d c0       	rjmp	.+26     	; 0xb46 <vListInsert+0x36>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     b2c:	da 01       	movw	r26, r20
     b2e:	13 96       	adiw	r26, 0x03	; 3
     b30:	01 c0       	rjmp	.+2      	; 0xb34 <vListInsert+0x24>
     b32:	df 01       	movw	r26, r30
     b34:	12 96       	adiw	r26, 0x02	; 2
     b36:	ed 91       	ld	r30, X+
     b38:	fc 91       	ld	r31, X
     b3a:	13 97       	sbiw	r26, 0x03	; 3
     b3c:	80 81       	ld	r24, Z
     b3e:	91 81       	ldd	r25, Z+1	; 0x01
     b40:	28 17       	cp	r18, r24
     b42:	39 07       	cpc	r19, r25
     b44:	b0 f7       	brcc	.-20     	; 0xb32 <vListInsert+0x22>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     b46:	12 96       	adiw	r26, 0x02	; 2
     b48:	ed 91       	ld	r30, X+
     b4a:	fc 91       	ld	r31, X
     b4c:	13 97       	sbiw	r26, 0x03	; 3
     b4e:	fb 83       	std	Y+3, r31	; 0x03
     b50:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     b52:	d5 83       	std	Z+5, r29	; 0x05
     b54:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     b56:	bd 83       	std	Y+5, r27	; 0x05
     b58:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     b5a:	13 96       	adiw	r26, 0x03	; 3
     b5c:	dc 93       	st	X, r29
     b5e:	ce 93       	st	-X, r28
     b60:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     b62:	59 87       	std	Y+9, r21	; 0x09
     b64:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
     b66:	fa 01       	movw	r30, r20
     b68:	80 81       	ld	r24, Z
     b6a:	8f 5f       	subi	r24, 0xFF	; 255
     b6c:	80 83       	st	Z, r24
}
     b6e:	df 91       	pop	r29
     b70:	cf 91       	pop	r28
     b72:	08 95       	ret

00000b74 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     b74:	cf 93       	push	r28
     b76:	df 93       	push	r29
     b78:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     b7a:	c0 85       	ldd	r28, Z+8	; 0x08
     b7c:	d1 85       	ldd	r29, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     b7e:	a2 81       	ldd	r26, Z+2	; 0x02
     b80:	b3 81       	ldd	r27, Z+3	; 0x03
     b82:	84 81       	ldd	r24, Z+4	; 0x04
     b84:	95 81       	ldd	r25, Z+5	; 0x05
     b86:	15 96       	adiw	r26, 0x05	; 5
     b88:	9c 93       	st	X, r25
     b8a:	8e 93       	st	-X, r24
     b8c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     b8e:	a4 81       	ldd	r26, Z+4	; 0x04
     b90:	b5 81       	ldd	r27, Z+5	; 0x05
     b92:	82 81       	ldd	r24, Z+2	; 0x02
     b94:	93 81       	ldd	r25, Z+3	; 0x03
     b96:	13 96       	adiw	r26, 0x03	; 3
     b98:	9c 93       	st	X, r25
     b9a:	8e 93       	st	-X, r24
     b9c:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     b9e:	a9 81       	ldd	r26, Y+1	; 0x01
     ba0:	ba 81       	ldd	r27, Y+2	; 0x02
     ba2:	ae 17       	cp	r26, r30
     ba4:	bf 07       	cpc	r27, r31
     ba6:	31 f4       	brne	.+12     	; 0xbb4 <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     ba8:	14 96       	adiw	r26, 0x04	; 4
     baa:	8d 91       	ld	r24, X+
     bac:	9c 91       	ld	r25, X
     bae:	15 97       	sbiw	r26, 0x05	; 5
     bb0:	9a 83       	std	Y+2, r25	; 0x02
     bb2:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     bb4:	11 86       	std	Z+9, r1	; 0x09
     bb6:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     bb8:	88 81       	ld	r24, Y
     bba:	81 50       	subi	r24, 0x01	; 1
     bbc:	88 83       	st	Y, r24

	return pxList->uxNumberOfItems;
}
     bbe:	df 91       	pop	r29
     bc0:	cf 91       	pop	r28
     bc2:	08 95       	ret

00000bc4 <LCD_voidTask>:
		}
	}	
	
}
void LCD_voidTask(void* pv)
{
     bc4:	cf 93       	push	r28
     bc6:	df 93       	push	r29
     bc8:	0f 92       	push	r0
     bca:	cd b7       	in	r28, 0x3d	; 61
     bcc:	de b7       	in	r29, 0x3e	; 62
	/* Initialization */
	u8 Local_u8QueueReceive;
	
	while(1)
	{
		xQueueReceive(My_Queue,&Local_u8QueueReceive,1000);  /* timeout 1 second */
     bce:	80 91 1a 04 	lds	r24, 0x041A
     bd2:	90 91 1b 04 	lds	r25, 0x041B
     bd6:	be 01       	movw	r22, r28
     bd8:	6f 5f       	subi	r22, 0xFF	; 255
     bda:	7f 4f       	sbci	r23, 0xFF	; 255
     bdc:	48 ee       	ldi	r20, 0xE8	; 232
     bde:	53 e0       	ldi	r21, 0x03	; 3
     be0:	20 e0       	ldi	r18, 0x00	; 0
     be2:	0e 94 48 0a 	call	0x1490	; 0x1490 <xQueueGenericReceive>
		LCD_send_char(Local_u8QueueReceive);				/* Send Value Received from Queue to LCD */
     be6:	89 81       	ldd	r24, Y+1	; 0x01
     be8:	0e 94 04 04 	call	0x808	; 0x808 <LCD_send_char>
     bec:	f0 cf       	rjmp	.-32     	; 0xbce <LCD_voidTask+0xa>

00000bee <KeyPad_voidTask>:
    }
}


void KeyPad_voidTask(void* pv)
{
     bee:	cf 93       	push	r28
     bf0:	df 93       	push	r29
     bf2:	0f 92       	push	r0
     bf4:	cd b7       	in	r28, 0x3d	; 61
     bf6:	de b7       	in	r29, 0x3e	; 62
     bf8:	05 e0       	ldi	r16, 0x05	; 5
     bfa:	10 2f       	mov	r17, r16
	
	u8 Local_u8KeyVal;
	u8 count=0;	
	while(1)
	{
		Local_u8KeyVal = Keypad_4_4_Read();
     bfc:	0e 94 a8 03 	call	0x750	; 0x750 <Keypad_4_4_Read>
     c00:	89 83       	std	Y+1, r24	; 0x01
		if ( Local_u8KeyVal != NOT_PRESSED )
     c02:	8f 3f       	cpi	r24, 0xFF	; 255
     c04:	d9 f3       	breq	.-10     	; 0xbfc <KeyPad_voidTask+0xe>
		{
			xQueueSend(My_Queue,&Local_u8KeyVal,1000);  /* timeout 1 second */
     c06:	80 91 1a 04 	lds	r24, 0x041A
     c0a:	90 91 1b 04 	lds	r25, 0x041B
     c0e:	be 01       	movw	r22, r28
     c10:	6f 5f       	subi	r22, 0xFF	; 255
     c12:	7f 4f       	sbci	r23, 0xFF	; 255
     c14:	48 ee       	ldi	r20, 0xE8	; 232
     c16:	53 e0       	ldi	r21, 0x03	; 3
     c18:	20 e0       	ldi	r18, 0x00	; 0
     c1a:	0e 94 2e 09 	call	0x125c	; 0x125c <xQueueGenericSend>
     c1e:	8f ef       	ldi	r24, 0xFF	; 255
     c20:	92 e5       	ldi	r25, 0x52	; 82
     c22:	a7 e0       	ldi	r26, 0x07	; 7
     c24:	81 50       	subi	r24, 0x01	; 1
     c26:	90 40       	sbci	r25, 0x00	; 0
     c28:	a0 40       	sbci	r26, 0x00	; 0
     c2a:	e1 f7       	brne	.-8      	; 0xc24 <KeyPad_voidTask+0x36>
     c2c:	00 c0       	rjmp	.+0      	; 0xc2e <KeyPad_voidTask+0x40>
     c2e:	00 00       	nop
     c30:	11 50       	subi	r17, 0x01	; 1
			_delay_ms(300);
			count++;
			if (count == 5){
     c32:	21 f7       	brne	.-56     	; 0xbfc <KeyPad_voidTask+0xe>
				vTaskDelay(1000);count=0;}
     c34:	88 ee       	ldi	r24, 0xE8	; 232
     c36:	93 e0       	ldi	r25, 0x03	; 3
     c38:	0e 94 a4 10 	call	0x2148	; 0x2148 <vTaskDelay>
     c3c:	de cf       	rjmp	.-68     	; 0xbfa <KeyPad_voidTask+0xc>

00000c3e <main>:
void LCD_voidTask(void* pv);

int main(void)
{
	/* Initialization */
	LCD_inti();
     c3e:	0e 94 b9 04 	call	0x972	; 0x972 <LCD_inti>
	Keypad_4_4_Init();	
     c42:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <Keypad_4_4_Init>
	xTaskCreate(KeyPad_voidTask,"Keypad",100,NULL,2,NULL);  /* Create Keypad Task */
     c46:	87 ef       	ldi	r24, 0xF7	; 247
     c48:	95 e0       	ldi	r25, 0x05	; 5
     c4a:	62 e7       	ldi	r22, 0x72	; 114
     c4c:	70 e0       	ldi	r23, 0x00	; 0
     c4e:	44 e6       	ldi	r20, 0x64	; 100
     c50:	50 e0       	ldi	r21, 0x00	; 0
     c52:	20 e0       	ldi	r18, 0x00	; 0
     c54:	30 e0       	ldi	r19, 0x00	; 0
     c56:	02 e0       	ldi	r16, 0x02	; 2
     c58:	ee 24       	eor	r14, r14
     c5a:	ff 24       	eor	r15, r15
     c5c:	0e 94 99 0c 	call	0x1932	; 0x1932 <xTaskCreate>
	xTaskCreate(LCD_voidTask,"LCD"   ,100,NULL,1,NULL);	/* Create LCD Task    */
     c60:	82 ee       	ldi	r24, 0xE2	; 226
     c62:	95 e0       	ldi	r25, 0x05	; 5
     c64:	69 e7       	ldi	r22, 0x79	; 121
     c66:	70 e0       	ldi	r23, 0x00	; 0
     c68:	44 e6       	ldi	r20, 0x64	; 100
     c6a:	50 e0       	ldi	r21, 0x00	; 0
     c6c:	20 e0       	ldi	r18, 0x00	; 0
     c6e:	30 e0       	ldi	r19, 0x00	; 0
     c70:	01 e0       	ldi	r16, 0x01	; 1
     c72:	0e 94 99 0c 	call	0x1932	; 0x1932 <xTaskCreate>
	
	My_Queue = xQueueCreate(5,sizeof(u8));  /*  Create Queue */
     c76:	85 e0       	ldi	r24, 0x05	; 5
     c78:	61 e0       	ldi	r22, 0x01	; 1
     c7a:	40 e0       	ldi	r20, 0x00	; 0
     c7c:	0e 94 05 09 	call	0x120a	; 0x120a <xQueueGenericCreate>
     c80:	90 93 1b 04 	sts	0x041B, r25
     c84:	80 93 1a 04 	sts	0x041A, r24
	
	
	/* Start Scheduler */
	vTaskStartScheduler();
     c88:	0e 94 0e 0f 	call	0x1e1c	; 0x1e1c <vTaskStartScheduler>
     c8c:	ff cf       	rjmp	.-2      	; 0xc8c <main+0x4e>

00000c8e <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     c8e:	21 e1       	ldi	r18, 0x11	; 17
     c90:	fc 01       	movw	r30, r24
     c92:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     c94:	31 97       	sbiw	r30, 0x01	; 1
     c96:	32 e2       	ldi	r19, 0x22	; 34
     c98:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     c9a:	fc 01       	movw	r30, r24
     c9c:	32 97       	sbiw	r30, 0x02	; 2
     c9e:	a3 e3       	ldi	r26, 0x33	; 51
     ca0:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     ca2:	fc 01       	movw	r30, r24
     ca4:	33 97       	sbiw	r30, 0x03	; 3
     ca6:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     ca8:	fc 01       	movw	r30, r24
     caa:	34 97       	sbiw	r30, 0x04	; 4
     cac:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     cae:	fc 01       	movw	r30, r24
     cb0:	35 97       	sbiw	r30, 0x05	; 5
     cb2:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     cb4:	fc 01       	movw	r30, r24
     cb6:	36 97       	sbiw	r30, 0x06	; 6
     cb8:	60 e8       	ldi	r22, 0x80	; 128
     cba:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     cbc:	fc 01       	movw	r30, r24
     cbe:	37 97       	sbiw	r30, 0x07	; 7
     cc0:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     cc2:	fc 01       	movw	r30, r24
     cc4:	38 97       	sbiw	r30, 0x08	; 8
     cc6:	62 e0       	ldi	r22, 0x02	; 2
     cc8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     cca:	fc 01       	movw	r30, r24
     ccc:	39 97       	sbiw	r30, 0x09	; 9
     cce:	63 e0       	ldi	r22, 0x03	; 3
     cd0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     cd2:	fc 01       	movw	r30, r24
     cd4:	3a 97       	sbiw	r30, 0x0a	; 10
     cd6:	64 e0       	ldi	r22, 0x04	; 4
     cd8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     cda:	fc 01       	movw	r30, r24
     cdc:	3b 97       	sbiw	r30, 0x0b	; 11
     cde:	65 e0       	ldi	r22, 0x05	; 5
     ce0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     ce2:	fc 01       	movw	r30, r24
     ce4:	3c 97       	sbiw	r30, 0x0c	; 12
     ce6:	66 e0       	ldi	r22, 0x06	; 6
     ce8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     cea:	fc 01       	movw	r30, r24
     cec:	3d 97       	sbiw	r30, 0x0d	; 13
     cee:	67 e0       	ldi	r22, 0x07	; 7
     cf0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     cf2:	fc 01       	movw	r30, r24
     cf4:	3e 97       	sbiw	r30, 0x0e	; 14
     cf6:	68 e0       	ldi	r22, 0x08	; 8
     cf8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     cfa:	fc 01       	movw	r30, r24
     cfc:	3f 97       	sbiw	r30, 0x0f	; 15
     cfe:	69 e0       	ldi	r22, 0x09	; 9
     d00:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     d02:	fc 01       	movw	r30, r24
     d04:	70 97       	sbiw	r30, 0x10	; 16
     d06:	60 e1       	ldi	r22, 0x10	; 16
     d08:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     d0a:	fc 01       	movw	r30, r24
     d0c:	71 97       	sbiw	r30, 0x11	; 17
     d0e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     d10:	fc 01       	movw	r30, r24
     d12:	72 97       	sbiw	r30, 0x12	; 18
     d14:	22 e1       	ldi	r18, 0x12	; 18
     d16:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     d18:	fc 01       	movw	r30, r24
     d1a:	73 97       	sbiw	r30, 0x13	; 19
     d1c:	23 e1       	ldi	r18, 0x13	; 19
     d1e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     d20:	fc 01       	movw	r30, r24
     d22:	74 97       	sbiw	r30, 0x14	; 20
     d24:	24 e1       	ldi	r18, 0x14	; 20
     d26:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     d28:	fc 01       	movw	r30, r24
     d2a:	75 97       	sbiw	r30, 0x15	; 21
     d2c:	25 e1       	ldi	r18, 0x15	; 21
     d2e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     d30:	fc 01       	movw	r30, r24
     d32:	76 97       	sbiw	r30, 0x16	; 22
     d34:	26 e1       	ldi	r18, 0x16	; 22
     d36:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     d38:	fc 01       	movw	r30, r24
     d3a:	77 97       	sbiw	r30, 0x17	; 23
     d3c:	27 e1       	ldi	r18, 0x17	; 23
     d3e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     d40:	fc 01       	movw	r30, r24
     d42:	78 97       	sbiw	r30, 0x18	; 24
     d44:	28 e1       	ldi	r18, 0x18	; 24
     d46:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     d48:	fc 01       	movw	r30, r24
     d4a:	79 97       	sbiw	r30, 0x19	; 25
     d4c:	29 e1       	ldi	r18, 0x19	; 25
     d4e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     d50:	fc 01       	movw	r30, r24
     d52:	7a 97       	sbiw	r30, 0x1a	; 26
     d54:	20 e2       	ldi	r18, 0x20	; 32
     d56:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     d58:	fc 01       	movw	r30, r24
     d5a:	7b 97       	sbiw	r30, 0x1b	; 27
     d5c:	21 e2       	ldi	r18, 0x21	; 33
     d5e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     d60:	fc 01       	movw	r30, r24
     d62:	7c 97       	sbiw	r30, 0x1c	; 28
     d64:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     d66:	fc 01       	movw	r30, r24
     d68:	7d 97       	sbiw	r30, 0x1d	; 29
     d6a:	23 e2       	ldi	r18, 0x23	; 35
     d6c:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     d6e:	fc 01       	movw	r30, r24
     d70:	7e 97       	sbiw	r30, 0x1e	; 30
     d72:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     d74:	fc 01       	movw	r30, r24
     d76:	7f 97       	sbiw	r30, 0x1f	; 31
     d78:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     d7a:	fc 01       	movw	r30, r24
     d7c:	b0 97       	sbiw	r30, 0x20	; 32
     d7e:	26 e2       	ldi	r18, 0x26	; 38
     d80:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     d82:	fc 01       	movw	r30, r24
     d84:	b1 97       	sbiw	r30, 0x21	; 33
     d86:	27 e2       	ldi	r18, 0x27	; 39
     d88:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     d8a:	fc 01       	movw	r30, r24
     d8c:	b2 97       	sbiw	r30, 0x22	; 34
     d8e:	28 e2       	ldi	r18, 0x28	; 40
     d90:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     d92:	fc 01       	movw	r30, r24
     d94:	b3 97       	sbiw	r30, 0x23	; 35
     d96:	29 e2       	ldi	r18, 0x29	; 41
     d98:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     d9a:	fc 01       	movw	r30, r24
     d9c:	b4 97       	sbiw	r30, 0x24	; 36
     d9e:	20 e3       	ldi	r18, 0x30	; 48
     da0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     da2:	fc 01       	movw	r30, r24
     da4:	b5 97       	sbiw	r30, 0x25	; 37
     da6:	21 e3       	ldi	r18, 0x31	; 49
     da8:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     daa:	86 97       	sbiw	r24, 0x26	; 38
}
     dac:	08 95       	ret

00000dae <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     dae:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
     db0:	8c e7       	ldi	r24, 0x7C	; 124
     db2:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     db4:	8b e0       	ldi	r24, 0x0B	; 11
     db6:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     db8:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     dba:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     dbc:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     dbe:	a0 91 ab 03 	lds	r26, 0x03AB
     dc2:	b0 91 ac 03 	lds	r27, 0x03AC
     dc6:	cd 91       	ld	r28, X+
     dc8:	cd bf       	out	0x3d, r28	; 61
     dca:	dd 91       	ld	r29, X+
     dcc:	de bf       	out	0x3e, r29	; 62
     dce:	ff 91       	pop	r31
     dd0:	ef 91       	pop	r30
     dd2:	df 91       	pop	r29
     dd4:	cf 91       	pop	r28
     dd6:	bf 91       	pop	r27
     dd8:	af 91       	pop	r26
     dda:	9f 91       	pop	r25
     ddc:	8f 91       	pop	r24
     dde:	7f 91       	pop	r23
     de0:	6f 91       	pop	r22
     de2:	5f 91       	pop	r21
     de4:	4f 91       	pop	r20
     de6:	3f 91       	pop	r19
     de8:	2f 91       	pop	r18
     dea:	1f 91       	pop	r17
     dec:	0f 91       	pop	r16
     dee:	ff 90       	pop	r15
     df0:	ef 90       	pop	r14
     df2:	df 90       	pop	r13
     df4:	cf 90       	pop	r12
     df6:	bf 90       	pop	r11
     df8:	af 90       	pop	r10
     dfa:	9f 90       	pop	r9
     dfc:	8f 90       	pop	r8
     dfe:	7f 90       	pop	r7
     e00:	6f 90       	pop	r6
     e02:	5f 90       	pop	r5
     e04:	4f 90       	pop	r4
     e06:	3f 90       	pop	r3
     e08:	2f 90       	pop	r2
     e0a:	1f 90       	pop	r1
     e0c:	0f 90       	pop	r0
     e0e:	0f be       	out	0x3f, r0	; 63
     e10:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     e12:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     e14:	81 e0       	ldi	r24, 0x01	; 1
     e16:	08 95       	ret

00000e18 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     e18:	08 95       	ret

00000e1a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     e1a:	0f 92       	push	r0
     e1c:	0f b6       	in	r0, 0x3f	; 63
     e1e:	f8 94       	cli
     e20:	0f 92       	push	r0
     e22:	1f 92       	push	r1
     e24:	11 24       	eor	r1, r1
     e26:	2f 92       	push	r2
     e28:	3f 92       	push	r3
     e2a:	4f 92       	push	r4
     e2c:	5f 92       	push	r5
     e2e:	6f 92       	push	r6
     e30:	7f 92       	push	r7
     e32:	8f 92       	push	r8
     e34:	9f 92       	push	r9
     e36:	af 92       	push	r10
     e38:	bf 92       	push	r11
     e3a:	cf 92       	push	r12
     e3c:	df 92       	push	r13
     e3e:	ef 92       	push	r14
     e40:	ff 92       	push	r15
     e42:	0f 93       	push	r16
     e44:	1f 93       	push	r17
     e46:	2f 93       	push	r18
     e48:	3f 93       	push	r19
     e4a:	4f 93       	push	r20
     e4c:	5f 93       	push	r21
     e4e:	6f 93       	push	r22
     e50:	7f 93       	push	r23
     e52:	8f 93       	push	r24
     e54:	9f 93       	push	r25
     e56:	af 93       	push	r26
     e58:	bf 93       	push	r27
     e5a:	cf 93       	push	r28
     e5c:	df 93       	push	r29
     e5e:	ef 93       	push	r30
     e60:	ff 93       	push	r31
     e62:	a0 91 ab 03 	lds	r26, 0x03AB
     e66:	b0 91 ac 03 	lds	r27, 0x03AC
     e6a:	0d b6       	in	r0, 0x3d	; 61
     e6c:	0d 92       	st	X+, r0
     e6e:	0e b6       	in	r0, 0x3e	; 62
     e70:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     e72:	0e 94 f7 10 	call	0x21ee	; 0x21ee <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     e76:	a0 91 ab 03 	lds	r26, 0x03AB
     e7a:	b0 91 ac 03 	lds	r27, 0x03AC
     e7e:	cd 91       	ld	r28, X+
     e80:	cd bf       	out	0x3d, r28	; 61
     e82:	dd 91       	ld	r29, X+
     e84:	de bf       	out	0x3e, r29	; 62
     e86:	ff 91       	pop	r31
     e88:	ef 91       	pop	r30
     e8a:	df 91       	pop	r29
     e8c:	cf 91       	pop	r28
     e8e:	bf 91       	pop	r27
     e90:	af 91       	pop	r26
     e92:	9f 91       	pop	r25
     e94:	8f 91       	pop	r24
     e96:	7f 91       	pop	r23
     e98:	6f 91       	pop	r22
     e9a:	5f 91       	pop	r21
     e9c:	4f 91       	pop	r20
     e9e:	3f 91       	pop	r19
     ea0:	2f 91       	pop	r18
     ea2:	1f 91       	pop	r17
     ea4:	0f 91       	pop	r16
     ea6:	ff 90       	pop	r15
     ea8:	ef 90       	pop	r14
     eaa:	df 90       	pop	r13
     eac:	cf 90       	pop	r12
     eae:	bf 90       	pop	r11
     eb0:	af 90       	pop	r10
     eb2:	9f 90       	pop	r9
     eb4:	8f 90       	pop	r8
     eb6:	7f 90       	pop	r7
     eb8:	6f 90       	pop	r6
     eba:	5f 90       	pop	r5
     ebc:	4f 90       	pop	r4
     ebe:	3f 90       	pop	r3
     ec0:	2f 90       	pop	r2
     ec2:	1f 90       	pop	r1
     ec4:	0f 90       	pop	r0
     ec6:	0f be       	out	0x3f, r0	; 63
     ec8:	0f 90       	pop	r0

	asm volatile ( "ret" );
     eca:	08 95       	ret

00000ecc <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     ecc:	0f 92       	push	r0
     ece:	0f b6       	in	r0, 0x3f	; 63
     ed0:	f8 94       	cli
     ed2:	0f 92       	push	r0
     ed4:	1f 92       	push	r1
     ed6:	11 24       	eor	r1, r1
     ed8:	2f 92       	push	r2
     eda:	3f 92       	push	r3
     edc:	4f 92       	push	r4
     ede:	5f 92       	push	r5
     ee0:	6f 92       	push	r6
     ee2:	7f 92       	push	r7
     ee4:	8f 92       	push	r8
     ee6:	9f 92       	push	r9
     ee8:	af 92       	push	r10
     eea:	bf 92       	push	r11
     eec:	cf 92       	push	r12
     eee:	df 92       	push	r13
     ef0:	ef 92       	push	r14
     ef2:	ff 92       	push	r15
     ef4:	0f 93       	push	r16
     ef6:	1f 93       	push	r17
     ef8:	2f 93       	push	r18
     efa:	3f 93       	push	r19
     efc:	4f 93       	push	r20
     efe:	5f 93       	push	r21
     f00:	6f 93       	push	r22
     f02:	7f 93       	push	r23
     f04:	8f 93       	push	r24
     f06:	9f 93       	push	r25
     f08:	af 93       	push	r26
     f0a:	bf 93       	push	r27
     f0c:	cf 93       	push	r28
     f0e:	df 93       	push	r29
     f10:	ef 93       	push	r30
     f12:	ff 93       	push	r31
     f14:	a0 91 ab 03 	lds	r26, 0x03AB
     f18:	b0 91 ac 03 	lds	r27, 0x03AC
     f1c:	0d b6       	in	r0, 0x3d	; 61
     f1e:	0d 92       	st	X+, r0
     f20:	0e b6       	in	r0, 0x3e	; 62
     f22:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     f24:	0e 94 5e 0f 	call	0x1ebc	; 0x1ebc <xTaskIncrementTick>
     f28:	88 23       	and	r24, r24
     f2a:	11 f0       	breq	.+4      	; 0xf30 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     f2c:	0e 94 f7 10 	call	0x21ee	; 0x21ee <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     f30:	a0 91 ab 03 	lds	r26, 0x03AB
     f34:	b0 91 ac 03 	lds	r27, 0x03AC
     f38:	cd 91       	ld	r28, X+
     f3a:	cd bf       	out	0x3d, r28	; 61
     f3c:	dd 91       	ld	r29, X+
     f3e:	de bf       	out	0x3e, r29	; 62
     f40:	ff 91       	pop	r31
     f42:	ef 91       	pop	r30
     f44:	df 91       	pop	r29
     f46:	cf 91       	pop	r28
     f48:	bf 91       	pop	r27
     f4a:	af 91       	pop	r26
     f4c:	9f 91       	pop	r25
     f4e:	8f 91       	pop	r24
     f50:	7f 91       	pop	r23
     f52:	6f 91       	pop	r22
     f54:	5f 91       	pop	r21
     f56:	4f 91       	pop	r20
     f58:	3f 91       	pop	r19
     f5a:	2f 91       	pop	r18
     f5c:	1f 91       	pop	r17
     f5e:	0f 91       	pop	r16
     f60:	ff 90       	pop	r15
     f62:	ef 90       	pop	r14
     f64:	df 90       	pop	r13
     f66:	cf 90       	pop	r12
     f68:	bf 90       	pop	r11
     f6a:	af 90       	pop	r10
     f6c:	9f 90       	pop	r9
     f6e:	8f 90       	pop	r8
     f70:	7f 90       	pop	r7
     f72:	6f 90       	pop	r6
     f74:	5f 90       	pop	r5
     f76:	4f 90       	pop	r4
     f78:	3f 90       	pop	r3
     f7a:	2f 90       	pop	r2
     f7c:	1f 90       	pop	r1
     f7e:	0f 90       	pop	r0
     f80:	0f be       	out	0x3f, r0	; 63
     f82:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f84:	08 95       	ret

00000f86 <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal ) );
	void TIMER1_COMPA_vect( void )
	{
     f86:	1f 92       	push	r1
     f88:	0f 92       	push	r0
     f8a:	0f b6       	in	r0, 0x3f	; 63
     f8c:	0f 92       	push	r0
     f8e:	11 24       	eor	r1, r1
     f90:	2f 93       	push	r18
     f92:	3f 93       	push	r19
     f94:	4f 93       	push	r20
     f96:	5f 93       	push	r21
     f98:	6f 93       	push	r22
     f9a:	7f 93       	push	r23
     f9c:	8f 93       	push	r24
     f9e:	9f 93       	push	r25
     fa0:	af 93       	push	r26
     fa2:	bf 93       	push	r27
     fa4:	ef 93       	push	r30
     fa6:	ff 93       	push	r31
		xTaskIncrementTick();
     fa8:	0e 94 5e 0f 	call	0x1ebc	; 0x1ebc <xTaskIncrementTick>
	}
     fac:	ff 91       	pop	r31
     fae:	ef 91       	pop	r30
     fb0:	bf 91       	pop	r27
     fb2:	af 91       	pop	r26
     fb4:	9f 91       	pop	r25
     fb6:	8f 91       	pop	r24
     fb8:	7f 91       	pop	r23
     fba:	6f 91       	pop	r22
     fbc:	5f 91       	pop	r21
     fbe:	4f 91       	pop	r20
     fc0:	3f 91       	pop	r19
     fc2:	2f 91       	pop	r18
     fc4:	0f 90       	pop	r0
     fc6:	0f be       	out	0x3f, r0	; 63
     fc8:	0f 90       	pop	r0
     fca:	1f 90       	pop	r1
     fcc:	18 95       	reti

00000fce <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     fce:	0f b6       	in	r0, 0x3f	; 63
     fd0:	f8 94       	cli
     fd2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     fd4:	fc 01       	movw	r30, r24
     fd6:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     fd8:	0f 90       	pop	r0
     fda:	0f be       	out	0x3f, r0	; 63

	taskENTER_CRITICAL();
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
		{
			xReturn = pdTRUE;
     fdc:	81 e0       	ldi	r24, 0x01	; 1
     fde:	91 11       	cpse	r25, r1
     fe0:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();

	return xReturn;
}
     fe2:	08 95       	ret

00000fe4 <prvCopyDataFromQueue>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     fe4:	fc 01       	movw	r30, r24
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     fe6:	44 8d       	ldd	r20, Z+28	; 0x1c
     fe8:	44 23       	and	r20, r20
     fea:	c1 f0       	breq	.+48     	; 0x101c <prvCopyDataFromQueue+0x38>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     fec:	26 81       	ldd	r18, Z+6	; 0x06
     fee:	37 81       	ldd	r19, Z+7	; 0x07
     ff0:	24 0f       	add	r18, r20
     ff2:	31 1d       	adc	r19, r1
     ff4:	37 83       	std	Z+7, r19	; 0x07
     ff6:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     ff8:	a2 81       	ldd	r26, Z+2	; 0x02
     ffa:	b3 81       	ldd	r27, Z+3	; 0x03
     ffc:	2a 17       	cp	r18, r26
     ffe:	3b 07       	cpc	r19, r27
    1000:	20 f0       	brcs	.+8      	; 0x100a <prvCopyDataFromQueue+0x26>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1002:	20 81       	ld	r18, Z
    1004:	31 81       	ldd	r19, Z+1	; 0x01
    1006:	37 83       	std	Z+7, r19	; 0x07
    1008:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    100a:	36 81       	ldd	r19, Z+6	; 0x06
    100c:	27 81       	ldd	r18, Z+7	; 0x07
    100e:	86 2f       	mov	r24, r22
    1010:	97 2f       	mov	r25, r23
    1012:	63 2f       	mov	r22, r19
    1014:	72 2f       	mov	r23, r18
    1016:	50 e0       	ldi	r21, 0x00	; 0
    1018:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <memcpy>
    101c:	08 95       	ret

0000101e <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    101e:	ef 92       	push	r14
    1020:	ff 92       	push	r15
    1022:	0f 93       	push	r16
    1024:	1f 93       	push	r17
    1026:	cf 93       	push	r28
    1028:	8c 01       	movw	r16, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    102a:	0f b6       	in	r0, 0x3f	; 63
    102c:	f8 94       	cli
    102e:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1030:	fc 01       	movw	r30, r24
    1032:	c6 8d       	ldd	r28, Z+30	; 0x1e

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1034:	1c 16       	cp	r1, r28
    1036:	cc f4       	brge	.+50     	; 0x106a <prvUnlockQueue+0x4c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1038:	81 89       	ldd	r24, Z+17	; 0x11
    103a:	88 23       	and	r24, r24
    103c:	31 f4       	brne	.+12     	; 0x104a <prvUnlockQueue+0x2c>
    103e:	15 c0       	rjmp	.+42     	; 0x106a <prvUnlockQueue+0x4c>
    1040:	f8 01       	movw	r30, r16
    1042:	81 89       	ldd	r24, Z+17	; 0x11
    1044:	88 23       	and	r24, r24
    1046:	41 f4       	brne	.+16     	; 0x1058 <prvUnlockQueue+0x3a>
    1048:	10 c0       	rjmp	.+32     	; 0x106a <prvUnlockQueue+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    104a:	0f 2e       	mov	r0, r31
    104c:	f1 e1       	ldi	r31, 0x11	; 17
    104e:	ef 2e       	mov	r14, r31
    1050:	ff 24       	eor	r15, r15
    1052:	f0 2d       	mov	r31, r0
    1054:	e0 0e       	add	r14, r16
    1056:	f1 1e       	adc	r15, r17
    1058:	c7 01       	movw	r24, r14
    105a:	0e 94 cd 11 	call	0x239a	; 0x239a <xTaskRemoveFromEventList>
    105e:	88 23       	and	r24, r24
    1060:	11 f0       	breq	.+4      	; 0x1066 <prvUnlockQueue+0x48>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    1062:	0e 94 92 12 	call	0x2524	; 0x2524 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    1066:	c1 50       	subi	r28, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1068:	59 f7       	brne	.-42     	; 0x1040 <prvUnlockQueue+0x22>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    106a:	8f ef       	ldi	r24, 0xFF	; 255
    106c:	f8 01       	movw	r30, r16
    106e:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1070:	0f 90       	pop	r0
    1072:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1074:	0f b6       	in	r0, 0x3f	; 63
    1076:	f8 94       	cli
    1078:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    107a:	f8 01       	movw	r30, r16
    107c:	c5 8d       	ldd	r28, Z+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
    107e:	1c 16       	cp	r1, r28
    1080:	c4 f4       	brge	.+48     	; 0x10b2 <prvUnlockQueue+0x94>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1082:	80 85       	ldd	r24, Z+8	; 0x08
    1084:	88 23       	and	r24, r24
    1086:	31 f4       	brne	.+12     	; 0x1094 <prvUnlockQueue+0x76>
    1088:	14 c0       	rjmp	.+40     	; 0x10b2 <prvUnlockQueue+0x94>
    108a:	f8 01       	movw	r30, r16
    108c:	80 85       	ldd	r24, Z+8	; 0x08
    108e:	88 23       	and	r24, r24
    1090:	39 f4       	brne	.+14     	; 0x10a0 <prvUnlockQueue+0x82>
    1092:	0f c0       	rjmp	.+30     	; 0x10b2 <prvUnlockQueue+0x94>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1094:	ee 24       	eor	r14, r14
    1096:	ff 24       	eor	r15, r15
    1098:	68 94       	set
    109a:	e3 f8       	bld	r14, 3
    109c:	e0 0e       	add	r14, r16
    109e:	f1 1e       	adc	r15, r17
    10a0:	c7 01       	movw	r24, r14
    10a2:	0e 94 cd 11 	call	0x239a	; 0x239a <xTaskRemoveFromEventList>
    10a6:	88 23       	and	r24, r24
    10a8:	11 f0       	breq	.+4      	; 0x10ae <prvUnlockQueue+0x90>
				{
					vTaskMissedYield();
    10aa:	0e 94 92 12 	call	0x2524	; 0x2524 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    10ae:	c1 50       	subi	r28, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    10b0:	61 f7       	brne	.-40     	; 0x108a <prvUnlockQueue+0x6c>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    10b2:	8f ef       	ldi	r24, 0xFF	; 255
    10b4:	f8 01       	movw	r30, r16
    10b6:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    10b8:	0f 90       	pop	r0
    10ba:	0f be       	out	0x3f, r0	; 63
}
    10bc:	cf 91       	pop	r28
    10be:	1f 91       	pop	r17
    10c0:	0f 91       	pop	r16
    10c2:	ff 90       	pop	r15
    10c4:	ef 90       	pop	r14
    10c6:	08 95       	ret

000010c8 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    10c8:	0f 93       	push	r16
    10ca:	1f 93       	push	r17
    10cc:	cf 93       	push	r28
    10ce:	df 93       	push	r29
    10d0:	ec 01       	movw	r28, r24
    10d2:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    10d4:	0a 8d       	ldd	r16, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    10d6:	4c 8d       	ldd	r20, Y+28	; 0x1c
    10d8:	44 23       	and	r20, r20
    10da:	61 f4       	brne	.+24     	; 0x10f4 <prvCopyDataToQueue+0x2c>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    10dc:	88 81       	ld	r24, Y
    10de:	99 81       	ldd	r25, Y+1	; 0x01
    10e0:	00 97       	sbiw	r24, 0x00	; 0
    10e2:	09 f0       	breq	.+2      	; 0x10e6 <prvCopyDataToQueue+0x1e>
    10e4:	42 c0       	rjmp	.+132    	; 0x116a <prvCopyDataToQueue+0xa2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    10e6:	8a 81       	ldd	r24, Y+2	; 0x02
    10e8:	9b 81       	ldd	r25, Y+3	; 0x03
    10ea:	0e 94 f9 12 	call	0x25f2	; 0x25f2 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    10ee:	1b 82       	std	Y+3, r1	; 0x03
    10f0:	1a 82       	std	Y+2, r1	; 0x02
    10f2:	42 c0       	rjmp	.+132    	; 0x1178 <prvCopyDataToQueue+0xb0>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    10f4:	11 23       	and	r17, r17
    10f6:	b9 f4       	brne	.+46     	; 0x1126 <prvCopyDataToQueue+0x5e>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    10f8:	8c 81       	ldd	r24, Y+4	; 0x04
    10fa:	9d 81       	ldd	r25, Y+5	; 0x05
    10fc:	50 e0       	ldi	r21, 0x00	; 0
    10fe:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1102:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1104:	8c 81       	ldd	r24, Y+4	; 0x04
    1106:	9d 81       	ldd	r25, Y+5	; 0x05
    1108:	82 0f       	add	r24, r18
    110a:	91 1d       	adc	r25, r1
    110c:	9d 83       	std	Y+5, r25	; 0x05
    110e:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1110:	2a 81       	ldd	r18, Y+2	; 0x02
    1112:	3b 81       	ldd	r19, Y+3	; 0x03
    1114:	82 17       	cp	r24, r18
    1116:	93 07       	cpc	r25, r19
    1118:	50 f1       	brcs	.+84     	; 0x116e <prvCopyDataToQueue+0xa6>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    111a:	88 81       	ld	r24, Y
    111c:	99 81       	ldd	r25, Y+1	; 0x01
    111e:	9d 83       	std	Y+5, r25	; 0x05
    1120:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1122:	80 e0       	ldi	r24, 0x00	; 0
    1124:	29 c0       	rjmp	.+82     	; 0x1178 <prvCopyDataToQueue+0xb0>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1126:	8e 81       	ldd	r24, Y+6	; 0x06
    1128:	9f 81       	ldd	r25, Y+7	; 0x07
    112a:	50 e0       	ldi	r21, 0x00	; 0
    112c:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    1130:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1132:	50 e0       	ldi	r21, 0x00	; 0
    1134:	50 95       	com	r21
    1136:	41 95       	neg	r20
    1138:	5f 4f       	sbci	r21, 0xFF	; 255
    113a:	8e 81       	ldd	r24, Y+6	; 0x06
    113c:	9f 81       	ldd	r25, Y+7	; 0x07
    113e:	84 0f       	add	r24, r20
    1140:	95 1f       	adc	r25, r21
    1142:	9f 83       	std	Y+7, r25	; 0x07
    1144:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1146:	28 81       	ld	r18, Y
    1148:	39 81       	ldd	r19, Y+1	; 0x01
    114a:	82 17       	cp	r24, r18
    114c:	93 07       	cpc	r25, r19
    114e:	30 f4       	brcc	.+12     	; 0x115c <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1150:	8a 81       	ldd	r24, Y+2	; 0x02
    1152:	9b 81       	ldd	r25, Y+3	; 0x03
    1154:	84 0f       	add	r24, r20
    1156:	95 1f       	adc	r25, r21
    1158:	9f 83       	std	Y+7, r25	; 0x07
    115a:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    115c:	12 30       	cpi	r17, 0x02	; 2
    115e:	49 f4       	brne	.+18     	; 0x1172 <prvCopyDataToQueue+0xaa>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1160:	00 23       	and	r16, r16
    1162:	49 f0       	breq	.+18     	; 0x1176 <prvCopyDataToQueue+0xae>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    1164:	01 50       	subi	r16, 0x01	; 1
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1166:	80 e0       	ldi	r24, 0x00	; 0
    1168:	07 c0       	rjmp	.+14     	; 0x1178 <prvCopyDataToQueue+0xb0>
    116a:	80 e0       	ldi	r24, 0x00	; 0
    116c:	05 c0       	rjmp	.+10     	; 0x1178 <prvCopyDataToQueue+0xb0>
    116e:	80 e0       	ldi	r24, 0x00	; 0
    1170:	03 c0       	rjmp	.+6      	; 0x1178 <prvCopyDataToQueue+0xb0>
    1172:	80 e0       	ldi	r24, 0x00	; 0
    1174:	01 c0       	rjmp	.+2      	; 0x1178 <prvCopyDataToQueue+0xb0>
    1176:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    1178:	0f 5f       	subi	r16, 0xFF	; 255
    117a:	0a 8f       	std	Y+26, r16	; 0x1a

	return xReturn;
}
    117c:	df 91       	pop	r29
    117e:	cf 91       	pop	r28
    1180:	1f 91       	pop	r17
    1182:	0f 91       	pop	r16
    1184:	08 95       	ret

00001186 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1186:	cf 93       	push	r28
    1188:	df 93       	push	r29
    118a:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    118c:	0f b6       	in	r0, 0x3f	; 63
    118e:	f8 94       	cli
    1190:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1192:	48 81       	ld	r20, Y
    1194:	59 81       	ldd	r21, Y+1	; 0x01
    1196:	2b 8d       	ldd	r18, Y+27	; 0x1b
    1198:	30 e0       	ldi	r19, 0x00	; 0
    119a:	ec 8d       	ldd	r30, Y+28	; 0x1c
    119c:	f0 e0       	ldi	r31, 0x00	; 0
    119e:	2e 9f       	mul	r18, r30
    11a0:	c0 01       	movw	r24, r0
    11a2:	2f 9f       	mul	r18, r31
    11a4:	90 0d       	add	r25, r0
    11a6:	3e 9f       	mul	r19, r30
    11a8:	90 0d       	add	r25, r0
    11aa:	11 24       	eor	r1, r1
    11ac:	84 0f       	add	r24, r20
    11ae:	95 1f       	adc	r25, r21
    11b0:	9b 83       	std	Y+3, r25	; 0x03
    11b2:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    11b4:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    11b6:	5d 83       	std	Y+5, r21	; 0x05
    11b8:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    11ba:	c9 01       	movw	r24, r18
    11bc:	01 97       	sbiw	r24, 0x01	; 1
    11be:	e8 9f       	mul	r30, r24
    11c0:	90 01       	movw	r18, r0
    11c2:	e9 9f       	mul	r30, r25
    11c4:	30 0d       	add	r19, r0
    11c6:	f8 9f       	mul	r31, r24
    11c8:	30 0d       	add	r19, r0
    11ca:	11 24       	eor	r1, r1
    11cc:	24 0f       	add	r18, r20
    11ce:	35 1f       	adc	r19, r21
    11d0:	3f 83       	std	Y+7, r19	; 0x07
    11d2:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    11d4:	8f ef       	ldi	r24, 0xFF	; 255
    11d6:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    11d8:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    11da:	66 23       	and	r22, r22
    11dc:	41 f4       	brne	.+16     	; 0x11ee <xQueueGenericReset+0x68>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    11de:	88 85       	ldd	r24, Y+8	; 0x08
    11e0:	88 23       	and	r24, r24
    11e2:	69 f0       	breq	.+26     	; 0x11fe <xQueueGenericReset+0x78>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    11e4:	ce 01       	movw	r24, r28
    11e6:	08 96       	adiw	r24, 0x08	; 8
    11e8:	0e 94 cd 11 	call	0x239a	; 0x239a <xTaskRemoveFromEventList>
    11ec:	08 c0       	rjmp	.+16     	; 0x11fe <xQueueGenericReset+0x78>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    11ee:	ce 01       	movw	r24, r28
    11f0:	08 96       	adiw	r24, 0x08	; 8
    11f2:	0e 94 57 05 	call	0xaae	; 0xaae <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    11f6:	ce 01       	movw	r24, r28
    11f8:	41 96       	adiw	r24, 0x11	; 17
    11fa:	0e 94 57 05 	call	0xaae	; 0xaae <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    11fe:	0f 90       	pop	r0
    1200:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1202:	81 e0       	ldi	r24, 0x01	; 1
    1204:	df 91       	pop	r29
    1206:	cf 91       	pop	r28
    1208:	08 95       	ret

0000120a <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    120a:	0f 93       	push	r16
    120c:	1f 93       	push	r17
    120e:	cf 93       	push	r28
    1210:	df 93       	push	r29
    1212:	08 2f       	mov	r16, r24
    1214:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1216:	66 23       	and	r22, r22
    1218:	21 f0       	breq	.+8      	; 0x1222 <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    121a:	68 9f       	mul	r22, r24
    121c:	c0 01       	movw	r24, r0
    121e:	11 24       	eor	r1, r1
    1220:	02 c0       	rjmp	.+4      	; 0x1226 <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1222:	80 e0       	ldi	r24, 0x00	; 0
    1224:	90 e0       	ldi	r25, 0x00	; 0
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    1226:	4f 96       	adiw	r24, 0x1f	; 31
    1228:	0e 94 92 02 	call	0x524	; 0x524 <pvPortMalloc>
    122c:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    122e:	00 97       	sbiw	r24, 0x00	; 0
    1230:	71 f0       	breq	.+28     	; 0x124e <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1232:	11 23       	and	r17, r17
    1234:	19 f4       	brne	.+6      	; 0x123c <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1236:	99 83       	std	Y+1, r25	; 0x01
    1238:	88 83       	st	Y, r24
    123a:	03 c0       	rjmp	.+6      	; 0x1242 <xQueueGenericCreate+0x38>

		if( pxNewQueue != NULL )
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
    123c:	4f 96       	adiw	r24, 0x1f	; 31
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    123e:	99 83       	std	Y+1, r25	; 0x01
    1240:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1242:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1244:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1246:	ce 01       	movw	r24, r28
    1248:	61 e0       	ldi	r22, 0x01	; 1
    124a:	0e 94 c3 08 	call	0x1186	; 0x1186 <xQueueGenericReset>

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
	}
    124e:	8c 2f       	mov	r24, r28
    1250:	9d 2f       	mov	r25, r29
    1252:	df 91       	pop	r29
    1254:	cf 91       	pop	r28
    1256:	1f 91       	pop	r17
    1258:	0f 91       	pop	r16
    125a:	08 95       	ret

0000125c <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    125c:	8f 92       	push	r8
    125e:	9f 92       	push	r9
    1260:	bf 92       	push	r11
    1262:	cf 92       	push	r12
    1264:	df 92       	push	r13
    1266:	ef 92       	push	r14
    1268:	ff 92       	push	r15
    126a:	0f 93       	push	r16
    126c:	1f 93       	push	r17
    126e:	cf 93       	push	r28
    1270:	df 93       	push	r29
    1272:	00 d0       	rcall	.+0      	; 0x1274 <xQueueGenericSend+0x18>
    1274:	00 d0       	rcall	.+0      	; 0x1276 <xQueueGenericSend+0x1a>
    1276:	0f 92       	push	r0
    1278:	cd b7       	in	r28, 0x3d	; 61
    127a:	de b7       	in	r29, 0x3e	; 62
    127c:	8c 01       	movw	r16, r24
    127e:	4b 01       	movw	r8, r22
    1280:	5d 83       	std	Y+5, r21	; 0x05
    1282:	4c 83       	std	Y+4, r20	; 0x04
    1284:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1286:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1288:	bb 24       	eor	r11, r11
    128a:	b3 94       	inc	r11
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    128c:	cc 24       	eor	r12, r12
    128e:	dd 24       	eor	r13, r13
    1290:	68 94       	set
    1292:	c3 f8       	bld	r12, 3
    1294:	c8 0e       	add	r12, r24
    1296:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1298:	0f b6       	in	r0, 0x3f	; 63
    129a:	f8 94       	cli
    129c:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    129e:	f8 01       	movw	r30, r16
    12a0:	92 8d       	ldd	r25, Z+26	; 0x1a
    12a2:	83 8d       	ldd	r24, Z+27	; 0x1b
    12a4:	98 17       	cp	r25, r24
    12a6:	18 f0       	brcs	.+6      	; 0x12ae <xQueueGenericSend+0x52>
    12a8:	f2 e0       	ldi	r31, 0x02	; 2
    12aa:	ef 16       	cp	r14, r31
    12ac:	89 f4       	brne	.+34     	; 0x12d0 <xQueueGenericSend+0x74>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    12ae:	c8 01       	movw	r24, r16
    12b0:	b4 01       	movw	r22, r8
    12b2:	4e 2d       	mov	r20, r14
    12b4:	0e 94 64 08 	call	0x10c8	; 0x10c8 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12b8:	f8 01       	movw	r30, r16
    12ba:	81 89       	ldd	r24, Z+17	; 0x11
    12bc:	88 23       	and	r24, r24
    12be:	21 f0       	breq	.+8      	; 0x12c8 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12c0:	c8 01       	movw	r24, r16
    12c2:	41 96       	adiw	r24, 0x11	; 17
    12c4:	0e 94 cd 11 	call	0x239a	; 0x239a <xTaskRemoveFromEventList>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    12c8:	0f 90       	pop	r0
    12ca:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    12cc:	81 e0       	ldi	r24, 0x01	; 1
    12ce:	52 c0       	rjmp	.+164    	; 0x1374 <xQueueGenericSend+0x118>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    12d0:	8c 81       	ldd	r24, Y+4	; 0x04
    12d2:	9d 81       	ldd	r25, Y+5	; 0x05
    12d4:	00 97       	sbiw	r24, 0x00	; 0
    12d6:	21 f4       	brne	.+8      	; 0x12e0 <xQueueGenericSend+0x84>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    12d8:	0f 90       	pop	r0
    12da:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    12dc:	80 e0       	ldi	r24, 0x00	; 0
    12de:	4a c0       	rjmp	.+148    	; 0x1374 <xQueueGenericSend+0x118>
				}
				else if( xEntryTimeSet == pdFALSE )
    12e0:	ff 20       	and	r15, r15
    12e2:	29 f4       	brne	.+10     	; 0x12ee <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    12e4:	ce 01       	movw	r24, r28
    12e6:	01 96       	adiw	r24, 0x01	; 1
    12e8:	0e 94 52 12 	call	0x24a4	; 0x24a4 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    12ec:	fb 2c       	mov	r15, r11
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    12ee:	0f 90       	pop	r0
    12f0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    12f2:	0e 94 3e 0f 	call	0x1e7c	; 0x1e7c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    12f6:	0f b6       	in	r0, 0x3f	; 63
    12f8:	f8 94       	cli
    12fa:	0f 92       	push	r0
    12fc:	f8 01       	movw	r30, r16
    12fe:	85 8d       	ldd	r24, Z+29	; 0x1d
    1300:	8f 3f       	cpi	r24, 0xFF	; 255
    1302:	09 f4       	brne	.+2      	; 0x1306 <xQueueGenericSend+0xaa>
    1304:	15 8e       	std	Z+29, r1	; 0x1d
    1306:	f8 01       	movw	r30, r16
    1308:	86 8d       	ldd	r24, Z+30	; 0x1e
    130a:	8f 3f       	cpi	r24, 0xFF	; 255
    130c:	09 f4       	brne	.+2      	; 0x1310 <xQueueGenericSend+0xb4>
    130e:	16 8e       	std	Z+30, r1	; 0x1e
    1310:	0f 90       	pop	r0
    1312:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1314:	ce 01       	movw	r24, r28
    1316:	01 96       	adiw	r24, 0x01	; 1
    1318:	be 01       	movw	r22, r28
    131a:	6c 5f       	subi	r22, 0xFC	; 252
    131c:	7f 4f       	sbci	r23, 0xFF	; 255
    131e:	0e 94 5d 12 	call	0x24ba	; 0x24ba <xTaskCheckForTimeOut>
    1322:	88 23       	and	r24, r24
    1324:	09 f5       	brne	.+66     	; 0x1368 <xQueueGenericSend+0x10c>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1326:	0f b6       	in	r0, 0x3f	; 63
    1328:	f8 94       	cli
    132a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    132c:	f8 01       	movw	r30, r16
    132e:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1330:	0f 90       	pop	r0
    1332:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1334:	f8 01       	movw	r30, r16
    1336:	83 8d       	ldd	r24, Z+27	; 0x1b
    1338:	98 17       	cp	r25, r24
    133a:	81 f4       	brne	.+32     	; 0x135c <xQueueGenericSend+0x100>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    133c:	6c 81       	ldd	r22, Y+4	; 0x04
    133e:	7d 81       	ldd	r23, Y+5	; 0x05
    1340:	c6 01       	movw	r24, r12
    1342:	0e 94 a2 11 	call	0x2344	; 0x2344 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1346:	c8 01       	movw	r24, r16
    1348:	0e 94 0f 08 	call	0x101e	; 0x101e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    134c:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <xTaskResumeAll>
    1350:	88 23       	and	r24, r24
    1352:	09 f0       	breq	.+2      	; 0x1356 <xQueueGenericSend+0xfa>
    1354:	a1 cf       	rjmp	.-190    	; 0x1298 <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
    1356:	0e 94 0d 07 	call	0xe1a	; 0xe1a <vPortYield>
    135a:	9e cf       	rjmp	.-196    	; 0x1298 <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    135c:	c8 01       	movw	r24, r16
    135e:	0e 94 0f 08 	call	0x101e	; 0x101e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1362:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <xTaskResumeAll>
    1366:	98 cf       	rjmp	.-208    	; 0x1298 <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1368:	c8 01       	movw	r24, r16
    136a:	0e 94 0f 08 	call	0x101e	; 0x101e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    136e:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1372:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1374:	0f 90       	pop	r0
    1376:	0f 90       	pop	r0
    1378:	0f 90       	pop	r0
    137a:	0f 90       	pop	r0
    137c:	0f 90       	pop	r0
    137e:	df 91       	pop	r29
    1380:	cf 91       	pop	r28
    1382:	1f 91       	pop	r17
    1384:	0f 91       	pop	r16
    1386:	ff 90       	pop	r15
    1388:	ef 90       	pop	r14
    138a:	df 90       	pop	r13
    138c:	cf 90       	pop	r12
    138e:	bf 90       	pop	r11
    1390:	9f 90       	pop	r9
    1392:	8f 90       	pop	r8
    1394:	08 95       	ret

00001396 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1396:	cf 93       	push	r28
    1398:	df 93       	push	r29
    139a:	48 2f       	mov	r20, r24
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    139c:	81 e0       	ldi	r24, 0x01	; 1
    139e:	60 e0       	ldi	r22, 0x00	; 0
    13a0:	0e 94 05 09 	call	0x120a	; 0x120a <xQueueGenericCreate>
    13a4:	ec 01       	movw	r28, r24

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
		if( pxNewQueue != NULL )
    13a6:	00 97       	sbiw	r24, 0x00	; 0
    13a8:	61 f0       	breq	.+24     	; 0x13c2 <xQueueCreateMutex+0x2c>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    13aa:	1b 82       	std	Y+3, r1	; 0x03
    13ac:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    13ae:	19 82       	std	Y+1, r1	; 0x01
    13b0:	18 82       	st	Y, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
    13b2:	1e 82       	std	Y+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    13b4:	60 e0       	ldi	r22, 0x00	; 0
    13b6:	70 e0       	ldi	r23, 0x00	; 0
    13b8:	40 e0       	ldi	r20, 0x00	; 0
    13ba:	50 e0       	ldi	r21, 0x00	; 0
    13bc:	20 e0       	ldi	r18, 0x00	; 0
    13be:	0e 94 2e 09 	call	0x125c	; 0x125c <xQueueGenericSend>

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
		prvInitialiseMutex( pxNewQueue );

		return pxNewQueue;
	}
    13c2:	8c 2f       	mov	r24, r28
    13c4:	9d 2f       	mov	r25, r29
    13c6:	df 91       	pop	r29
    13c8:	cf 91       	pop	r28
    13ca:	08 95       	ret

000013cc <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    13cc:	ef 92       	push	r14
    13ce:	ff 92       	push	r15
    13d0:	0f 93       	push	r16
    13d2:	1f 93       	push	r17
    13d4:	cf 93       	push	r28
    13d6:	8c 01       	movw	r16, r24
    13d8:	7a 01       	movw	r14, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    13da:	fc 01       	movw	r30, r24
    13dc:	92 8d       	ldd	r25, Z+26	; 0x1a
    13de:	83 8d       	ldd	r24, Z+27	; 0x1b
    13e0:	98 17       	cp	r25, r24
    13e2:	10 f0       	brcs	.+4      	; 0x13e8 <xQueueGenericSendFromISR+0x1c>
    13e4:	22 30       	cpi	r18, 0x02	; 2
    13e6:	f1 f4       	brne	.+60     	; 0x1424 <xQueueGenericSendFromISR+0x58>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    13e8:	f8 01       	movw	r30, r16
    13ea:	c6 8d       	ldd	r28, Z+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    13ec:	c8 01       	movw	r24, r16
    13ee:	42 2f       	mov	r20, r18
    13f0:	0e 94 64 08 	call	0x10c8	; 0x10c8 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    13f4:	cf 3f       	cpi	r28, 0xFF	; 255
    13f6:	89 f4       	brne	.+34     	; 0x141a <xQueueGenericSendFromISR+0x4e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13f8:	f8 01       	movw	r30, r16
    13fa:	81 89       	ldd	r24, Z+17	; 0x11
    13fc:	88 23       	and	r24, r24
    13fe:	a1 f0       	breq	.+40     	; 0x1428 <xQueueGenericSendFromISR+0x5c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1400:	c8 01       	movw	r24, r16
    1402:	41 96       	adiw	r24, 0x11	; 17
    1404:	0e 94 cd 11 	call	0x239a	; 0x239a <xTaskRemoveFromEventList>
    1408:	88 23       	and	r24, r24
    140a:	81 f0       	breq	.+32     	; 0x142c <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    140c:	e1 14       	cp	r14, r1
    140e:	f1 04       	cpc	r15, r1
    1410:	79 f0       	breq	.+30     	; 0x1430 <xQueueGenericSendFromISR+0x64>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1412:	81 e0       	ldi	r24, 0x01	; 1
    1414:	f7 01       	movw	r30, r14
    1416:	80 83       	st	Z, r24
    1418:	0c c0       	rjmp	.+24     	; 0x1432 <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    141a:	cf 5f       	subi	r28, 0xFF	; 255
    141c:	f8 01       	movw	r30, r16
    141e:	c6 8f       	std	Z+30, r28	; 0x1e
			}

			xReturn = pdPASS;
    1420:	81 e0       	ldi	r24, 0x01	; 1
    1422:	07 c0       	rjmp	.+14     	; 0x1432 <xQueueGenericSendFromISR+0x66>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1424:	80 e0       	ldi	r24, 0x00	; 0
    1426:	05 c0       	rjmp	.+10     	; 0x1432 <xQueueGenericSendFromISR+0x66>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    1428:	81 e0       	ldi	r24, 0x01	; 1
    142a:	03 c0       	rjmp	.+6      	; 0x1432 <xQueueGenericSendFromISR+0x66>
    142c:	81 e0       	ldi	r24, 0x01	; 1
    142e:	01 c0       	rjmp	.+2      	; 0x1432 <xQueueGenericSendFromISR+0x66>
    1430:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1432:	cf 91       	pop	r28
    1434:	1f 91       	pop	r17
    1436:	0f 91       	pop	r16
    1438:	ff 90       	pop	r15
    143a:	ef 90       	pop	r14
    143c:	08 95       	ret

0000143e <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    143e:	cf 93       	push	r28
    1440:	df 93       	push	r29
    1442:	fc 01       	movw	r30, r24
    1444:	eb 01       	movw	r28, r22
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1446:	82 8d       	ldd	r24, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1448:	93 8d       	ldd	r25, Z+27	; 0x1b
    144a:	89 17       	cp	r24, r25
    144c:	b8 f4       	brcc	.+46     	; 0x147c <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    144e:	96 8d       	ldd	r25, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    1450:	8f 5f       	subi	r24, 0xFF	; 255
    1452:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1454:	9f 3f       	cpi	r25, 0xFF	; 255
    1456:	71 f4       	brne	.+28     	; 0x1474 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1458:	81 89       	ldd	r24, Z+17	; 0x11
    145a:	88 23       	and	r24, r24
    145c:	89 f0       	breq	.+34     	; 0x1480 <xQueueGiveFromISR+0x42>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    145e:	cf 01       	movw	r24, r30
    1460:	41 96       	adiw	r24, 0x11	; 17
    1462:	0e 94 cd 11 	call	0x239a	; 0x239a <xTaskRemoveFromEventList>
    1466:	88 23       	and	r24, r24
    1468:	69 f0       	breq	.+26     	; 0x1484 <xQueueGiveFromISR+0x46>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    146a:	20 97       	sbiw	r28, 0x00	; 0
    146c:	69 f0       	breq	.+26     	; 0x1488 <xQueueGiveFromISR+0x4a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    146e:	81 e0       	ldi	r24, 0x01	; 1
    1470:	88 83       	st	Y, r24
    1472:	0b c0       	rjmp	.+22     	; 0x148a <xQueueGiveFromISR+0x4c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1474:	9f 5f       	subi	r25, 0xFF	; 255
    1476:	96 8f       	std	Z+30, r25	; 0x1e
			}

			xReturn = pdPASS;
    1478:	81 e0       	ldi	r24, 0x01	; 1
    147a:	07 c0       	rjmp	.+14     	; 0x148a <xQueueGiveFromISR+0x4c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    147c:	80 e0       	ldi	r24, 0x00	; 0
    147e:	05 c0       	rjmp	.+10     	; 0x148a <xQueueGiveFromISR+0x4c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    1480:	81 e0       	ldi	r24, 0x01	; 1
    1482:	03 c0       	rjmp	.+6      	; 0x148a <xQueueGiveFromISR+0x4c>
    1484:	81 e0       	ldi	r24, 0x01	; 1
    1486:	01 c0       	rjmp	.+2      	; 0x148a <xQueueGiveFromISR+0x4c>
    1488:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    148a:	df 91       	pop	r29
    148c:	cf 91       	pop	r28
    148e:	08 95       	ret

00001490 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1490:	8f 92       	push	r8
    1492:	9f 92       	push	r9
    1494:	af 92       	push	r10
    1496:	bf 92       	push	r11
    1498:	cf 92       	push	r12
    149a:	df 92       	push	r13
    149c:	ef 92       	push	r14
    149e:	ff 92       	push	r15
    14a0:	0f 93       	push	r16
    14a2:	1f 93       	push	r17
    14a4:	cf 93       	push	r28
    14a6:	df 93       	push	r29
    14a8:	00 d0       	rcall	.+0      	; 0x14aa <xQueueGenericReceive+0x1a>
    14aa:	00 d0       	rcall	.+0      	; 0x14ac <xQueueGenericReceive+0x1c>
    14ac:	0f 92       	push	r0
    14ae:	cd b7       	in	r28, 0x3d	; 61
    14b0:	de b7       	in	r29, 0x3e	; 62
    14b2:	7c 01       	movw	r14, r24
    14b4:	4b 01       	movw	r8, r22
    14b6:	5d 83       	std	Y+5, r21	; 0x05
    14b8:	4c 83       	std	Y+4, r20	; 0x04
    14ba:	c2 2e       	mov	r12, r18
BaseType_t xEntryTimeSet = pdFALSE;
    14bc:	00 e0       	ldi	r16, 0x00	; 0
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    14be:	dd 24       	eor	r13, r13
    14c0:	d3 94       	inc	r13
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    14c2:	0f 2e       	mov	r0, r31
    14c4:	f1 e1       	ldi	r31, 0x11	; 17
    14c6:	af 2e       	mov	r10, r31
    14c8:	bb 24       	eor	r11, r11
    14ca:	f0 2d       	mov	r31, r0
    14cc:	a8 0e       	add	r10, r24
    14ce:	b9 1e       	adc	r11, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    14d0:	0f b6       	in	r0, 0x3f	; 63
    14d2:	f8 94       	cli
    14d4:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    14d6:	f7 01       	movw	r30, r14
    14d8:	12 8d       	ldd	r17, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    14da:	11 23       	and	r17, r17
    14dc:	59 f1       	breq	.+86     	; 0x1534 <xQueueGenericReceive+0xa4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    14de:	a6 80       	ldd	r10, Z+6	; 0x06
    14e0:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    14e2:	c7 01       	movw	r24, r14
    14e4:	b4 01       	movw	r22, r8
    14e6:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    14ea:	cc 20       	and	r12, r12
    14ec:	a9 f4       	brne	.+42     	; 0x1518 <xQueueGenericReceive+0x88>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    14ee:	11 50       	subi	r17, 0x01	; 1
    14f0:	f7 01       	movw	r30, r14
    14f2:	12 8f       	std	Z+26, r17	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    14f4:	80 81       	ld	r24, Z
    14f6:	91 81       	ldd	r25, Z+1	; 0x01
    14f8:	00 97       	sbiw	r24, 0x00	; 0
    14fa:	29 f4       	brne	.+10     	; 0x1506 <xQueueGenericReceive+0x76>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    14fc:	0e 94 52 13 	call	0x26a4	; 0x26a4 <pvTaskIncrementMutexHeldCount>
    1500:	f7 01       	movw	r30, r14
    1502:	93 83       	std	Z+3, r25	; 0x03
    1504:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1506:	f7 01       	movw	r30, r14
    1508:	80 85       	ldd	r24, Z+8	; 0x08
    150a:	88 23       	and	r24, r24
    150c:	79 f0       	breq	.+30     	; 0x152c <xQueueGenericReceive+0x9c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    150e:	c7 01       	movw	r24, r14
    1510:	08 96       	adiw	r24, 0x08	; 8
    1512:	0e 94 cd 11 	call	0x239a	; 0x239a <xTaskRemoveFromEventList>
    1516:	0a c0       	rjmp	.+20     	; 0x152c <xQueueGenericReceive+0x9c>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1518:	f7 01       	movw	r30, r14
    151a:	b7 82       	std	Z+7, r11	; 0x07
    151c:	a6 82       	std	Z+6, r10	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    151e:	81 89       	ldd	r24, Z+17	; 0x11
    1520:	88 23       	and	r24, r24
    1522:	21 f0       	breq	.+8      	; 0x152c <xQueueGenericReceive+0x9c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1524:	c7 01       	movw	r24, r14
    1526:	41 96       	adiw	r24, 0x11	; 17
    1528:	0e 94 cd 11 	call	0x239a	; 0x239a <xTaskRemoveFromEventList>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    152c:	0f 90       	pop	r0
    152e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1530:	81 e0       	ldi	r24, 0x01	; 1
    1532:	61 c0       	rjmp	.+194    	; 0x15f6 <xQueueGenericReceive+0x166>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1534:	8c 81       	ldd	r24, Y+4	; 0x04
    1536:	9d 81       	ldd	r25, Y+5	; 0x05
    1538:	00 97       	sbiw	r24, 0x00	; 0
    153a:	21 f4       	brne	.+8      	; 0x1544 <xQueueGenericReceive+0xb4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    153c:	0f 90       	pop	r0
    153e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1540:	80 e0       	ldi	r24, 0x00	; 0
    1542:	59 c0       	rjmp	.+178    	; 0x15f6 <xQueueGenericReceive+0x166>
				}
				else if( xEntryTimeSet == pdFALSE )
    1544:	00 23       	and	r16, r16
    1546:	29 f4       	brne	.+10     	; 0x1552 <xQueueGenericReceive+0xc2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1548:	ce 01       	movw	r24, r28
    154a:	01 96       	adiw	r24, 0x01	; 1
    154c:	0e 94 52 12 	call	0x24a4	; 0x24a4 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1550:	0d 2d       	mov	r16, r13
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1552:	0f 90       	pop	r0
    1554:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1556:	0e 94 3e 0f 	call	0x1e7c	; 0x1e7c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    155a:	0f b6       	in	r0, 0x3f	; 63
    155c:	f8 94       	cli
    155e:	0f 92       	push	r0
    1560:	f7 01       	movw	r30, r14
    1562:	85 8d       	ldd	r24, Z+29	; 0x1d
    1564:	8f 3f       	cpi	r24, 0xFF	; 255
    1566:	09 f4       	brne	.+2      	; 0x156a <xQueueGenericReceive+0xda>
    1568:	15 8e       	std	Z+29, r1	; 0x1d
    156a:	f7 01       	movw	r30, r14
    156c:	86 8d       	ldd	r24, Z+30	; 0x1e
    156e:	8f 3f       	cpi	r24, 0xFF	; 255
    1570:	09 f4       	brne	.+2      	; 0x1574 <xQueueGenericReceive+0xe4>
    1572:	16 8e       	std	Z+30, r1	; 0x1e
    1574:	0f 90       	pop	r0
    1576:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1578:	ce 01       	movw	r24, r28
    157a:	01 96       	adiw	r24, 0x01	; 1
    157c:	be 01       	movw	r22, r28
    157e:	6c 5f       	subi	r22, 0xFC	; 252
    1580:	7f 4f       	sbci	r23, 0xFF	; 255
    1582:	0e 94 5d 12 	call	0x24ba	; 0x24ba <xTaskCheckForTimeOut>
    1586:	88 23       	and	r24, r24
    1588:	51 f5       	brne	.+84     	; 0x15de <xQueueGenericReceive+0x14e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    158a:	c7 01       	movw	r24, r14
    158c:	0e 94 e7 07 	call	0xfce	; 0xfce <prvIsQueueEmpty>
    1590:	88 23       	and	r24, r24
    1592:	f9 f0       	breq	.+62     	; 0x15d2 <xQueueGenericReceive+0x142>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1594:	f7 01       	movw	r30, r14
    1596:	80 81       	ld	r24, Z
    1598:	91 81       	ldd	r25, Z+1	; 0x01
    159a:	00 97       	sbiw	r24, 0x00	; 0
    159c:	51 f4       	brne	.+20     	; 0x15b2 <xQueueGenericReceive+0x122>
					{
						taskENTER_CRITICAL();
    159e:	0f b6       	in	r0, 0x3f	; 63
    15a0:	f8 94       	cli
    15a2:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    15a4:	f7 01       	movw	r30, r14
    15a6:	82 81       	ldd	r24, Z+2	; 0x02
    15a8:	93 81       	ldd	r25, Z+3	; 0x03
    15aa:	0e 94 9b 12 	call	0x2536	; 0x2536 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    15ae:	0f 90       	pop	r0
    15b0:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    15b2:	6c 81       	ldd	r22, Y+4	; 0x04
    15b4:	7d 81       	ldd	r23, Y+5	; 0x05
    15b6:	c5 01       	movw	r24, r10
    15b8:	0e 94 a2 11 	call	0x2344	; 0x2344 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    15bc:	c7 01       	movw	r24, r14
    15be:	0e 94 0f 08 	call	0x101e	; 0x101e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    15c2:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <xTaskResumeAll>
    15c6:	88 23       	and	r24, r24
    15c8:	09 f0       	breq	.+2      	; 0x15cc <xQueueGenericReceive+0x13c>
    15ca:	82 cf       	rjmp	.-252    	; 0x14d0 <xQueueGenericReceive+0x40>
				{
					portYIELD_WITHIN_API();
    15cc:	0e 94 0d 07 	call	0xe1a	; 0xe1a <vPortYield>
    15d0:	7f cf       	rjmp	.-258    	; 0x14d0 <xQueueGenericReceive+0x40>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    15d2:	c7 01       	movw	r24, r14
    15d4:	0e 94 0f 08 	call	0x101e	; 0x101e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    15d8:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <xTaskResumeAll>
    15dc:	79 cf       	rjmp	.-270    	; 0x14d0 <xQueueGenericReceive+0x40>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    15de:	c7 01       	movw	r24, r14
    15e0:	0e 94 0f 08 	call	0x101e	; 0x101e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    15e4:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    15e8:	c7 01       	movw	r24, r14
    15ea:	0e 94 e7 07 	call	0xfce	; 0xfce <prvIsQueueEmpty>
    15ee:	88 23       	and	r24, r24
    15f0:	09 f4       	brne	.+2      	; 0x15f4 <xQueueGenericReceive+0x164>
    15f2:	6e cf       	rjmp	.-292    	; 0x14d0 <xQueueGenericReceive+0x40>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    15f4:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    15f6:	0f 90       	pop	r0
    15f8:	0f 90       	pop	r0
    15fa:	0f 90       	pop	r0
    15fc:	0f 90       	pop	r0
    15fe:	0f 90       	pop	r0
    1600:	df 91       	pop	r29
    1602:	cf 91       	pop	r28
    1604:	1f 91       	pop	r17
    1606:	0f 91       	pop	r16
    1608:	ff 90       	pop	r15
    160a:	ef 90       	pop	r14
    160c:	df 90       	pop	r13
    160e:	cf 90       	pop	r12
    1610:	bf 90       	pop	r11
    1612:	af 90       	pop	r10
    1614:	9f 90       	pop	r9
    1616:	8f 90       	pop	r8
    1618:	08 95       	ret

0000161a <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    161a:	ef 92       	push	r14
    161c:	ff 92       	push	r15
    161e:	0f 93       	push	r16
    1620:	1f 93       	push	r17
    1622:	cf 93       	push	r28
    1624:	df 93       	push	r29
    1626:	8c 01       	movw	r16, r24
    1628:	7a 01       	movw	r14, r20
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    162a:	fc 01       	movw	r30, r24
    162c:	c2 8d       	ldd	r28, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    162e:	cc 23       	and	r28, r28
    1630:	e9 f0       	breq	.+58     	; 0x166c <xQueueReceiveFromISR+0x52>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1632:	d5 8d       	ldd	r29, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1634:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1638:	c1 50       	subi	r28, 0x01	; 1
    163a:	f8 01       	movw	r30, r16
    163c:	c2 8f       	std	Z+26, r28	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    163e:	df 3f       	cpi	r29, 0xFF	; 255
    1640:	81 f4       	brne	.+32     	; 0x1662 <xQueueReceiveFromISR+0x48>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1642:	80 85       	ldd	r24, Z+8	; 0x08
    1644:	88 23       	and	r24, r24
    1646:	a1 f0       	breq	.+40     	; 0x1670 <xQueueReceiveFromISR+0x56>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1648:	c8 01       	movw	r24, r16
    164a:	08 96       	adiw	r24, 0x08	; 8
    164c:	0e 94 cd 11 	call	0x239a	; 0x239a <xTaskRemoveFromEventList>
    1650:	88 23       	and	r24, r24
    1652:	81 f0       	breq	.+32     	; 0x1674 <xQueueReceiveFromISR+0x5a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1654:	e1 14       	cp	r14, r1
    1656:	f1 04       	cpc	r15, r1
    1658:	79 f0       	breq	.+30     	; 0x1678 <xQueueReceiveFromISR+0x5e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    165a:	81 e0       	ldi	r24, 0x01	; 1
    165c:	f7 01       	movw	r30, r14
    165e:	80 83       	st	Z, r24
    1660:	0c c0       	rjmp	.+24     	; 0x167a <xQueueReceiveFromISR+0x60>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1662:	df 5f       	subi	r29, 0xFF	; 255
    1664:	f8 01       	movw	r30, r16
    1666:	d5 8f       	std	Z+29, r29	; 0x1d
			}

			xReturn = pdPASS;
    1668:	81 e0       	ldi	r24, 0x01	; 1
    166a:	07 c0       	rjmp	.+14     	; 0x167a <xQueueReceiveFromISR+0x60>
		}
		else
		{
			xReturn = pdFAIL;
    166c:	80 e0       	ldi	r24, 0x00	; 0
    166e:	05 c0       	rjmp	.+10     	; 0x167a <xQueueReceiveFromISR+0x60>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
			}

			xReturn = pdPASS;
    1670:	81 e0       	ldi	r24, 0x01	; 1
    1672:	03 c0       	rjmp	.+6      	; 0x167a <xQueueReceiveFromISR+0x60>
    1674:	81 e0       	ldi	r24, 0x01	; 1
    1676:	01 c0       	rjmp	.+2      	; 0x167a <xQueueReceiveFromISR+0x60>
    1678:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    167a:	df 91       	pop	r29
    167c:	cf 91       	pop	r28
    167e:	1f 91       	pop	r17
    1680:	0f 91       	pop	r16
    1682:	ff 90       	pop	r15
    1684:	ef 90       	pop	r14
    1686:	08 95       	ret

00001688 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1688:	0f 93       	push	r16
    168a:	1f 93       	push	r17
    168c:	cf 93       	push	r28
    168e:	df 93       	push	r29
    1690:	ec 01       	movw	r28, r24
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1692:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1694:	88 23       	and	r24, r24
    1696:	49 f0       	breq	.+18     	; 0x16aa <xQueuePeekFromISR+0x22>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1698:	0e 81       	ldd	r16, Y+6	; 0x06
    169a:	1f 81       	ldd	r17, Y+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    169c:	ce 01       	movw	r24, r28
    169e:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    16a2:	1f 83       	std	Y+7, r17	; 0x07
    16a4:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    16a6:	81 e0       	ldi	r24, 0x01	; 1
    16a8:	01 c0       	rjmp	.+2      	; 0x16ac <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    16aa:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    16ac:	df 91       	pop	r29
    16ae:	cf 91       	pop	r28
    16b0:	1f 91       	pop	r17
    16b2:	0f 91       	pop	r16
    16b4:	08 95       	ret

000016b6 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    16b6:	0f b6       	in	r0, 0x3f	; 63
    16b8:	f8 94       	cli
    16ba:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    16bc:	fc 01       	movw	r30, r24
    16be:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    16c0:	0f 90       	pop	r0
    16c2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    16c4:	08 95       	ret

000016c6 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    16c6:	fc 01       	movw	r30, r24
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    16c8:	0f b6       	in	r0, 0x3f	; 63
    16ca:	f8 94       	cli
    16cc:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    16ce:	92 8d       	ldd	r25, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    16d0:	0f 90       	pop	r0
    16d2:	0f be       	out	0x3f, r0	; 63
	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    16d4:	83 8d       	ldd	r24, Z+27	; 0x1b
	}
	taskEXIT_CRITICAL();

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    16d6:	89 1b       	sub	r24, r25
    16d8:	08 95       	ret

000016da <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    16da:	fc 01       	movw	r30, r24
    16dc:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    16de:	08 95       	ret

000016e0 <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    16e0:	fc 01       	movw	r30, r24
    16e2:	92 8d       	ldd	r25, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    16e4:	81 e0       	ldi	r24, 0x01	; 1
    16e6:	91 11       	cpse	r25, r1
    16e8:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    16ea:	08 95       	ret

000016ec <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    16ec:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    16ee:	22 8d       	ldd	r18, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    16f0:	81 e0       	ldi	r24, 0x01	; 1
    16f2:	93 8d       	ldd	r25, Z+27	; 0x1b
    16f4:	29 13       	cpse	r18, r25
    16f6:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    16f8:	08 95       	ret

000016fa <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    16fa:	dc 01       	movw	r26, r24

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
    16fc:	80 91 1c 04 	lds	r24, 0x041C
    1700:	90 91 1d 04 	lds	r25, 0x041D
    1704:	00 97       	sbiw	r24, 0x00	; 0
    1706:	51 f0       	breq	.+20     	; 0x171c <vQueueAddToRegistry+0x22>
    1708:	e0 e2       	ldi	r30, 0x20	; 32
    170a:	f4 e0       	ldi	r31, 0x04	; 4
    170c:	21 e0       	ldi	r18, 0x01	; 1
    170e:	30 e0       	ldi	r19, 0x00	; 0
    1710:	a9 01       	movw	r20, r18
    1712:	80 81       	ld	r24, Z
    1714:	91 81       	ldd	r25, Z+1	; 0x01
    1716:	00 97       	sbiw	r24, 0x00	; 0
    1718:	79 f4       	brne	.+30     	; 0x1738 <vQueueAddToRegistry+0x3e>
    171a:	02 c0       	rjmp	.+4      	; 0x1720 <vQueueAddToRegistry+0x26>
    171c:	40 e0       	ldi	r20, 0x00	; 0
    171e:	50 e0       	ldi	r21, 0x00	; 0
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
    1720:	fa 01       	movw	r30, r20
    1722:	ee 0f       	add	r30, r30
    1724:	ff 1f       	adc	r31, r31
    1726:	ee 0f       	add	r30, r30
    1728:	ff 1f       	adc	r31, r31
    172a:	e4 5e       	subi	r30, 0xE4	; 228
    172c:	fb 4f       	sbci	r31, 0xFB	; 251
    172e:	71 83       	std	Z+1, r23	; 0x01
    1730:	60 83       	st	Z, r22
				xQueueRegistry[ ux ].xHandle = xQueue;
    1732:	b3 83       	std	Z+3, r27	; 0x03
    1734:	a2 83       	std	Z+2, r26	; 0x02

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
    1736:	08 95       	ret
    1738:	2f 5f       	subi	r18, 0xFF	; 255
    173a:	3f 4f       	sbci	r19, 0xFF	; 255
    173c:	34 96       	adiw	r30, 0x04	; 4
	{
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    173e:	28 30       	cpi	r18, 0x08	; 8
    1740:	31 05       	cpc	r19, r1
    1742:	31 f7       	brne	.-52     	; 0x1710 <vQueueAddToRegistry+0x16>
    1744:	08 95       	ret

00001746 <pcQueueGetName>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    1746:	ac 01       	movw	r20, r24

		/* Note there is nothing here to protect against another task adding or
		removing entries from the registry while it is being searched. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
    1748:	80 91 1e 04 	lds	r24, 0x041E
    174c:	90 91 1f 04 	lds	r25, 0x041F
    1750:	84 17       	cp	r24, r20
    1752:	95 07       	cpc	r25, r21
    1754:	59 f0       	breq	.+22     	; 0x176c <pcQueueGetName+0x26>
    1756:	e2 e2       	ldi	r30, 0x22	; 34
    1758:	f4 e0       	ldi	r31, 0x04	; 4
    175a:	21 e0       	ldi	r18, 0x01	; 1
    175c:	30 e0       	ldi	r19, 0x00	; 0
    175e:	b9 01       	movw	r22, r18
    1760:	80 81       	ld	r24, Z
    1762:	91 81       	ldd	r25, Z+1	; 0x01
    1764:	84 17       	cp	r24, r20
    1766:	95 07       	cpc	r25, r21
    1768:	69 f4       	brne	.+26     	; 0x1784 <pcQueueGetName+0x3e>
    176a:	02 c0       	rjmp	.+4      	; 0x1770 <pcQueueGetName+0x2a>
    176c:	60 e0       	ldi	r22, 0x00	; 0
    176e:	70 e0       	ldi	r23, 0x00	; 0
			{
				pcReturn = xQueueRegistry[ ux ].pcQueueName;
    1770:	fb 01       	movw	r30, r22
    1772:	ee 0f       	add	r30, r30
    1774:	ff 1f       	adc	r31, r31
    1776:	ee 0f       	add	r30, r30
    1778:	ff 1f       	adc	r31, r31
    177a:	e4 5e       	subi	r30, 0xE4	; 228
    177c:	fb 4f       	sbci	r31, 0xFB	; 251
    177e:	80 81       	ld	r24, Z
    1780:	91 81       	ldd	r25, Z+1	; 0x01
				break;
    1782:	08 95       	ret
    1784:	2f 5f       	subi	r18, 0xFF	; 255
    1786:	3f 4f       	sbci	r19, 0xFF	; 255
    1788:	34 96       	adiw	r30, 0x04	; 4
	UBaseType_t ux;
	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */

		/* Note there is nothing here to protect against another task adding or
		removing entries from the registry while it is being searched. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    178a:	28 30       	cpi	r18, 0x08	; 8
    178c:	31 05       	cpc	r19, r1
    178e:	39 f7       	brne	.-50     	; 0x175e <pcQueueGetName+0x18>
#if ( configQUEUE_REGISTRY_SIZE > 0 )

	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
	UBaseType_t ux;
	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    1790:	80 e0       	ldi	r24, 0x00	; 0
    1792:	90 e0       	ldi	r25, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}

		return pcReturn;
	}
    1794:	08 95       	ret

00001796 <vQueueUnregisterQueue>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueUnregisterQueue( QueueHandle_t xQueue )
	{
    1796:	ac 01       	movw	r20, r24

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
    1798:	80 91 1e 04 	lds	r24, 0x041E
    179c:	90 91 1f 04 	lds	r25, 0x041F
    17a0:	84 17       	cp	r24, r20
    17a2:	95 07       	cpc	r25, r21
    17a4:	59 f0       	breq	.+22     	; 0x17bc <vQueueUnregisterQueue+0x26>
    17a6:	e2 e2       	ldi	r30, 0x22	; 34
    17a8:	f4 e0       	ldi	r31, 0x04	; 4
    17aa:	21 e0       	ldi	r18, 0x01	; 1
    17ac:	30 e0       	ldi	r19, 0x00	; 0
    17ae:	b9 01       	movw	r22, r18
    17b0:	80 81       	ld	r24, Z
    17b2:	91 81       	ldd	r25, Z+1	; 0x01
    17b4:	84 17       	cp	r24, r20
    17b6:	95 07       	cpc	r25, r21
    17b8:	79 f4       	brne	.+30     	; 0x17d8 <vQueueUnregisterQueue+0x42>
    17ba:	02 c0       	rjmp	.+4      	; 0x17c0 <vQueueUnregisterQueue+0x2a>
    17bc:	60 e0       	ldi	r22, 0x00	; 0
    17be:	70 e0       	ldi	r23, 0x00	; 0
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
    17c0:	fb 01       	movw	r30, r22
    17c2:	ee 0f       	add	r30, r30
    17c4:	ff 1f       	adc	r31, r31
    17c6:	ee 0f       	add	r30, r30
    17c8:	ff 1f       	adc	r31, r31
    17ca:	e4 5e       	subi	r30, 0xE4	; 228
    17cc:	fb 4f       	sbci	r31, 0xFB	; 251
    17ce:	11 82       	std	Z+1, r1	; 0x01
    17d0:	10 82       	st	Z, r1

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
    17d2:	13 82       	std	Z+3, r1	; 0x03
    17d4:	12 82       	std	Z+2, r1	; 0x02
				break;
    17d6:	08 95       	ret
    17d8:	2f 5f       	subi	r18, 0xFF	; 255
    17da:	3f 4f       	sbci	r19, 0xFF	; 255
    17dc:	34 96       	adiw	r30, 0x04	; 4
	{
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    17de:	28 30       	cpi	r18, 0x08	; 8
    17e0:	31 05       	cpc	r19, r1
    17e2:	29 f7       	brne	.-54     	; 0x17ae <vQueueUnregisterQueue+0x18>
    17e4:	08 95       	ret

000017e6 <vQueueDelete>:
	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    17e6:	cf 93       	push	r28
    17e8:	df 93       	push	r29
    17ea:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );
	traceQUEUE_DELETE( pxQueue );

	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
    17ec:	0e 94 cb 0b 	call	0x1796	; 0x1796 <vQueueUnregisterQueue>

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    17f0:	ce 01       	movw	r24, r28
    17f2:	0e 94 32 03 	call	0x664	; 0x664 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    17f6:	df 91       	pop	r29
    17f8:	cf 91       	pop	r28
    17fa:	08 95       	ret

000017fc <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    17fc:	fc 01       	movw	r30, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    17fe:	82 85       	ldd	r24, Z+10	; 0x0a
    1800:	93 85       	ldd	r25, Z+11	; 0x0b
    1802:	24 e0       	ldi	r18, 0x04	; 4
    1804:	8f 30       	cpi	r24, 0x0F	; 15
    1806:	92 07       	cpc	r25, r18
    1808:	61 f4       	brne	.+24     	; 0x1822 <prvTaskIsTaskSuspended+0x26>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    180a:	24 89       	ldd	r18, Z+20	; 0x14
    180c:	35 89       	ldd	r19, Z+21	; 0x15
    180e:	83 e0       	ldi	r24, 0x03	; 3
    1810:	2d 3f       	cpi	r18, 0xFD	; 253
    1812:	38 07       	cpc	r19, r24
    1814:	41 f0       	breq	.+16     	; 0x1826 <prvTaskIsTaskSuspended+0x2a>

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
	BaseType_t xReturn = pdFALSE;
    1816:	81 e0       	ldi	r24, 0x01	; 1
    1818:	21 15       	cp	r18, r1
    181a:	31 05       	cpc	r19, r1
    181c:	29 f0       	breq	.+10     	; 0x1828 <prvTaskIsTaskSuspended+0x2c>
    181e:	80 e0       	ldi	r24, 0x00	; 0
    1820:	08 95       	ret
    1822:	80 e0       	ldi	r24, 0x00	; 0
    1824:	08 95       	ret
    1826:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    1828:	08 95       	ret

0000182a <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    182a:	e0 91 bb 03 	lds	r30, 0x03BB
    182e:	f0 91 bc 03 	lds	r31, 0x03BC
    1832:	80 81       	ld	r24, Z
    1834:	88 23       	and	r24, r24
    1836:	39 f4       	brne	.+14     	; 0x1846 <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    1838:	8f ef       	ldi	r24, 0xFF	; 255
    183a:	9f ef       	ldi	r25, 0xFF	; 255
    183c:	90 93 af 03 	sts	0x03AF, r25
    1840:	80 93 ae 03 	sts	0x03AE, r24
    1844:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1846:	e0 91 bb 03 	lds	r30, 0x03BB
    184a:	f0 91 bc 03 	lds	r31, 0x03BC
    184e:	05 80       	ldd	r0, Z+5	; 0x05
    1850:	f6 81       	ldd	r31, Z+6	; 0x06
    1852:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    1854:	06 80       	ldd	r0, Z+6	; 0x06
    1856:	f7 81       	ldd	r31, Z+7	; 0x07
    1858:	e0 2d       	mov	r30, r0
    185a:	82 81       	ldd	r24, Z+2	; 0x02
    185c:	93 81       	ldd	r25, Z+3	; 0x03
    185e:	90 93 af 03 	sts	0x03AF, r25
    1862:	80 93 ae 03 	sts	0x03AE, r24
    1866:	08 95       	ret

00001868 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    1868:	ef 92       	push	r14
    186a:	ff 92       	push	r15
    186c:	1f 93       	push	r17
    186e:	cf 93       	push	r28
    1870:	df 93       	push	r29
    1872:	ec 01       	movw	r28, r24
    1874:	16 2f       	mov	r17, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    1876:	e0 90 b5 03 	lds	r14, 0x03B5
    187a:	f0 90 b6 03 	lds	r15, 0x03B6
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    187e:	80 91 ab 03 	lds	r24, 0x03AB
    1882:	90 91 ac 03 	lds	r25, 0x03AC
    1886:	02 96       	adiw	r24, 0x02	; 2
    1888:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    188c:	8f ef       	ldi	r24, 0xFF	; 255
    188e:	cf 3f       	cpi	r28, 0xFF	; 255
    1890:	d8 07       	cpc	r29, r24
    1892:	69 f4       	brne	.+26     	; 0x18ae <prvAddCurrentTaskToDelayedList+0x46>
    1894:	11 23       	and	r17, r17
    1896:	59 f0       	breq	.+22     	; 0x18ae <prvAddCurrentTaskToDelayedList+0x46>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1898:	60 91 ab 03 	lds	r22, 0x03AB
    189c:	70 91 ac 03 	lds	r23, 0x03AC
    18a0:	6e 5f       	subi	r22, 0xFE	; 254
    18a2:	7f 4f       	sbci	r23, 0xFF	; 255
    18a4:	8f e0       	ldi	r24, 0x0F	; 15
    18a6:	94 e0       	ldi	r25, 0x04	; 4
    18a8:	0e 94 69 05 	call	0xad2	; 0xad2 <vListInsertEnd>
    18ac:	2f c0       	rjmp	.+94     	; 0x190c <prvAddCurrentTaskToDelayedList+0xa4>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    18ae:	ce 0d       	add	r28, r14
    18b0:	df 1d       	adc	r29, r15

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    18b2:	e0 91 ab 03 	lds	r30, 0x03AB
    18b6:	f0 91 ac 03 	lds	r31, 0x03AC
    18ba:	d3 83       	std	Z+3, r29	; 0x03
    18bc:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
    18be:	ce 15       	cp	r28, r14
    18c0:	df 05       	cpc	r29, r15
    18c2:	68 f4       	brcc	.+26     	; 0x18de <prvAddCurrentTaskToDelayedList+0x76>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    18c4:	80 91 b9 03 	lds	r24, 0x03B9
    18c8:	90 91 ba 03 	lds	r25, 0x03BA
    18cc:	60 91 ab 03 	lds	r22, 0x03AB
    18d0:	70 91 ac 03 	lds	r23, 0x03AC
    18d4:	6e 5f       	subi	r22, 0xFE	; 254
    18d6:	7f 4f       	sbci	r23, 0xFF	; 255
    18d8:	0e 94 88 05 	call	0xb10	; 0xb10 <vListInsert>
    18dc:	17 c0       	rjmp	.+46     	; 0x190c <prvAddCurrentTaskToDelayedList+0xa4>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    18de:	80 91 bb 03 	lds	r24, 0x03BB
    18e2:	90 91 bc 03 	lds	r25, 0x03BC
    18e6:	60 91 ab 03 	lds	r22, 0x03AB
    18ea:	70 91 ac 03 	lds	r23, 0x03AC
    18ee:	6e 5f       	subi	r22, 0xFE	; 254
    18f0:	7f 4f       	sbci	r23, 0xFF	; 255
    18f2:	0e 94 88 05 	call	0xb10	; 0xb10 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    18f6:	80 91 ae 03 	lds	r24, 0x03AE
    18fa:	90 91 af 03 	lds	r25, 0x03AF
    18fe:	c8 17       	cp	r28, r24
    1900:	d9 07       	cpc	r29, r25
    1902:	20 f4       	brcc	.+8      	; 0x190c <prvAddCurrentTaskToDelayedList+0xa4>
				{
					xNextTaskUnblockTime = xTimeToWake;
    1904:	d0 93 af 03 	sts	0x03AF, r29
    1908:	c0 93 ae 03 	sts	0x03AE, r28

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    190c:	df 91       	pop	r29
    190e:	cf 91       	pop	r28
    1910:	1f 91       	pop	r17
    1912:	ff 90       	pop	r15
    1914:	ef 90       	pop	r14
    1916:	08 95       	ret

00001918 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    1918:	cf 93       	push	r28
    191a:	df 93       	push	r29
    191c:	ec 01       	movw	r28, r24

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    191e:	8f 89       	ldd	r24, Y+23	; 0x17
    1920:	98 8d       	ldd	r25, Y+24	; 0x18
    1922:	0e 94 32 03 	call	0x664	; 0x664 <vPortFree>
			vPortFree( pxTCB );
    1926:	ce 01       	movw	r24, r28
    1928:	0e 94 32 03 	call	0x664	; 0x664 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    192c:	df 91       	pop	r29
    192e:	cf 91       	pop	r28
    1930:	08 95       	ret

00001932 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    1932:	2f 92       	push	r2
    1934:	3f 92       	push	r3
    1936:	4f 92       	push	r4
    1938:	5f 92       	push	r5
    193a:	6f 92       	push	r6
    193c:	7f 92       	push	r7
    193e:	8f 92       	push	r8
    1940:	9f 92       	push	r9
    1942:	af 92       	push	r10
    1944:	bf 92       	push	r11
    1946:	df 92       	push	r13
    1948:	ef 92       	push	r14
    194a:	ff 92       	push	r15
    194c:	0f 93       	push	r16
    194e:	1f 93       	push	r17
    1950:	cf 93       	push	r28
    1952:	df 93       	push	r29
    1954:	3c 01       	movw	r6, r24
    1956:	5b 01       	movw	r10, r22
    1958:	ea 01       	movw	r28, r20
    195a:	29 01       	movw	r4, r18
    195c:	d0 2e       	mov	r13, r16
    195e:	47 01       	movw	r8, r14
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1960:	ca 01       	movw	r24, r20
    1962:	0e 94 92 02 	call	0x524	; 0x524 <pvPortMalloc>
    1966:	7c 01       	movw	r14, r24

			if( pxStack != NULL )
    1968:	00 97       	sbiw	r24, 0x00	; 0
    196a:	09 f4       	brne	.+2      	; 0x196e <xTaskCreate+0x3c>
    196c:	e6 c0       	rjmp	.+460    	; 0x1b3a <xTaskCreate+0x208>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    196e:	8a e2       	ldi	r24, 0x2A	; 42
    1970:	90 e0       	ldi	r25, 0x00	; 0
    1972:	0e 94 92 02 	call	0x524	; 0x524 <pvPortMalloc>
    1976:	8c 01       	movw	r16, r24

				if( pxNewTCB != NULL )
    1978:	00 97       	sbiw	r24, 0x00	; 0
    197a:	81 f0       	breq	.+32     	; 0x199c <xTaskCreate+0x6a>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    197c:	fc 01       	movw	r30, r24
    197e:	f0 8e       	std	Z+24, r15	; 0x18
    1980:	e7 8a       	std	Z+23, r14	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    1982:	21 97       	sbiw	r28, 0x01	; 1
    1984:	17 01       	movw	r2, r14
    1986:	2c 0e       	add	r2, r28
    1988:	3d 1e       	adc	r3, r29
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    198a:	f5 01       	movw	r30, r10
    198c:	80 81       	ld	r24, Z
    198e:	f8 01       	movw	r30, r16
    1990:	81 8f       	std	Z+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1992:	f5 01       	movw	r30, r10
    1994:	80 81       	ld	r24, Z
    1996:	88 23       	and	r24, r24
    1998:	31 f4       	brne	.+12     	; 0x19a6 <xTaskCreate+0x74>
    199a:	13 c0       	rjmp	.+38     	; 0x19c2 <xTaskCreate+0x90>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    199c:	c7 01       	movw	r24, r14
    199e:	0e 94 32 03 	call	0x664	; 0x664 <vPortFree>
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    19a2:	8f ef       	ldi	r24, 0xFF	; 255
    19a4:	cd c0       	rjmp	.+410    	; 0x1b40 <xTaskCreate+0x20e>
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    19a6:	e8 01       	movw	r28, r16
    19a8:	6a 96       	adiw	r28, 0x1a	; 26
    19aa:	d5 01       	movw	r26, r10
    19ac:	11 96       	adiw	r26, 0x01	; 1
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    19ae:	81 e0       	ldi	r24, 0x01	; 1
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    19b0:	fd 01       	movw	r30, r26
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    19b2:	9d 91       	ld	r25, X+
    19b4:	99 93       	st	Y+, r25

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    19b6:	90 81       	ld	r25, Z
    19b8:	99 23       	and	r25, r25
    19ba:	19 f0       	breq	.+6      	; 0x19c2 <xTaskCreate+0x90>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    19bc:	8f 5f       	subi	r24, 0xFF	; 255
    19be:	8a 30       	cpi	r24, 0x0A	; 10
    19c0:	b9 f7       	brne	.-18     	; 0x19b0 <xTaskCreate+0x7e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    19c2:	f8 01       	movw	r30, r16
    19c4:	12 a2       	lds	r17, 0x92
    19c6:	cd 2d       	mov	r28, r13
    19c8:	c5 30       	cpi	r28, 0x05	; 5
    19ca:	08 f0       	brcs	.+2      	; 0x19ce <xTaskCreate+0x9c>
    19cc:	c4 e0       	ldi	r28, 0x04	; 4
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    19ce:	f8 01       	movw	r30, r16
    19d0:	c6 8b       	std	Z+22, r28	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    19d2:	c3 a3       	lds	r28, 0x53
		pxNewTCB->uxMutexesHeld = 0;
    19d4:	14 a2       	lds	r17, 0x94
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    19d6:	ee 24       	eor	r14, r14
    19d8:	ff 24       	eor	r15, r15
    19da:	68 94       	set
    19dc:	e1 f8       	bld	r14, 1
    19de:	e0 0e       	add	r14, r16
    19e0:	f1 1e       	adc	r15, r17
    19e2:	c7 01       	movw	r24, r14
    19e4:	0e 94 65 05 	call	0xaca	; 0xaca <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    19e8:	c8 01       	movw	r24, r16
    19ea:	0c 96       	adiw	r24, 0x0c	; 12
    19ec:	0e 94 65 05 	call	0xaca	; 0xaca <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    19f0:	f8 01       	movw	r30, r16
    19f2:	11 87       	std	Z+9, r17	; 0x09
    19f4:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    19f6:	85 e0       	ldi	r24, 0x05	; 5
    19f8:	90 e0       	ldi	r25, 0x00	; 0
    19fa:	8c 1b       	sub	r24, r28
    19fc:	91 09       	sbc	r25, r1
    19fe:	95 87       	std	Z+13, r25	; 0x0d
    1a00:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    1a02:	13 8b       	std	Z+19, r17	; 0x13
    1a04:	02 8b       	std	Z+18, r16	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    1a06:	15 a2       	lds	r17, 0x95
    1a08:	16 a2       	lds	r17, 0x96
    1a0a:	17 a2       	lds	r17, 0x97
    1a0c:	10 a6       	lds	r17, 0xb0
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1a0e:	11 a6       	lds	r17, 0xb1
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1a10:	c1 01       	movw	r24, r2
    1a12:	b3 01       	movw	r22, r6
    1a14:	a2 01       	movw	r20, r4
    1a16:	0e 94 47 06 	call	0xc8e	; 0xc8e <pxPortInitialiseStack>
    1a1a:	f8 01       	movw	r30, r16
    1a1c:	91 83       	std	Z+1, r25	; 0x01
    1a1e:	80 83       	st	Z, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    1a20:	81 14       	cp	r8, r1
    1a22:	91 04       	cpc	r9, r1
    1a24:	19 f0       	breq	.+6      	; 0x1a2c <xTaskCreate+0xfa>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1a26:	f4 01       	movw	r30, r8
    1a28:	11 83       	std	Z+1, r17	; 0x01
    1a2a:	00 83       	st	Z, r16

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    1a2c:	0f b6       	in	r0, 0x3f	; 63
    1a2e:	f8 94       	cli
    1a30:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    1a32:	80 91 b7 03 	lds	r24, 0x03B7
    1a36:	8f 5f       	subi	r24, 0xFF	; 255
    1a38:	80 93 b7 03 	sts	0x03B7, r24
		if( pxCurrentTCB == NULL )
    1a3c:	80 91 ab 03 	lds	r24, 0x03AB
    1a40:	90 91 ac 03 	lds	r25, 0x03AC
    1a44:	00 97       	sbiw	r24, 0x00	; 0
    1a46:	09 f0       	breq	.+2      	; 0x1a4a <xTaskCreate+0x118>
    1a48:	3f c0       	rjmp	.+126    	; 0x1ac8 <xTaskCreate+0x196>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    1a4a:	10 93 ac 03 	sts	0x03AC, r17
    1a4e:	00 93 ab 03 	sts	0x03AB, r16

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    1a52:	80 91 b7 03 	lds	r24, 0x03B7
    1a56:	81 30       	cpi	r24, 0x01	; 1
    1a58:	09 f0       	breq	.+2      	; 0x1a5c <xTaskCreate+0x12a>
    1a5a:	47 c0       	rjmp	.+142    	; 0x1aea <xTaskCreate+0x1b8>
    1a5c:	c0 e0       	ldi	r28, 0x00	; 0
    1a5e:	d0 e0       	ldi	r29, 0x00	; 0
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1a60:	ce 01       	movw	r24, r28
    1a62:	88 0f       	add	r24, r24
    1a64:	99 1f       	adc	r25, r25
    1a66:	88 0f       	add	r24, r24
    1a68:	99 1f       	adc	r25, r25
    1a6a:	88 0f       	add	r24, r24
    1a6c:	99 1f       	adc	r25, r25
    1a6e:	8c 0f       	add	r24, r28
    1a70:	9d 1f       	adc	r25, r29
    1a72:	82 54       	subi	r24, 0x42	; 66
    1a74:	9c 4f       	sbci	r25, 0xFC	; 252
    1a76:	0e 94 57 05 	call	0xaae	; 0xaae <vListInitialise>
    1a7a:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    1a7c:	c5 30       	cpi	r28, 0x05	; 5
    1a7e:	d1 05       	cpc	r29, r1
    1a80:	79 f7       	brne	.-34     	; 0x1a60 <xTaskCreate+0x12e>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    1a82:	cb ee       	ldi	r28, 0xEB	; 235
    1a84:	d3 e0       	ldi	r29, 0x03	; 3
    1a86:	ce 01       	movw	r24, r28
    1a88:	0e 94 57 05 	call	0xaae	; 0xaae <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    1a8c:	0f 2e       	mov	r0, r31
    1a8e:	f4 ef       	ldi	r31, 0xF4	; 244
    1a90:	af 2e       	mov	r10, r31
    1a92:	f3 e0       	ldi	r31, 0x03	; 3
    1a94:	bf 2e       	mov	r11, r31
    1a96:	f0 2d       	mov	r31, r0
    1a98:	c5 01       	movw	r24, r10
    1a9a:	0e 94 57 05 	call	0xaae	; 0xaae <vListInitialise>
	vListInitialise( &xPendingReadyList );
    1a9e:	8d ef       	ldi	r24, 0xFD	; 253
    1aa0:	93 e0       	ldi	r25, 0x03	; 3
    1aa2:	0e 94 57 05 	call	0xaae	; 0xaae <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    1aa6:	86 e0       	ldi	r24, 0x06	; 6
    1aa8:	94 e0       	ldi	r25, 0x04	; 4
    1aaa:	0e 94 57 05 	call	0xaae	; 0xaae <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    1aae:	8f e0       	ldi	r24, 0x0F	; 15
    1ab0:	94 e0       	ldi	r25, 0x04	; 4
    1ab2:	0e 94 57 05 	call	0xaae	; 0xaae <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1ab6:	d0 93 bc 03 	sts	0x03BC, r29
    1aba:	c0 93 bb 03 	sts	0x03BB, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1abe:	b0 92 ba 03 	sts	0x03BA, r11
    1ac2:	a0 92 b9 03 	sts	0x03B9, r10
    1ac6:	11 c0       	rjmp	.+34     	; 0x1aea <xTaskCreate+0x1b8>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    1ac8:	80 91 b3 03 	lds	r24, 0x03B3
    1acc:	88 23       	and	r24, r24
    1ace:	69 f4       	brne	.+26     	; 0x1aea <xTaskCreate+0x1b8>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    1ad0:	e0 91 ab 03 	lds	r30, 0x03AB
    1ad4:	f0 91 ac 03 	lds	r31, 0x03AC
    1ad8:	96 89       	ldd	r25, Z+22	; 0x16
    1ada:	f8 01       	movw	r30, r16
    1adc:	86 89       	ldd	r24, Z+22	; 0x16
    1ade:	89 17       	cp	r24, r25
    1ae0:	20 f0       	brcs	.+8      	; 0x1aea <xTaskCreate+0x1b8>
				{
					pxCurrentTCB = pxNewTCB;
    1ae2:	10 93 ac 03 	sts	0x03AC, r17
    1ae6:	00 93 ab 03 	sts	0x03AB, r16
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    1aea:	80 91 bd 03 	lds	r24, 0x03BD
    1aee:	8f 5f       	subi	r24, 0xFF	; 255
    1af0:	80 93 bd 03 	sts	0x03BD, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    1af4:	f8 01       	movw	r30, r16
    1af6:	86 89       	ldd	r24, Z+22	; 0x16
    1af8:	90 91 b4 03 	lds	r25, 0x03B4
    1afc:	98 17       	cp	r25, r24
    1afe:	10 f4       	brcc	.+4      	; 0x1b04 <xTaskCreate+0x1d2>
    1b00:	80 93 b4 03 	sts	0x03B4, r24
    1b04:	90 e0       	ldi	r25, 0x00	; 0
    1b06:	9c 01       	movw	r18, r24
    1b08:	22 0f       	add	r18, r18
    1b0a:	33 1f       	adc	r19, r19
    1b0c:	22 0f       	add	r18, r18
    1b0e:	33 1f       	adc	r19, r19
    1b10:	22 0f       	add	r18, r18
    1b12:	33 1f       	adc	r19, r19
    1b14:	82 0f       	add	r24, r18
    1b16:	93 1f       	adc	r25, r19
    1b18:	82 54       	subi	r24, 0x42	; 66
    1b1a:	9c 4f       	sbci	r25, 0xFC	; 252
    1b1c:	b7 01       	movw	r22, r14
    1b1e:	0e 94 69 05 	call	0xad2	; 0xad2 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    1b22:	0f 90       	pop	r0
    1b24:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    1b26:	80 91 b3 03 	lds	r24, 0x03B3
    1b2a:	88 23       	and	r24, r24
    1b2c:	41 f0       	breq	.+16     	; 0x1b3e <xTaskCreate+0x20c>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    1b2e:	80 91 ab 03 	lds	r24, 0x03AB
    1b32:	90 91 ac 03 	lds	r25, 0x03AC
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    1b36:	81 e0       	ldi	r24, 0x01	; 1
    1b38:	03 c0       	rjmp	.+6      	; 0x1b40 <xTaskCreate+0x20e>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1b3a:	8f ef       	ldi	r24, 0xFF	; 255
    1b3c:	01 c0       	rjmp	.+2      	; 0x1b40 <xTaskCreate+0x20e>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    1b3e:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
		}

		return xReturn;
	}
    1b40:	df 91       	pop	r29
    1b42:	cf 91       	pop	r28
    1b44:	1f 91       	pop	r17
    1b46:	0f 91       	pop	r16
    1b48:	ff 90       	pop	r15
    1b4a:	ef 90       	pop	r14
    1b4c:	df 90       	pop	r13
    1b4e:	bf 90       	pop	r11
    1b50:	af 90       	pop	r10
    1b52:	9f 90       	pop	r9
    1b54:	8f 90       	pop	r8
    1b56:	7f 90       	pop	r7
    1b58:	6f 90       	pop	r6
    1b5a:	5f 90       	pop	r5
    1b5c:	4f 90       	pop	r4
    1b5e:	3f 90       	pop	r3
    1b60:	2f 90       	pop	r2
    1b62:	08 95       	ret

00001b64 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    1b64:	0f 93       	push	r16
    1b66:	1f 93       	push	r17
    1b68:	cf 93       	push	r28
    1b6a:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    1b6c:	0f b6       	in	r0, 0x3f	; 63
    1b6e:	f8 94       	cli
    1b70:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    1b72:	00 97       	sbiw	r24, 0x00	; 0
    1b74:	29 f4       	brne	.+10     	; 0x1b80 <vTaskDelete+0x1c>
    1b76:	c0 91 ab 03 	lds	r28, 0x03AB
    1b7a:	d0 91 ac 03 	lds	r29, 0x03AC
    1b7e:	01 c0       	rjmp	.+2      	; 0x1b82 <vTaskDelete+0x1e>
    1b80:	ec 01       	movw	r28, r24

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1b82:	8e 01       	movw	r16, r28
    1b84:	0e 5f       	subi	r16, 0xFE	; 254
    1b86:	1f 4f       	sbci	r17, 0xFF	; 255
    1b88:	c8 01       	movw	r24, r16
    1b8a:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1b8e:	8c 89       	ldd	r24, Y+20	; 0x14
    1b90:	9d 89       	ldd	r25, Y+21	; 0x15
    1b92:	00 97       	sbiw	r24, 0x00	; 0
    1b94:	21 f0       	breq	.+8      	; 0x1b9e <vTaskDelete+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1b96:	ce 01       	movw	r24, r28
    1b98:	0c 96       	adiw	r24, 0x0c	; 12
    1b9a:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    1b9e:	80 91 bd 03 	lds	r24, 0x03BD
    1ba2:	8f 5f       	subi	r24, 0xFF	; 255
    1ba4:	80 93 bd 03 	sts	0x03BD, r24

			if( pxTCB == pxCurrentTCB )
    1ba8:	80 91 ab 03 	lds	r24, 0x03AB
    1bac:	90 91 ac 03 	lds	r25, 0x03AC
    1bb0:	c8 17       	cp	r28, r24
    1bb2:	d9 07       	cpc	r29, r25
    1bb4:	59 f4       	brne	.+22     	; 0x1bcc <vTaskDelete+0x68>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    1bb6:	86 e0       	ldi	r24, 0x06	; 6
    1bb8:	94 e0       	ldi	r25, 0x04	; 4
    1bba:	b8 01       	movw	r22, r16
    1bbc:	0e 94 69 05 	call	0xad2	; 0xad2 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    1bc0:	80 91 b8 03 	lds	r24, 0x03B8
    1bc4:	8f 5f       	subi	r24, 0xFF	; 255
    1bc6:	80 93 b8 03 	sts	0x03B8, r24
    1bca:	0a c0       	rjmp	.+20     	; 0x1be0 <vTaskDelete+0x7c>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    1bcc:	80 91 b7 03 	lds	r24, 0x03B7
    1bd0:	81 50       	subi	r24, 0x01	; 1
    1bd2:	80 93 b7 03 	sts	0x03B7, r24
				prvDeleteTCB( pxTCB );
    1bd6:	ce 01       	movw	r24, r28
    1bd8:	0e 94 8c 0c 	call	0x1918	; 0x1918 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    1bdc:	0e 94 15 0c 	call	0x182a	; 0x182a <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1be0:	0f 90       	pop	r0
    1be2:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    1be4:	80 91 b3 03 	lds	r24, 0x03B3
    1be8:	88 23       	and	r24, r24
    1bea:	49 f0       	breq	.+18     	; 0x1bfe <vTaskDelete+0x9a>
		{
			if( pxTCB == pxCurrentTCB )
    1bec:	80 91 ab 03 	lds	r24, 0x03AB
    1bf0:	90 91 ac 03 	lds	r25, 0x03AC
    1bf4:	c8 17       	cp	r28, r24
    1bf6:	d9 07       	cpc	r29, r25
    1bf8:	11 f4       	brne	.+4      	; 0x1bfe <vTaskDelete+0x9a>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    1bfa:	0e 94 0d 07 	call	0xe1a	; 0xe1a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    1bfe:	df 91       	pop	r29
    1c00:	cf 91       	pop	r28
    1c02:	1f 91       	pop	r17
    1c04:	0f 91       	pop	r16
    1c06:	08 95       	ret

00001c08 <uxTaskPriorityGet>:
	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    1c08:	0f b6       	in	r0, 0x3f	; 63
    1c0a:	f8 94       	cli
    1c0c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the that
			called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1c0e:	00 97       	sbiw	r24, 0x00	; 0
    1c10:	29 f4       	brne	.+10     	; 0x1c1c <uxTaskPriorityGet+0x14>
    1c12:	e0 91 ab 03 	lds	r30, 0x03AB
    1c16:	f0 91 ac 03 	lds	r31, 0x03AC
    1c1a:	01 c0       	rjmp	.+2      	; 0x1c1e <uxTaskPriorityGet+0x16>
    1c1c:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		taskEXIT_CRITICAL();
    1c1e:	0f 90       	pop	r0
    1c20:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    1c22:	86 89       	ldd	r24, Z+22	; 0x16
    1c24:	08 95       	ret

00001c26 <uxTaskPriorityGetFromISR>:

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1c26:	00 97       	sbiw	r24, 0x00	; 0
    1c28:	29 f4       	brne	.+10     	; 0x1c34 <uxTaskPriorityGetFromISR+0xe>
    1c2a:	e0 91 ab 03 	lds	r30, 0x03AB
    1c2e:	f0 91 ac 03 	lds	r31, 0x03AC
    1c32:	01 c0       	rjmp	.+2      	; 0x1c36 <uxTaskPriorityGetFromISR+0x10>
    1c34:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
	}
    1c36:	86 89       	ldd	r24, Z+22	; 0x16
    1c38:	08 95       	ret

00001c3a <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    1c3a:	0f 93       	push	r16
    1c3c:	1f 93       	push	r17
    1c3e:	cf 93       	push	r28
    1c40:	df 93       	push	r29

		taskENTER_CRITICAL();
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1c42:	65 30       	cpi	r22, 0x05	; 5
    1c44:	08 f0       	brcs	.+2      	; 0x1c48 <vTaskPrioritySet+0xe>
    1c46:	64 e0       	ldi	r22, 0x04	; 4
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    1c48:	0f b6       	in	r0, 0x3f	; 63
    1c4a:	f8 94       	cli
    1c4c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1c4e:	00 97       	sbiw	r24, 0x00	; 0
    1c50:	29 f4       	brne	.+10     	; 0x1c5c <vTaskPrioritySet+0x22>
    1c52:	c0 91 ab 03 	lds	r28, 0x03AB
    1c56:	d0 91 ac 03 	lds	r29, 0x03AC
    1c5a:	01 c0       	rjmp	.+2      	; 0x1c5e <vTaskPrioritySet+0x24>
    1c5c:	ec 01       	movw	r28, r24

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    1c5e:	2b a1       	lds	r18, 0x4b
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    1c60:	26 17       	cp	r18, r22
    1c62:	09 f4       	brne	.+2      	; 0x1c66 <vTaskPrioritySet+0x2c>
    1c64:	4e c0       	rjmp	.+156    	; 0x1d02 <vTaskPrioritySet+0xc8>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    1c66:	26 17       	cp	r18, r22
    1c68:	60 f4       	brcc	.+24     	; 0x1c82 <vTaskPrioritySet+0x48>
				{
					if( pxTCB != pxCurrentTCB )
    1c6a:	80 91 ab 03 	lds	r24, 0x03AB
    1c6e:	90 91 ac 03 	lds	r25, 0x03AC
    1c72:	c8 17       	cp	r28, r24
    1c74:	d9 07       	cpc	r29, r25
    1c76:	49 f0       	breq	.+18     	; 0x1c8a <vTaskPrioritySet+0x50>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    1c78:	80 91 ab 03 	lds	r24, 0x03AB
    1c7c:	90 91 ac 03 	lds	r25, 0x03AC
    1c80:	04 c0       	rjmp	.+8      	; 0x1c8a <vTaskPrioritySet+0x50>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    1c82:	80 91 ab 03 	lds	r24, 0x03AB
    1c86:	90 91 ac 03 	lds	r25, 0x03AC
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    1c8a:	8e 89       	ldd	r24, Y+22	; 0x16

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    1c8c:	28 17       	cp	r18, r24
    1c8e:	09 f4       	brne	.+2      	; 0x1c92 <vTaskPrioritySet+0x58>
					{
						pxTCB->uxPriority = uxNewPriority;
    1c90:	6e 8b       	std	Y+22, r22	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    1c92:	6b a3       	lds	r22, 0x5b
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1c94:	2c 85       	ldd	r18, Y+12	; 0x0c
    1c96:	3d 85       	ldd	r19, Y+13	; 0x0d
    1c98:	33 23       	and	r19, r19
    1c9a:	34 f0       	brlt	.+12     	; 0x1ca8 <vTaskPrioritySet+0x6e>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1c9c:	25 e0       	ldi	r18, 0x05	; 5
    1c9e:	30 e0       	ldi	r19, 0x00	; 0
    1ca0:	26 1b       	sub	r18, r22
    1ca2:	31 09       	sbc	r19, r1
    1ca4:	3d 87       	std	Y+13, r19	; 0x0d
    1ca6:	2c 87       	std	Y+12, r18	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    1ca8:	90 e0       	ldi	r25, 0x00	; 0
    1caa:	9c 01       	movw	r18, r24
    1cac:	22 0f       	add	r18, r18
    1cae:	33 1f       	adc	r19, r19
    1cb0:	22 0f       	add	r18, r18
    1cb2:	33 1f       	adc	r19, r19
    1cb4:	22 0f       	add	r18, r18
    1cb6:	33 1f       	adc	r19, r19
    1cb8:	82 0f       	add	r24, r18
    1cba:	93 1f       	adc	r25, r19
    1cbc:	82 54       	subi	r24, 0x42	; 66
    1cbe:	9c 4f       	sbci	r25, 0xFC	; 252
    1cc0:	2a 85       	ldd	r18, Y+10	; 0x0a
    1cc2:	3b 85       	ldd	r19, Y+11	; 0x0b
    1cc4:	28 17       	cp	r18, r24
    1cc6:	39 07       	cpc	r19, r25
    1cc8:	e1 f4       	brne	.+56     	; 0x1d02 <vTaskPrioritySet+0xc8>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1cca:	8e 01       	movw	r16, r28
    1ccc:	0e 5f       	subi	r16, 0xFE	; 254
    1cce:	1f 4f       	sbci	r17, 0xFF	; 255
    1cd0:	c8 01       	movw	r24, r16
    1cd2:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    1cd6:	8e 89       	ldd	r24, Y+22	; 0x16
    1cd8:	90 91 b4 03 	lds	r25, 0x03B4
    1cdc:	98 17       	cp	r25, r24
    1cde:	10 f4       	brcc	.+4      	; 0x1ce4 <vTaskPrioritySet+0xaa>
    1ce0:	80 93 b4 03 	sts	0x03B4, r24
    1ce4:	90 e0       	ldi	r25, 0x00	; 0
    1ce6:	9c 01       	movw	r18, r24
    1ce8:	22 0f       	add	r18, r18
    1cea:	33 1f       	adc	r19, r19
    1cec:	22 0f       	add	r18, r18
    1cee:	33 1f       	adc	r19, r19
    1cf0:	22 0f       	add	r18, r18
    1cf2:	33 1f       	adc	r19, r19
    1cf4:	82 0f       	add	r24, r18
    1cf6:	93 1f       	adc	r25, r19
    1cf8:	82 54       	subi	r24, 0x42	; 66
    1cfa:	9c 4f       	sbci	r25, 0xFC	; 252
    1cfc:	b8 01       	movw	r22, r16
    1cfe:	0e 94 69 05 	call	0xad2	; 0xad2 <vListInsertEnd>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    1d02:	0f 90       	pop	r0
    1d04:	0f be       	out	0x3f, r0	; 63
	}
    1d06:	df 91       	pop	r29
    1d08:	cf 91       	pop	r28
    1d0a:	1f 91       	pop	r17
    1d0c:	0f 91       	pop	r16
    1d0e:	08 95       	ret

00001d10 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    1d10:	0f 93       	push	r16
    1d12:	1f 93       	push	r17
    1d14:	cf 93       	push	r28
    1d16:	df 93       	push	r29
    1d18:	ec 01       	movw	r28, r24
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    1d1a:	00 97       	sbiw	r24, 0x00	; 0
    1d1c:	89 f1       	breq	.+98     	; 0x1d80 <vTaskResume+0x70>
    1d1e:	80 91 ab 03 	lds	r24, 0x03AB
    1d22:	90 91 ac 03 	lds	r25, 0x03AC
    1d26:	c8 17       	cp	r28, r24
    1d28:	d9 07       	cpc	r29, r25
    1d2a:	51 f1       	breq	.+84     	; 0x1d80 <vTaskResume+0x70>
		{
			taskENTER_CRITICAL();
    1d2c:	0f b6       	in	r0, 0x3f	; 63
    1d2e:	f8 94       	cli
    1d30:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    1d32:	ce 01       	movw	r24, r28
    1d34:	0e 94 fe 0b 	call	0x17fc	; 0x17fc <prvTaskIsTaskSuspended>
    1d38:	88 23       	and	r24, r24
    1d3a:	01 f1       	breq	.+64     	; 0x1d7c <vTaskResume+0x6c>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    1d3c:	8e 01       	movw	r16, r28
    1d3e:	0e 5f       	subi	r16, 0xFE	; 254
    1d40:	1f 4f       	sbci	r17, 0xFF	; 255
    1d42:	c8 01       	movw	r24, r16
    1d44:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1d48:	8e 89       	ldd	r24, Y+22	; 0x16
    1d4a:	90 91 b4 03 	lds	r25, 0x03B4
    1d4e:	98 17       	cp	r25, r24
    1d50:	10 f4       	brcc	.+4      	; 0x1d56 <vTaskResume+0x46>
    1d52:	80 93 b4 03 	sts	0x03B4, r24
    1d56:	90 e0       	ldi	r25, 0x00	; 0
    1d58:	9c 01       	movw	r18, r24
    1d5a:	22 0f       	add	r18, r18
    1d5c:	33 1f       	adc	r19, r19
    1d5e:	22 0f       	add	r18, r18
    1d60:	33 1f       	adc	r19, r19
    1d62:	22 0f       	add	r18, r18
    1d64:	33 1f       	adc	r19, r19
    1d66:	82 0f       	add	r24, r18
    1d68:	93 1f       	adc	r25, r19
    1d6a:	82 54       	subi	r24, 0x42	; 66
    1d6c:	9c 4f       	sbci	r25, 0xFC	; 252
    1d6e:	b8 01       	movw	r22, r16
    1d70:	0e 94 69 05 	call	0xad2	; 0xad2 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1d74:	80 91 ab 03 	lds	r24, 0x03AB
    1d78:	90 91 ac 03 	lds	r25, 0x03AC
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    1d7c:	0f 90       	pop	r0
    1d7e:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1d80:	df 91       	pop	r29
    1d82:	cf 91       	pop	r28
    1d84:	1f 91       	pop	r17
    1d86:	0f 91       	pop	r16
    1d88:	08 95       	ret

00001d8a <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    1d8a:	ef 92       	push	r14
    1d8c:	ff 92       	push	r15
    1d8e:	1f 93       	push	r17
    1d90:	cf 93       	push	r28
    1d92:	df 93       	push	r29
    1d94:	ec 01       	movw	r28, r24
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    1d96:	0e 94 fe 0b 	call	0x17fc	; 0x17fc <prvTaskIsTaskSuspended>
    1d9a:	88 23       	and	r24, r24
    1d9c:	b9 f1       	breq	.+110    	; 0x1e0c <xTaskResumeFromISR+0x82>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1d9e:	80 91 ad 03 	lds	r24, 0x03AD
    1da2:	88 23       	and	r24, r24
    1da4:	51 f5       	brne	.+84     	; 0x1dfa <xTaskResumeFromISR+0x70>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1da6:	e0 91 ab 03 	lds	r30, 0x03AB
    1daa:	f0 91 ac 03 	lds	r31, 0x03AC

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
    1dae:	11 e0       	ldi	r17, 0x01	; 1
    1db0:	9e 89       	ldd	r25, Y+22	; 0x16
    1db2:	86 89       	ldd	r24, Z+22	; 0x16
    1db4:	98 17       	cp	r25, r24
    1db6:	08 f4       	brcc	.+2      	; 0x1dba <xTaskResumeFromISR+0x30>
    1db8:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1dba:	ee 24       	eor	r14, r14
    1dbc:	ff 24       	eor	r15, r15
    1dbe:	68 94       	set
    1dc0:	e1 f8       	bld	r14, 1
    1dc2:	ec 0e       	add	r14, r28
    1dc4:	fd 1e       	adc	r15, r29
    1dc6:	c7 01       	movw	r24, r14
    1dc8:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1dcc:	8e 89       	ldd	r24, Y+22	; 0x16
    1dce:	90 91 b4 03 	lds	r25, 0x03B4
    1dd2:	98 17       	cp	r25, r24
    1dd4:	10 f4       	brcc	.+4      	; 0x1dda <xTaskResumeFromISR+0x50>
    1dd6:	80 93 b4 03 	sts	0x03B4, r24
    1dda:	90 e0       	ldi	r25, 0x00	; 0
    1ddc:	9c 01       	movw	r18, r24
    1dde:	22 0f       	add	r18, r18
    1de0:	33 1f       	adc	r19, r19
    1de2:	22 0f       	add	r18, r18
    1de4:	33 1f       	adc	r19, r19
    1de6:	22 0f       	add	r18, r18
    1de8:	33 1f       	adc	r19, r19
    1dea:	82 0f       	add	r24, r18
    1dec:	93 1f       	adc	r25, r19
    1dee:	82 54       	subi	r24, 0x42	; 66
    1df0:	9c 4f       	sbci	r25, 0xFC	; 252
    1df2:	b7 01       	movw	r22, r14
    1df4:	0e 94 69 05 	call	0xad2	; 0xad2 <vListInsertEnd>
    1df8:	0a c0       	rjmp	.+20     	; 0x1e0e <xTaskResumeFromISR+0x84>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1dfa:	be 01       	movw	r22, r28
    1dfc:	64 5f       	subi	r22, 0xF4	; 244
    1dfe:	7f 4f       	sbci	r23, 0xFF	; 255
    1e00:	8d ef       	ldi	r24, 0xFD	; 253
    1e02:	93 e0       	ldi	r25, 0x03	; 3
    1e04:	0e 94 69 05 	call	0xad2	; 0xad2 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
    1e08:	10 e0       	ldi	r17, 0x00	; 0
    1e0a:	01 c0       	rjmp	.+2      	; 0x1e0e <xTaskResumeFromISR+0x84>
    1e0c:	10 e0       	ldi	r17, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
    1e0e:	81 2f       	mov	r24, r17
    1e10:	df 91       	pop	r29
    1e12:	cf 91       	pop	r28
    1e14:	1f 91       	pop	r17
    1e16:	ff 90       	pop	r15
    1e18:	ef 90       	pop	r14
    1e1a:	08 95       	ret

00001e1c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    1e1c:	ef 92       	push	r14
    1e1e:	ff 92       	push	r15
    1e20:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    1e22:	87 e7       	ldi	r24, 0x77	; 119
    1e24:	90 e1       	ldi	r25, 0x10	; 16
    1e26:	6d e7       	ldi	r22, 0x7D	; 125
    1e28:	70 e0       	ldi	r23, 0x00	; 0
    1e2a:	48 ec       	ldi	r20, 0xC8	; 200
    1e2c:	50 e0       	ldi	r21, 0x00	; 0
    1e2e:	20 e0       	ldi	r18, 0x00	; 0
    1e30:	30 e0       	ldi	r19, 0x00	; 0
    1e32:	00 e0       	ldi	r16, 0x00	; 0
    1e34:	0f 2e       	mov	r0, r31
    1e36:	f8 e1       	ldi	r31, 0x18	; 24
    1e38:	ef 2e       	mov	r14, r31
    1e3a:	f4 e0       	ldi	r31, 0x04	; 4
    1e3c:	ff 2e       	mov	r15, r31
    1e3e:	f0 2d       	mov	r31, r0
    1e40:	0e 94 99 0c 	call	0x1932	; 0x1932 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    1e44:	81 30       	cpi	r24, 0x01	; 1
    1e46:	81 f4       	brne	.+32     	; 0x1e68 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    1e48:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    1e4a:	8f ef       	ldi	r24, 0xFF	; 255
    1e4c:	9f ef       	ldi	r25, 0xFF	; 255
    1e4e:	90 93 af 03 	sts	0x03AF, r25
    1e52:	80 93 ae 03 	sts	0x03AE, r24
		xSchedulerRunning = pdTRUE;
    1e56:	81 e0       	ldi	r24, 0x01	; 1
    1e58:	80 93 b3 03 	sts	0x03B3, r24
		xTickCount = ( TickType_t ) 0U;
    1e5c:	10 92 b6 03 	sts	0x03B6, r1
    1e60:	10 92 b5 03 	sts	0x03B5, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1e64:	0e 94 d7 06 	call	0xdae	; 0xdae <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    1e68:	0f 91       	pop	r16
    1e6a:	ff 90       	pop	r15
    1e6c:	ef 90       	pop	r14
    1e6e:	08 95       	ret

00001e70 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1e70:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1e72:	10 92 b3 03 	sts	0x03B3, r1
	vPortEndScheduler();
    1e76:	0e 94 0c 07 	call	0xe18	; 0xe18 <vPortEndScheduler>
}
    1e7a:	08 95       	ret

00001e7c <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    1e7c:	80 91 ad 03 	lds	r24, 0x03AD
    1e80:	8f 5f       	subi	r24, 0xFF	; 255
    1e82:	80 93 ad 03 	sts	0x03AD, r24
}
    1e86:	08 95       	ret

00001e88 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    1e88:	0f b6       	in	r0, 0x3f	; 63
    1e8a:	f8 94       	cli
    1e8c:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1e8e:	80 91 b5 03 	lds	r24, 0x03B5
    1e92:	90 91 b6 03 	lds	r25, 0x03B6
	}
	portTICK_TYPE_EXIT_CRITICAL();
    1e96:	0f 90       	pop	r0
    1e98:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1e9a:	08 95       	ret

00001e9c <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
    1e9c:	80 91 b5 03 	lds	r24, 0x03B5
    1ea0:	90 91 b6 03 	lds	r25, 0x03B6
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1ea4:	08 95       	ret

00001ea6 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    1ea6:	80 91 b7 03 	lds	r24, 0x03B7
}
    1eaa:	08 95       	ret

00001eac <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1eac:	00 97       	sbiw	r24, 0x00	; 0
    1eae:	21 f4       	brne	.+8      	; 0x1eb8 <pcTaskGetName+0xc>
    1eb0:	80 91 ab 03 	lds	r24, 0x03AB
    1eb4:	90 91 ac 03 	lds	r25, 0x03AC
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    1eb8:	49 96       	adiw	r24, 0x19	; 25
}
    1eba:	08 95       	ret

00001ebc <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    1ebc:	ef 92       	push	r14
    1ebe:	ff 92       	push	r15
    1ec0:	0f 93       	push	r16
    1ec2:	1f 93       	push	r17
    1ec4:	cf 93       	push	r28
    1ec6:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1ec8:	80 91 ad 03 	lds	r24, 0x03AD
    1ecc:	88 23       	and	r24, r24
    1ece:	09 f0       	breq	.+2      	; 0x1ed2 <xTaskIncrementTick+0x16>
    1ed0:	89 c0       	rjmp	.+274    	; 0x1fe4 <xTaskIncrementTick+0x128>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    1ed2:	e0 90 b5 03 	lds	r14, 0x03B5
    1ed6:	f0 90 b6 03 	lds	r15, 0x03B6
    1eda:	08 94       	sec
    1edc:	e1 1c       	adc	r14, r1
    1ede:	f1 1c       	adc	r15, r1

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    1ee0:	f0 92 b6 03 	sts	0x03B6, r15
    1ee4:	e0 92 b5 03 	sts	0x03B5, r14

		if( xConstTickCount == ( TickType_t ) 0U )
    1ee8:	e1 14       	cp	r14, r1
    1eea:	f1 04       	cpc	r15, r1
    1eec:	b9 f4       	brne	.+46     	; 0x1f1c <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
    1eee:	80 91 bb 03 	lds	r24, 0x03BB
    1ef2:	90 91 bc 03 	lds	r25, 0x03BC
    1ef6:	20 91 b9 03 	lds	r18, 0x03B9
    1efa:	30 91 ba 03 	lds	r19, 0x03BA
    1efe:	30 93 bc 03 	sts	0x03BC, r19
    1f02:	20 93 bb 03 	sts	0x03BB, r18
    1f06:	90 93 ba 03 	sts	0x03BA, r25
    1f0a:	80 93 b9 03 	sts	0x03B9, r24
    1f0e:	80 91 b0 03 	lds	r24, 0x03B0
    1f12:	8f 5f       	subi	r24, 0xFF	; 255
    1f14:	80 93 b0 03 	sts	0x03B0, r24
    1f18:	0e 94 15 0c 	call	0x182a	; 0x182a <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    1f1c:	80 91 ae 03 	lds	r24, 0x03AE
    1f20:	90 91 af 03 	lds	r25, 0x03AF
    1f24:	e8 16       	cp	r14, r24
    1f26:	f9 06       	cpc	r15, r25
    1f28:	08 f4       	brcc	.+2      	; 0x1f2c <xTaskIncrementTick+0x70>
    1f2a:	61 c0       	rjmp	.+194    	; 0x1fee <xTaskIncrementTick+0x132>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1f2c:	e0 91 bb 03 	lds	r30, 0x03BB
    1f30:	f0 91 bc 03 	lds	r31, 0x03BC
    1f34:	80 81       	ld	r24, Z
    1f36:	88 23       	and	r24, r24
    1f38:	79 f0       	breq	.+30     	; 0x1f58 <xTaskIncrementTick+0x9c>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1f3a:	e0 91 bb 03 	lds	r30, 0x03BB
    1f3e:	f0 91 bc 03 	lds	r31, 0x03BC
    1f42:	05 80       	ldd	r0, Z+5	; 0x05
    1f44:	f6 81       	ldd	r31, Z+6	; 0x06
    1f46:	e0 2d       	mov	r30, r0
    1f48:	c6 81       	ldd	r28, Z+6	; 0x06
    1f4a:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    1f4c:	8a 81       	ldd	r24, Y+2	; 0x02
    1f4e:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
    1f50:	e8 16       	cp	r14, r24
    1f52:	f9 06       	cpc	r15, r25
    1f54:	d8 f4       	brcc	.+54     	; 0x1f8c <xTaskIncrementTick+0xd0>
    1f56:	15 c0       	rjmp	.+42     	; 0x1f82 <xTaskIncrementTick+0xc6>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1f58:	8f ef       	ldi	r24, 0xFF	; 255
    1f5a:	9f ef       	ldi	r25, 0xFF	; 255
    1f5c:	90 93 af 03 	sts	0x03AF, r25
    1f60:	80 93 ae 03 	sts	0x03AE, r24
					break;
    1f64:	44 c0       	rjmp	.+136    	; 0x1fee <xTaskIncrementTick+0x132>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1f66:	e0 91 bb 03 	lds	r30, 0x03BB
    1f6a:	f0 91 bc 03 	lds	r31, 0x03BC
    1f6e:	05 80       	ldd	r0, Z+5	; 0x05
    1f70:	f6 81       	ldd	r31, Z+6	; 0x06
    1f72:	e0 2d       	mov	r30, r0
    1f74:	c6 81       	ldd	r28, Z+6	; 0x06
    1f76:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    1f78:	8a 81       	ldd	r24, Y+2	; 0x02
    1f7a:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
    1f7c:	e8 16       	cp	r14, r24
    1f7e:	f9 06       	cpc	r15, r25
    1f80:	28 f4       	brcc	.+10     	; 0x1f8c <xTaskIncrementTick+0xd0>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    1f82:	90 93 af 03 	sts	0x03AF, r25
    1f86:	80 93 ae 03 	sts	0x03AE, r24
						break;
    1f8a:	31 c0       	rjmp	.+98     	; 0x1fee <xTaskIncrementTick+0x132>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1f8c:	8e 01       	movw	r16, r28
    1f8e:	0e 5f       	subi	r16, 0xFE	; 254
    1f90:	1f 4f       	sbci	r17, 0xFF	; 255
    1f92:	c8 01       	movw	r24, r16
    1f94:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1f98:	8c 89       	ldd	r24, Y+20	; 0x14
    1f9a:	9d 89       	ldd	r25, Y+21	; 0x15
    1f9c:	00 97       	sbiw	r24, 0x00	; 0
    1f9e:	21 f0       	breq	.+8      	; 0x1fa8 <xTaskIncrementTick+0xec>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1fa0:	ce 01       	movw	r24, r28
    1fa2:	0c 96       	adiw	r24, 0x0c	; 12
    1fa4:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    1fa8:	8e 89       	ldd	r24, Y+22	; 0x16
    1faa:	90 91 b4 03 	lds	r25, 0x03B4
    1fae:	98 17       	cp	r25, r24
    1fb0:	10 f4       	brcc	.+4      	; 0x1fb6 <xTaskIncrementTick+0xfa>
    1fb2:	80 93 b4 03 	sts	0x03B4, r24
    1fb6:	90 e0       	ldi	r25, 0x00	; 0
    1fb8:	9c 01       	movw	r18, r24
    1fba:	22 0f       	add	r18, r18
    1fbc:	33 1f       	adc	r19, r19
    1fbe:	22 0f       	add	r18, r18
    1fc0:	33 1f       	adc	r19, r19
    1fc2:	22 0f       	add	r18, r18
    1fc4:	33 1f       	adc	r19, r19
    1fc6:	82 0f       	add	r24, r18
    1fc8:	93 1f       	adc	r25, r19
    1fca:	82 54       	subi	r24, 0x42	; 66
    1fcc:	9c 4f       	sbci	r25, 0xFC	; 252
    1fce:	b8 01       	movw	r22, r16
    1fd0:	0e 94 69 05 	call	0xad2	; 0xad2 <vListInsertEnd>
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1fd4:	e0 91 bb 03 	lds	r30, 0x03BB
    1fd8:	f0 91 bc 03 	lds	r31, 0x03BC
    1fdc:	80 81       	ld	r24, Z
    1fde:	88 23       	and	r24, r24
    1fe0:	11 f6       	brne	.-124    	; 0x1f66 <xTaskIncrementTick+0xaa>
    1fe2:	ba cf       	rjmp	.-140    	; 0x1f58 <xTaskIncrementTick+0x9c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    1fe4:	80 91 b2 03 	lds	r24, 0x03B2
    1fe8:	8f 5f       	subi	r24, 0xFF	; 255
    1fea:	80 93 b2 03 	sts	0x03B2, r24
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    1fee:	80 e0       	ldi	r24, 0x00	; 0
    1ff0:	df 91       	pop	r29
    1ff2:	cf 91       	pop	r28
    1ff4:	1f 91       	pop	r17
    1ff6:	0f 91       	pop	r16
    1ff8:	ff 90       	pop	r15
    1ffa:	ef 90       	pop	r14
    1ffc:	08 95       	ret

00001ffe <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    1ffe:	df 92       	push	r13
    2000:	ef 92       	push	r14
    2002:	ff 92       	push	r15
    2004:	0f 93       	push	r16
    2006:	1f 93       	push	r17
    2008:	cf 93       	push	r28
    200a:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    200c:	0f b6       	in	r0, 0x3f	; 63
    200e:	f8 94       	cli
    2010:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2012:	80 91 ad 03 	lds	r24, 0x03AD
    2016:	81 50       	subi	r24, 0x01	; 1
    2018:	80 93 ad 03 	sts	0x03AD, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    201c:	80 91 ad 03 	lds	r24, 0x03AD
    2020:	88 23       	and	r24, r24
    2022:	09 f0       	breq	.+2      	; 0x2026 <xTaskResumeAll+0x28>
    2024:	59 c0       	rjmp	.+178    	; 0x20d8 <xTaskResumeAll+0xda>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    2026:	80 91 b7 03 	lds	r24, 0x03B7
    202a:	88 23       	and	r24, r24
    202c:	91 f5       	brne	.+100    	; 0x2092 <xTaskResumeAll+0x94>
    202e:	54 c0       	rjmp	.+168    	; 0x20d8 <xTaskResumeAll+0xda>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    2030:	e0 91 02 04 	lds	r30, 0x0402
    2034:	f0 91 03 04 	lds	r31, 0x0403
    2038:	c6 81       	ldd	r28, Z+6	; 0x06
    203a:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    203c:	ce 01       	movw	r24, r28
    203e:	0c 96       	adiw	r24, 0x0c	; 12
    2040:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2044:	8e 01       	movw	r16, r28
    2046:	0e 5f       	subi	r16, 0xFE	; 254
    2048:	1f 4f       	sbci	r17, 0xFF	; 255
    204a:	c8 01       	movw	r24, r16
    204c:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2050:	8e 89       	ldd	r24, Y+22	; 0x16
    2052:	90 91 b4 03 	lds	r25, 0x03B4
    2056:	98 17       	cp	r25, r24
    2058:	10 f4       	brcc	.+4      	; 0x205e <xTaskResumeAll+0x60>
    205a:	80 93 b4 03 	sts	0x03B4, r24
    205e:	90 e0       	ldi	r25, 0x00	; 0
    2060:	9c 01       	movw	r18, r24
    2062:	22 0f       	add	r18, r18
    2064:	33 1f       	adc	r19, r19
    2066:	22 0f       	add	r18, r18
    2068:	33 1f       	adc	r19, r19
    206a:	22 0f       	add	r18, r18
    206c:	33 1f       	adc	r19, r19
    206e:	82 0f       	add	r24, r18
    2070:	93 1f       	adc	r25, r19
    2072:	82 54       	subi	r24, 0x42	; 66
    2074:	9c 4f       	sbci	r25, 0xFC	; 252
    2076:	b8 01       	movw	r22, r16
    2078:	0e 94 69 05 	call	0xad2	; 0xad2 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    207c:	e0 91 ab 03 	lds	r30, 0x03AB
    2080:	f0 91 ac 03 	lds	r31, 0x03AC
    2084:	9e 89       	ldd	r25, Y+22	; 0x16
    2086:	86 89       	ldd	r24, Z+22	; 0x16
    2088:	98 17       	cp	r25, r24
    208a:	68 f0       	brcs	.+26     	; 0x20a6 <xTaskResumeAll+0xa8>
					{
						xYieldPending = pdTRUE;
    208c:	d0 92 b1 03 	sts	0x03B1, r13
    2090:	0a c0       	rjmp	.+20     	; 0x20a6 <xTaskResumeAll+0xa8>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    2092:	c0 e0       	ldi	r28, 0x00	; 0
    2094:	d0 e0       	ldi	r29, 0x00	; 0
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    2096:	0f 2e       	mov	r0, r31
    2098:	fd ef       	ldi	r31, 0xFD	; 253
    209a:	ef 2e       	mov	r14, r31
    209c:	f3 e0       	ldi	r31, 0x03	; 3
    209e:	ff 2e       	mov	r15, r31
    20a0:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    20a2:	dd 24       	eor	r13, r13
    20a4:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    20a6:	f7 01       	movw	r30, r14
    20a8:	80 81       	ld	r24, Z
    20aa:	88 23       	and	r24, r24
    20ac:	09 f6       	brne	.-126    	; 0x2030 <xTaskResumeAll+0x32>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    20ae:	20 97       	sbiw	r28, 0x00	; 0
    20b0:	11 f0       	breq	.+4      	; 0x20b6 <xTaskResumeAll+0xb8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    20b2:	0e 94 15 0c 	call	0x182a	; 0x182a <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    20b6:	c0 91 b2 03 	lds	r28, 0x03B2

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    20ba:	cc 23       	and	r28, r28
    20bc:	59 f0       	breq	.+22     	; 0x20d4 <xTaskResumeAll+0xd6>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
    20be:	01 e0       	ldi	r16, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    20c0:	0e 94 5e 0f 	call	0x1ebc	; 0x1ebc <xTaskIncrementTick>
    20c4:	88 23       	and	r24, r24
    20c6:	11 f0       	breq	.+4      	; 0x20cc <xTaskResumeAll+0xce>
							{
								xYieldPending = pdTRUE;
    20c8:	00 93 b1 03 	sts	0x03B1, r16
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    20cc:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    20ce:	c1 f7       	brne	.-16     	; 0x20c0 <xTaskResumeAll+0xc2>

						uxPendedTicks = 0;
    20d0:	10 92 b2 03 	sts	0x03B2, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    20d4:	80 91 b1 03 	lds	r24, 0x03B1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    20d8:	0f 90       	pop	r0
    20da:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    20dc:	80 e0       	ldi	r24, 0x00	; 0
    20de:	df 91       	pop	r29
    20e0:	cf 91       	pop	r28
    20e2:	1f 91       	pop	r17
    20e4:	0f 91       	pop	r16
    20e6:	ff 90       	pop	r15
    20e8:	ef 90       	pop	r14
    20ea:	df 90       	pop	r13
    20ec:	08 95       	ret

000020ee <prvIdleTask>:
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    20ee:	c6 e0       	ldi	r28, 0x06	; 6
    20f0:	d4 e0       	ldi	r29, 0x04	; 4
    20f2:	23 c0       	rjmp	.+70     	; 0x213a <prvIdleTask+0x4c>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    20f4:	0e 94 3e 0f 	call	0x1e7c	; 0x1e7c <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    20f8:	08 81       	ld	r16, Y
			}
			( void ) xTaskResumeAll();
    20fa:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    20fe:	00 23       	and	r16, r16
    2100:	e1 f0       	breq	.+56     	; 0x213a <prvIdleTask+0x4c>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    2102:	0f b6       	in	r0, 0x3f	; 63
    2104:	f8 94       	cli
    2106:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    2108:	e0 91 0b 04 	lds	r30, 0x040B
    210c:	f0 91 0c 04 	lds	r31, 0x040C
    2110:	06 81       	ldd	r16, Z+6	; 0x06
    2112:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2114:	c8 01       	movw	r24, r16
    2116:	02 96       	adiw	r24, 0x02	; 2
    2118:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>
					--uxCurrentNumberOfTasks;
    211c:	80 91 b7 03 	lds	r24, 0x03B7
    2120:	81 50       	subi	r24, 0x01	; 1
    2122:	80 93 b7 03 	sts	0x03B7, r24
					--uxDeletedTasksWaitingCleanUp;
    2126:	80 91 b8 03 	lds	r24, 0x03B8
    212a:	81 50       	subi	r24, 0x01	; 1
    212c:	80 93 b8 03 	sts	0x03B8, r24
				}
				taskEXIT_CRITICAL();
    2130:	0f 90       	pop	r0
    2132:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    2134:	c8 01       	movw	r24, r16
    2136:	0e 94 8c 0c 	call	0x1918	; 0x1918 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    213a:	80 91 b8 03 	lds	r24, 0x03B8
    213e:	88 23       	and	r24, r24
    2140:	c9 f6       	brne	.-78     	; 0x20f4 <prvIdleTask+0x6>
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
    2142:	0e 94 0d 07 	call	0xe1a	; 0xe1a <vPortYield>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    2146:	f9 cf       	rjmp	.-14     	; 0x213a <prvIdleTask+0x4c>

00002148 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2148:	cf 93       	push	r28
    214a:	df 93       	push	r29
    214c:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    214e:	00 97       	sbiw	r24, 0x00	; 0
    2150:	51 f0       	breq	.+20     	; 0x2166 <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2152:	0e 94 3e 0f 	call	0x1e7c	; 0x1e7c <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    2156:	ce 01       	movw	r24, r28
    2158:	60 e0       	ldi	r22, 0x00	; 0
    215a:	0e 94 34 0c 	call	0x1868	; 0x1868 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    215e:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2162:	88 23       	and	r24, r24
    2164:	11 f4       	brne	.+4      	; 0x216a <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
    2166:	0e 94 0d 07 	call	0xe1a	; 0xe1a <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    216a:	df 91       	pop	r29
    216c:	cf 91       	pop	r28
    216e:	08 95       	ret

00002170 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    2170:	0f 93       	push	r16
    2172:	1f 93       	push	r17
    2174:	cf 93       	push	r28
    2176:	df 93       	push	r29
    2178:	8c 01       	movw	r16, r24
    217a:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    217c:	0e 94 3e 0f 	call	0x1e7c	; 0x1e7c <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    2180:	80 91 b5 03 	lds	r24, 0x03B5
    2184:	90 91 b6 03 	lds	r25, 0x03B6

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2188:	f8 01       	movw	r30, r16
    218a:	20 81       	ld	r18, Z
    218c:	31 81       	ldd	r19, Z+1	; 0x01
    218e:	c2 0f       	add	r28, r18
    2190:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
    2192:	82 17       	cp	r24, r18
    2194:	93 07       	cpc	r25, r19
    2196:	48 f4       	brcc	.+18     	; 0x21aa <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    2198:	c2 17       	cp	r28, r18
    219a:	d3 07       	cpc	r29, r19
    219c:	f8 f4       	brcc	.+62     	; 0x21dc <vTaskDelayUntil+0x6c>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    219e:	d1 83       	std	Z+1, r29	; 0x01
    21a0:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    21a2:	8c 17       	cp	r24, r28
    21a4:	9d 07       	cpc	r25, r29
    21a6:	78 f4       	brcc	.+30     	; 0x21c6 <vTaskDelayUntil+0x56>
    21a8:	07 c0       	rjmp	.+14     	; 0x21b8 <vTaskDelayUntil+0x48>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    21aa:	c2 17       	cp	r28, r18
    21ac:	d3 07       	cpc	r29, r19
    21ae:	90 f0       	brcs	.+36     	; 0x21d4 <vTaskDelayUntil+0x64>
    21b0:	8c 17       	cp	r24, r28
    21b2:	9d 07       	cpc	r25, r29
    21b4:	78 f0       	brcs	.+30     	; 0x21d4 <vTaskDelayUntil+0x64>
    21b6:	12 c0       	rjmp	.+36     	; 0x21dc <vTaskDelayUntil+0x6c>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    21b8:	9e 01       	movw	r18, r28
    21ba:	28 1b       	sub	r18, r24
    21bc:	39 0b       	sbc	r19, r25
    21be:	c9 01       	movw	r24, r18
    21c0:	60 e0       	ldi	r22, 0x00	; 0
    21c2:	0e 94 34 0c 	call	0x1868	; 0x1868 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    21c6:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    21ca:	88 23       	and	r24, r24
    21cc:	59 f4       	brne	.+22     	; 0x21e4 <vTaskDelayUntil+0x74>
		{
			portYIELD_WITHIN_API();
    21ce:	0e 94 0d 07 	call	0xe1a	; 0xe1a <vPortYield>
    21d2:	08 c0       	rjmp	.+16     	; 0x21e4 <vTaskDelayUntil+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    21d4:	f8 01       	movw	r30, r16
    21d6:	d1 83       	std	Z+1, r29	; 0x01
    21d8:	c0 83       	st	Z, r28
    21da:	ee cf       	rjmp	.-36     	; 0x21b8 <vTaskDelayUntil+0x48>
    21dc:	f8 01       	movw	r30, r16
    21de:	d1 83       	std	Z+1, r29	; 0x01
    21e0:	c0 83       	st	Z, r28
    21e2:	f1 cf       	rjmp	.-30     	; 0x21c6 <vTaskDelayUntil+0x56>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    21e4:	df 91       	pop	r29
    21e6:	cf 91       	pop	r28
    21e8:	1f 91       	pop	r17
    21ea:	0f 91       	pop	r16
    21ec:	08 95       	ret

000021ee <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    21ee:	80 91 ad 03 	lds	r24, 0x03AD
    21f2:	88 23       	and	r24, r24
    21f4:	21 f0       	breq	.+8      	; 0x21fe <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    21f6:	81 e0       	ldi	r24, 0x01	; 1
    21f8:	80 93 b1 03 	sts	0x03B1, r24
    21fc:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    21fe:	10 92 b1 03 	sts	0x03B1, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    2202:	20 91 b4 03 	lds	r18, 0x03B4
    2206:	82 2f       	mov	r24, r18
    2208:	90 e0       	ldi	r25, 0x00	; 0
    220a:	fc 01       	movw	r30, r24
    220c:	ee 0f       	add	r30, r30
    220e:	ff 1f       	adc	r31, r31
    2210:	ee 0f       	add	r30, r30
    2212:	ff 1f       	adc	r31, r31
    2214:	ee 0f       	add	r30, r30
    2216:	ff 1f       	adc	r31, r31
    2218:	e8 0f       	add	r30, r24
    221a:	f9 1f       	adc	r31, r25
    221c:	e2 54       	subi	r30, 0x42	; 66
    221e:	fc 4f       	sbci	r31, 0xFC	; 252
    2220:	30 81       	ld	r19, Z
    2222:	33 23       	and	r19, r19
    2224:	89 f4       	brne	.+34     	; 0x2248 <vTaskSwitchContext+0x5a>
    2226:	21 50       	subi	r18, 0x01	; 1
    2228:	82 2f       	mov	r24, r18
    222a:	90 e0       	ldi	r25, 0x00	; 0
    222c:	fc 01       	movw	r30, r24
    222e:	ee 0f       	add	r30, r30
    2230:	ff 1f       	adc	r31, r31
    2232:	ee 0f       	add	r30, r30
    2234:	ff 1f       	adc	r31, r31
    2236:	ee 0f       	add	r30, r30
    2238:	ff 1f       	adc	r31, r31
    223a:	e8 0f       	add	r30, r24
    223c:	f9 1f       	adc	r31, r25
    223e:	e2 54       	subi	r30, 0x42	; 66
    2240:	fc 4f       	sbci	r31, 0xFC	; 252
    2242:	30 81       	ld	r19, Z
    2244:	33 23       	and	r19, r19
    2246:	79 f3       	breq	.-34     	; 0x2226 <vTaskSwitchContext+0x38>
    2248:	dc 01       	movw	r26, r24
    224a:	aa 0f       	add	r26, r26
    224c:	bb 1f       	adc	r27, r27
    224e:	aa 0f       	add	r26, r26
    2250:	bb 1f       	adc	r27, r27
    2252:	aa 0f       	add	r26, r26
    2254:	bb 1f       	adc	r27, r27
    2256:	8a 0f       	add	r24, r26
    2258:	9b 1f       	adc	r25, r27
    225a:	dc 01       	movw	r26, r24
    225c:	a2 54       	subi	r26, 0x42	; 66
    225e:	bc 4f       	sbci	r27, 0xFC	; 252
    2260:	11 96       	adiw	r26, 0x01	; 1
    2262:	ed 91       	ld	r30, X+
    2264:	fc 91       	ld	r31, X
    2266:	12 97       	sbiw	r26, 0x02	; 2
    2268:	02 80       	ldd	r0, Z+2	; 0x02
    226a:	f3 81       	ldd	r31, Z+3	; 0x03
    226c:	e0 2d       	mov	r30, r0
    226e:	12 96       	adiw	r26, 0x02	; 2
    2270:	fc 93       	st	X, r31
    2272:	ee 93       	st	-X, r30
    2274:	11 97       	sbiw	r26, 0x01	; 1
    2276:	cd 01       	movw	r24, r26
    2278:	03 96       	adiw	r24, 0x03	; 3
    227a:	e8 17       	cp	r30, r24
    227c:	f9 07       	cpc	r31, r25
    227e:	31 f4       	brne	.+12     	; 0x228c <vTaskSwitchContext+0x9e>
    2280:	82 81       	ldd	r24, Z+2	; 0x02
    2282:	93 81       	ldd	r25, Z+3	; 0x03
    2284:	12 96       	adiw	r26, 0x02	; 2
    2286:	9c 93       	st	X, r25
    2288:	8e 93       	st	-X, r24
    228a:	11 97       	sbiw	r26, 0x01	; 1
    228c:	11 96       	adiw	r26, 0x01	; 1
    228e:	ed 91       	ld	r30, X+
    2290:	fc 91       	ld	r31, X
    2292:	12 97       	sbiw	r26, 0x02	; 2
    2294:	86 81       	ldd	r24, Z+6	; 0x06
    2296:	97 81       	ldd	r25, Z+7	; 0x07
    2298:	90 93 ac 03 	sts	0x03AC, r25
    229c:	80 93 ab 03 	sts	0x03AB, r24
    22a0:	20 93 b4 03 	sts	0x03B4, r18
    22a4:	08 95       	ret

000022a6 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    22a6:	0f 93       	push	r16
    22a8:	1f 93       	push	r17
    22aa:	cf 93       	push	r28
    22ac:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    22ae:	0f b6       	in	r0, 0x3f	; 63
    22b0:	f8 94       	cli
    22b2:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    22b4:	00 97       	sbiw	r24, 0x00	; 0
    22b6:	29 f4       	brne	.+10     	; 0x22c2 <vTaskSuspend+0x1c>
    22b8:	00 91 ab 03 	lds	r16, 0x03AB
    22bc:	10 91 ac 03 	lds	r17, 0x03AC
    22c0:	01 c0       	rjmp	.+2      	; 0x22c4 <vTaskSuspend+0x1e>
    22c2:	8c 01       	movw	r16, r24

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    22c4:	e8 01       	movw	r28, r16
    22c6:	22 96       	adiw	r28, 0x02	; 2
    22c8:	ce 01       	movw	r24, r28
    22ca:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    22ce:	f8 01       	movw	r30, r16
    22d0:	84 89       	ldd	r24, Z+20	; 0x14
    22d2:	95 89       	ldd	r25, Z+21	; 0x15
    22d4:	00 97       	sbiw	r24, 0x00	; 0
    22d6:	21 f0       	breq	.+8      	; 0x22e0 <vTaskSuspend+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    22d8:	c8 01       	movw	r24, r16
    22da:	0c 96       	adiw	r24, 0x0c	; 12
    22dc:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    22e0:	8f e0       	ldi	r24, 0x0F	; 15
    22e2:	94 e0       	ldi	r25, 0x04	; 4
    22e4:	be 01       	movw	r22, r28
    22e6:	0e 94 69 05 	call	0xad2	; 0xad2 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    22ea:	0f 90       	pop	r0
    22ec:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    22ee:	80 91 b3 03 	lds	r24, 0x03B3
    22f2:	88 23       	and	r24, r24
    22f4:	39 f0       	breq	.+14     	; 0x2304 <vTaskSuspend+0x5e>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    22f6:	0f b6       	in	r0, 0x3f	; 63
    22f8:	f8 94       	cli
    22fa:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    22fc:	0e 94 15 0c 	call	0x182a	; 0x182a <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    2300:	0f 90       	pop	r0
    2302:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    2304:	80 91 ab 03 	lds	r24, 0x03AB
    2308:	90 91 ac 03 	lds	r25, 0x03AC
    230c:	08 17       	cp	r16, r24
    230e:	19 07       	cpc	r17, r25
    2310:	a1 f4       	brne	.+40     	; 0x233a <vTaskSuspend+0x94>
		{
			if( xSchedulerRunning != pdFALSE )
    2312:	80 91 b3 03 	lds	r24, 0x03B3
    2316:	88 23       	and	r24, r24
    2318:	19 f0       	breq	.+6      	; 0x2320 <vTaskSuspend+0x7a>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    231a:	0e 94 0d 07 	call	0xe1a	; 0xe1a <vPortYield>
    231e:	0d c0       	rjmp	.+26     	; 0x233a <vTaskSuspend+0x94>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    2320:	80 91 b7 03 	lds	r24, 0x03B7
    2324:	90 91 0f 04 	lds	r25, 0x040F
    2328:	98 17       	cp	r25, r24
    232a:	29 f4       	brne	.+10     	; 0x2336 <vTaskSuspend+0x90>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    232c:	10 92 ac 03 	sts	0x03AC, r1
    2330:	10 92 ab 03 	sts	0x03AB, r1
    2334:	02 c0       	rjmp	.+4      	; 0x233a <vTaskSuspend+0x94>
				}
				else
				{
					vTaskSwitchContext();
    2336:	0e 94 f7 10 	call	0x21ee	; 0x21ee <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    233a:	df 91       	pop	r29
    233c:	cf 91       	pop	r28
    233e:	1f 91       	pop	r17
    2340:	0f 91       	pop	r16
    2342:	08 95       	ret

00002344 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    2344:	cf 93       	push	r28
    2346:	df 93       	push	r29
    2348:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    234a:	60 91 ab 03 	lds	r22, 0x03AB
    234e:	70 91 ac 03 	lds	r23, 0x03AC
    2352:	64 5f       	subi	r22, 0xF4	; 244
    2354:	7f 4f       	sbci	r23, 0xFF	; 255
    2356:	0e 94 88 05 	call	0xb10	; 0xb10 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    235a:	ce 01       	movw	r24, r28
    235c:	61 e0       	ldi	r22, 0x01	; 1
    235e:	0e 94 34 0c 	call	0x1868	; 0x1868 <prvAddCurrentTaskToDelayedList>
}
    2362:	df 91       	pop	r29
    2364:	cf 91       	pop	r28
    2366:	08 95       	ret

00002368 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    2368:	cf 93       	push	r28
    236a:	df 93       	push	r29
    236c:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    236e:	e0 91 ab 03 	lds	r30, 0x03AB
    2372:	f0 91 ac 03 	lds	r31, 0x03AC
    2376:	70 68       	ori	r23, 0x80	; 128
    2378:	75 87       	std	Z+13, r23	; 0x0d
    237a:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    237c:	60 91 ab 03 	lds	r22, 0x03AB
    2380:	70 91 ac 03 	lds	r23, 0x03AC
    2384:	64 5f       	subi	r22, 0xF4	; 244
    2386:	7f 4f       	sbci	r23, 0xFF	; 255
    2388:	0e 94 69 05 	call	0xad2	; 0xad2 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    238c:	ce 01       	movw	r24, r28
    238e:	61 e0       	ldi	r22, 0x01	; 1
    2390:	0e 94 34 0c 	call	0x1868	; 0x1868 <prvAddCurrentTaskToDelayedList>
}
    2394:	df 91       	pop	r29
    2396:	cf 91       	pop	r28
    2398:	08 95       	ret

0000239a <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    239a:	0f 93       	push	r16
    239c:	1f 93       	push	r17
    239e:	cf 93       	push	r28
    23a0:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    23a2:	dc 01       	movw	r26, r24
    23a4:	15 96       	adiw	r26, 0x05	; 5
    23a6:	ed 91       	ld	r30, X+
    23a8:	fc 91       	ld	r31, X
    23aa:	16 97       	sbiw	r26, 0x06	; 6
    23ac:	06 81       	ldd	r16, Z+6	; 0x06
    23ae:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    23b0:	e8 01       	movw	r28, r16
    23b2:	2c 96       	adiw	r28, 0x0c	; 12
    23b4:	ce 01       	movw	r24, r28
    23b6:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    23ba:	80 91 ad 03 	lds	r24, 0x03AD
    23be:	88 23       	and	r24, r24
    23c0:	e9 f4       	brne	.+58     	; 0x23fc <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    23c2:	e8 01       	movw	r28, r16
    23c4:	22 96       	adiw	r28, 0x02	; 2
    23c6:	ce 01       	movw	r24, r28
    23c8:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    23cc:	f8 01       	movw	r30, r16
    23ce:	86 89       	ldd	r24, Z+22	; 0x16
    23d0:	90 91 b4 03 	lds	r25, 0x03B4
    23d4:	98 17       	cp	r25, r24
    23d6:	10 f4       	brcc	.+4      	; 0x23dc <xTaskRemoveFromEventList+0x42>
    23d8:	80 93 b4 03 	sts	0x03B4, r24
    23dc:	90 e0       	ldi	r25, 0x00	; 0
    23de:	9c 01       	movw	r18, r24
    23e0:	22 0f       	add	r18, r18
    23e2:	33 1f       	adc	r19, r19
    23e4:	22 0f       	add	r18, r18
    23e6:	33 1f       	adc	r19, r19
    23e8:	22 0f       	add	r18, r18
    23ea:	33 1f       	adc	r19, r19
    23ec:	82 0f       	add	r24, r18
    23ee:	93 1f       	adc	r25, r19
    23f0:	82 54       	subi	r24, 0x42	; 66
    23f2:	9c 4f       	sbci	r25, 0xFC	; 252
    23f4:	be 01       	movw	r22, r28
    23f6:	0e 94 69 05 	call	0xad2	; 0xad2 <vListInsertEnd>
    23fa:	05 c0       	rjmp	.+10     	; 0x2406 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    23fc:	8d ef       	ldi	r24, 0xFD	; 253
    23fe:	93 e0       	ldi	r25, 0x03	; 3
    2400:	be 01       	movw	r22, r28
    2402:	0e 94 69 05 	call	0xad2	; 0xad2 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2406:	e0 91 ab 03 	lds	r30, 0x03AB
    240a:	f0 91 ac 03 	lds	r31, 0x03AC
    240e:	d8 01       	movw	r26, r16
    2410:	56 96       	adiw	r26, 0x16	; 22
    2412:	9c 91       	ld	r25, X
    2414:	56 97       	sbiw	r26, 0x16	; 22
    2416:	86 89       	ldd	r24, Z+22	; 0x16
    2418:	89 17       	cp	r24, r25
    241a:	20 f4       	brcc	.+8      	; 0x2424 <xTaskRemoveFromEventList+0x8a>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    241c:	81 e0       	ldi	r24, 0x01	; 1
    241e:	80 93 b1 03 	sts	0x03B1, r24
    2422:	01 c0       	rjmp	.+2      	; 0x2426 <xTaskRemoveFromEventList+0x8c>
	}
	else
	{
		xReturn = pdFALSE;
    2424:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    2426:	df 91       	pop	r29
    2428:	cf 91       	pop	r28
    242a:	1f 91       	pop	r17
    242c:	0f 91       	pop	r16
    242e:	08 95       	ret

00002430 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    2430:	0f 93       	push	r16
    2432:	1f 93       	push	r17
    2434:	cf 93       	push	r28
    2436:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    2438:	70 68       	ori	r23, 0x80	; 128
    243a:	fc 01       	movw	r30, r24
    243c:	71 83       	std	Z+1, r23	; 0x01
    243e:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    2440:	c6 81       	ldd	r28, Z+6	; 0x06
    2442:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    2444:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    2448:	8e 01       	movw	r16, r28
    244a:	0e 5f       	subi	r16, 0xFE	; 254
    244c:	1f 4f       	sbci	r17, 0xFF	; 255
    244e:	c8 01       	movw	r24, r16
    2450:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    2454:	8e 89       	ldd	r24, Y+22	; 0x16
    2456:	90 91 b4 03 	lds	r25, 0x03B4
    245a:	98 17       	cp	r25, r24
    245c:	10 f4       	brcc	.+4      	; 0x2462 <xTaskRemoveFromUnorderedEventList+0x32>
    245e:	80 93 b4 03 	sts	0x03B4, r24
    2462:	90 e0       	ldi	r25, 0x00	; 0
    2464:	9c 01       	movw	r18, r24
    2466:	22 0f       	add	r18, r18
    2468:	33 1f       	adc	r19, r19
    246a:	22 0f       	add	r18, r18
    246c:	33 1f       	adc	r19, r19
    246e:	22 0f       	add	r18, r18
    2470:	33 1f       	adc	r19, r19
    2472:	82 0f       	add	r24, r18
    2474:	93 1f       	adc	r25, r19
    2476:	82 54       	subi	r24, 0x42	; 66
    2478:	9c 4f       	sbci	r25, 0xFC	; 252
    247a:	b8 01       	movw	r22, r16
    247c:	0e 94 69 05 	call	0xad2	; 0xad2 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2480:	e0 91 ab 03 	lds	r30, 0x03AB
    2484:	f0 91 ac 03 	lds	r31, 0x03AC
    2488:	9e 89       	ldd	r25, Y+22	; 0x16
    248a:	86 89       	ldd	r24, Z+22	; 0x16
    248c:	89 17       	cp	r24, r25
    248e:	20 f4       	brcc	.+8      	; 0x2498 <xTaskRemoveFromUnorderedEventList+0x68>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    2490:	81 e0       	ldi	r24, 0x01	; 1
    2492:	80 93 b1 03 	sts	0x03B1, r24
    2496:	01 c0       	rjmp	.+2      	; 0x249a <xTaskRemoveFromUnorderedEventList+0x6a>
	}
	else
	{
		xReturn = pdFALSE;
    2498:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    249a:	df 91       	pop	r29
    249c:	cf 91       	pop	r28
    249e:	1f 91       	pop	r17
    24a0:	0f 91       	pop	r16
    24a2:	08 95       	ret

000024a4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    24a4:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    24a6:	80 91 b0 03 	lds	r24, 0x03B0
    24aa:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    24ac:	80 91 b5 03 	lds	r24, 0x03B5
    24b0:	90 91 b6 03 	lds	r25, 0x03B6
    24b4:	92 83       	std	Z+2, r25	; 0x02
    24b6:	81 83       	std	Z+1, r24	; 0x01
}
    24b8:	08 95       	ret

000024ba <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    24ba:	fc 01       	movw	r30, r24
    24bc:	db 01       	movw	r26, r22
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    24be:	0f b6       	in	r0, 0x3f	; 63
    24c0:	f8 94       	cli
    24c2:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    24c4:	60 91 b5 03 	lds	r22, 0x03B5
    24c8:	70 91 b6 03 	lds	r23, 0x03B6
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    24cc:	4d 91       	ld	r20, X+
    24ce:	5c 91       	ld	r21, X
    24d0:	11 97       	sbiw	r26, 0x01	; 1
    24d2:	8f ef       	ldi	r24, 0xFF	; 255
    24d4:	4f 3f       	cpi	r20, 0xFF	; 255
    24d6:	58 07       	cpc	r21, r24
    24d8:	e9 f0       	breq	.+58     	; 0x2514 <xTaskCheckForTimeOut+0x5a>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    24da:	80 91 b0 03 	lds	r24, 0x03B0
    24de:	90 81       	ld	r25, Z
    24e0:	98 17       	cp	r25, r24
    24e2:	29 f0       	breq	.+10     	; 0x24ee <xTaskCheckForTimeOut+0x34>
    24e4:	81 81       	ldd	r24, Z+1	; 0x01
    24e6:	92 81       	ldd	r25, Z+2	; 0x02
    24e8:	68 17       	cp	r22, r24
    24ea:	79 07       	cpc	r23, r25
    24ec:	a8 f4       	brcc	.+42     	; 0x2518 <xTaskCheckForTimeOut+0x5e>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    24ee:	81 81       	ldd	r24, Z+1	; 0x01
    24f0:	92 81       	ldd	r25, Z+2	; 0x02
    24f2:	9b 01       	movw	r18, r22
    24f4:	28 1b       	sub	r18, r24
    24f6:	39 0b       	sbc	r19, r25
    24f8:	24 17       	cp	r18, r20
    24fa:	35 07       	cpc	r19, r21
    24fc:	78 f4       	brcc	.+30     	; 0x251c <xTaskCheckForTimeOut+0x62>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    24fe:	86 1b       	sub	r24, r22
    2500:	97 0b       	sbc	r25, r23
    2502:	84 0f       	add	r24, r20
    2504:	95 1f       	adc	r25, r21
    2506:	8d 93       	st	X+, r24
    2508:	9c 93       	st	X, r25
			vTaskSetTimeOutState( pxTimeOut );
    250a:	cf 01       	movw	r24, r30
    250c:	0e 94 52 12 	call	0x24a4	; 0x24a4 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2510:	80 e0       	ldi	r24, 0x00	; 0
    2512:	05 c0       	rjmp	.+10     	; 0x251e <xTaskCheckForTimeOut+0x64>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    2514:	80 e0       	ldi	r24, 0x00	; 0
    2516:	03 c0       	rjmp	.+6      	; 0x251e <xTaskCheckForTimeOut+0x64>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    2518:	81 e0       	ldi	r24, 0x01	; 1
    251a:	01 c0       	rjmp	.+2      	; 0x251e <xTaskCheckForTimeOut+0x64>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    251c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    251e:	0f 90       	pop	r0
    2520:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2522:	08 95       	ret

00002524 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    2524:	81 e0       	ldi	r24, 0x01	; 1
    2526:	80 93 b1 03 	sts	0x03B1, r24
}
    252a:	08 95       	ret

0000252c <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    252c:	80 91 ab 03 	lds	r24, 0x03AB
    2530:	90 91 ac 03 	lds	r25, 0x03AC

		return xReturn;
	}
    2534:	08 95       	ret

00002536 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    2536:	0f 93       	push	r16
    2538:	1f 93       	push	r17
    253a:	cf 93       	push	r28
    253c:	df 93       	push	r29
    253e:	ec 01       	movw	r28, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    2540:	00 97       	sbiw	r24, 0x00	; 0
    2542:	09 f4       	brne	.+2      	; 0x2546 <vTaskPriorityInherit+0x10>
    2544:	51 c0       	rjmp	.+162    	; 0x25e8 <vTaskPriorityInherit+0xb2>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2546:	8e 89       	ldd	r24, Y+22	; 0x16
    2548:	e0 91 ab 03 	lds	r30, 0x03AB
    254c:	f0 91 ac 03 	lds	r31, 0x03AC
    2550:	96 89       	ldd	r25, Z+22	; 0x16
    2552:	89 17       	cp	r24, r25
    2554:	08 f0       	brcs	.+2      	; 0x2558 <vTaskPriorityInherit+0x22>
    2556:	48 c0       	rjmp	.+144    	; 0x25e8 <vTaskPriorityInherit+0xb2>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    2558:	2c 85       	ldd	r18, Y+12	; 0x0c
    255a:	3d 85       	ldd	r19, Y+13	; 0x0d
    255c:	33 23       	and	r19, r19
    255e:	5c f0       	brlt	.+22     	; 0x2576 <vTaskPriorityInherit+0x40>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2560:	e0 91 ab 03 	lds	r30, 0x03AB
    2564:	f0 91 ac 03 	lds	r31, 0x03AC
    2568:	96 89       	ldd	r25, Z+22	; 0x16
    256a:	25 e0       	ldi	r18, 0x05	; 5
    256c:	30 e0       	ldi	r19, 0x00	; 0
    256e:	29 1b       	sub	r18, r25
    2570:	31 09       	sbc	r19, r1
    2572:	3d 87       	std	Y+13, r19	; 0x0d
    2574:	2c 87       	std	Y+12, r18	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    2576:	90 e0       	ldi	r25, 0x00	; 0
    2578:	9c 01       	movw	r18, r24
    257a:	22 0f       	add	r18, r18
    257c:	33 1f       	adc	r19, r19
    257e:	22 0f       	add	r18, r18
    2580:	33 1f       	adc	r19, r19
    2582:	22 0f       	add	r18, r18
    2584:	33 1f       	adc	r19, r19
    2586:	82 0f       	add	r24, r18
    2588:	93 1f       	adc	r25, r19
    258a:	82 54       	subi	r24, 0x42	; 66
    258c:	9c 4f       	sbci	r25, 0xFC	; 252
    258e:	2a 85       	ldd	r18, Y+10	; 0x0a
    2590:	3b 85       	ldd	r19, Y+11	; 0x0b
    2592:	28 17       	cp	r18, r24
    2594:	39 07       	cpc	r19, r25
    2596:	11 f5       	brne	.+68     	; 0x25dc <vTaskPriorityInherit+0xa6>
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2598:	8e 01       	movw	r16, r28
    259a:	0e 5f       	subi	r16, 0xFE	; 254
    259c:	1f 4f       	sbci	r17, 0xFF	; 255
    259e:	c8 01       	movw	r24, r16
    25a0:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    25a4:	e0 91 ab 03 	lds	r30, 0x03AB
    25a8:	f0 91 ac 03 	lds	r31, 0x03AC
    25ac:	86 89       	ldd	r24, Z+22	; 0x16
    25ae:	8e 8b       	std	Y+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    25b0:	90 91 b4 03 	lds	r25, 0x03B4
    25b4:	98 17       	cp	r25, r24
    25b6:	10 f4       	brcc	.+4      	; 0x25bc <vTaskPriorityInherit+0x86>
    25b8:	80 93 b4 03 	sts	0x03B4, r24
    25bc:	90 e0       	ldi	r25, 0x00	; 0
    25be:	9c 01       	movw	r18, r24
    25c0:	22 0f       	add	r18, r18
    25c2:	33 1f       	adc	r19, r19
    25c4:	22 0f       	add	r18, r18
    25c6:	33 1f       	adc	r19, r19
    25c8:	22 0f       	add	r18, r18
    25ca:	33 1f       	adc	r19, r19
    25cc:	82 0f       	add	r24, r18
    25ce:	93 1f       	adc	r25, r19
    25d0:	82 54       	subi	r24, 0x42	; 66
    25d2:	9c 4f       	sbci	r25, 0xFC	; 252
    25d4:	b8 01       	movw	r22, r16
    25d6:	0e 94 69 05 	call	0xad2	; 0xad2 <vListInsertEnd>
    25da:	06 c0       	rjmp	.+12     	; 0x25e8 <vTaskPriorityInherit+0xb2>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    25dc:	e0 91 ab 03 	lds	r30, 0x03AB
    25e0:	f0 91 ac 03 	lds	r31, 0x03AC
    25e4:	86 89       	ldd	r24, Z+22	; 0x16
    25e6:	8e 8b       	std	Y+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    25e8:	df 91       	pop	r29
    25ea:	cf 91       	pop	r28
    25ec:	1f 91       	pop	r17
    25ee:	0f 91       	pop	r16
    25f0:	08 95       	ret

000025f2 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    25f2:	0f 93       	push	r16
    25f4:	1f 93       	push	r17
    25f6:	cf 93       	push	r28
    25f8:	df 93       	push	r29
    25fa:	ec 01       	movw	r28, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    25fc:	00 97       	sbiw	r24, 0x00	; 0
    25fe:	81 f1       	breq	.+96     	; 0x2660 <xTaskPriorityDisinherit+0x6e>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    2600:	8c a1       	lds	r24, 0x4c
    2602:	81 50       	subi	r24, 0x01	; 1
    2604:	8c a3       	lds	r24, 0x5c

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2606:	2e 89       	ldd	r18, Y+22	; 0x16
    2608:	9b a1       	lds	r25, 0x4b
    260a:	29 17       	cp	r18, r25
    260c:	59 f1       	breq	.+86     	; 0x2664 <xTaskPriorityDisinherit+0x72>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    260e:	88 23       	and	r24, r24
    2610:	59 f5       	brne	.+86     	; 0x2668 <xTaskPriorityDisinherit+0x76>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2612:	8e 01       	movw	r16, r28
    2614:	0e 5f       	subi	r16, 0xFE	; 254
    2616:	1f 4f       	sbci	r17, 0xFF	; 255
    2618:	c8 01       	movw	r24, r16
    261a:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    261e:	4b a1       	lds	r20, 0x4b
    2620:	4e 8b       	std	Y+22, r20	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2622:	24 2f       	mov	r18, r20
    2624:	30 e0       	ldi	r19, 0x00	; 0
    2626:	85 e0       	ldi	r24, 0x05	; 5
    2628:	90 e0       	ldi	r25, 0x00	; 0
    262a:	82 1b       	sub	r24, r18
    262c:	93 0b       	sbc	r25, r19
    262e:	9d 87       	std	Y+13, r25	; 0x0d
    2630:	8c 87       	std	Y+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    2632:	80 91 b4 03 	lds	r24, 0x03B4
    2636:	84 17       	cp	r24, r20
    2638:	10 f4       	brcc	.+4      	; 0x263e <xTaskPriorityDisinherit+0x4c>
    263a:	40 93 b4 03 	sts	0x03B4, r20
    263e:	c9 01       	movw	r24, r18
    2640:	88 0f       	add	r24, r24
    2642:	99 1f       	adc	r25, r25
    2644:	88 0f       	add	r24, r24
    2646:	99 1f       	adc	r25, r25
    2648:	88 0f       	add	r24, r24
    264a:	99 1f       	adc	r25, r25
    264c:	28 0f       	add	r18, r24
    264e:	39 1f       	adc	r19, r25
    2650:	c9 01       	movw	r24, r18
    2652:	82 54       	subi	r24, 0x42	; 66
    2654:	9c 4f       	sbci	r25, 0xFC	; 252
    2656:	b8 01       	movw	r22, r16
    2658:	0e 94 69 05 	call	0xad2	; 0xad2 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    265c:	81 e0       	ldi	r24, 0x01	; 1
    265e:	05 c0       	rjmp	.+10     	; 0x266a <xTaskPriorityDisinherit+0x78>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    2660:	80 e0       	ldi	r24, 0x00	; 0
    2662:	03 c0       	rjmp	.+6      	; 0x266a <xTaskPriorityDisinherit+0x78>
    2664:	80 e0       	ldi	r24, 0x00	; 0
    2666:	01 c0       	rjmp	.+2      	; 0x266a <xTaskPriorityDisinherit+0x78>
    2668:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    266a:	df 91       	pop	r29
    266c:	cf 91       	pop	r28
    266e:	1f 91       	pop	r17
    2670:	0f 91       	pop	r16
    2672:	08 95       	ret

00002674 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    2674:	e0 91 ab 03 	lds	r30, 0x03AB
    2678:	f0 91 ac 03 	lds	r31, 0x03AC
    267c:	84 85       	ldd	r24, Z+12	; 0x0c
    267e:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2680:	e0 91 ab 03 	lds	r30, 0x03AB
    2684:	f0 91 ac 03 	lds	r31, 0x03AC
    2688:	a0 91 ab 03 	lds	r26, 0x03AB
    268c:	b0 91 ac 03 	lds	r27, 0x03AC
    2690:	56 96       	adiw	r26, 0x16	; 22
    2692:	4c 91       	ld	r20, X
    2694:	56 97       	sbiw	r26, 0x16	; 22
    2696:	25 e0       	ldi	r18, 0x05	; 5
    2698:	30 e0       	ldi	r19, 0x00	; 0
    269a:	24 1b       	sub	r18, r20
    269c:	31 09       	sbc	r19, r1
    269e:	35 87       	std	Z+13, r19	; 0x0d
    26a0:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    26a2:	08 95       	ret

000026a4 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    26a4:	80 91 ab 03 	lds	r24, 0x03AB
    26a8:	90 91 ac 03 	lds	r25, 0x03AC
    26ac:	00 97       	sbiw	r24, 0x00	; 0
    26ae:	39 f0       	breq	.+14     	; 0x26be <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    26b0:	e0 91 ab 03 	lds	r30, 0x03AB
    26b4:	f0 91 ac 03 	lds	r31, 0x03AC
    26b8:	84 a1       	lds	r24, 0x44
    26ba:	8f 5f       	subi	r24, 0xFF	; 255
    26bc:	84 a3       	lds	r24, 0x54
		}

		return pxCurrentTCB;
    26be:	80 91 ab 03 	lds	r24, 0x03AB
    26c2:	90 91 ac 03 	lds	r25, 0x03AC
	}
    26c6:	08 95       	ret

000026c8 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    26c8:	0f 93       	push	r16
    26ca:	1f 93       	push	r17
    26cc:	cf 93       	push	r28
    26ce:	c8 2f       	mov	r28, r24
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    26d0:	0f b6       	in	r0, 0x3f	; 63
    26d2:	f8 94       	cli
    26d4:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    26d6:	e0 91 ab 03 	lds	r30, 0x03AB
    26da:	f0 91 ac 03 	lds	r31, 0x03AC
    26de:	85 a1       	lds	r24, 0x45
    26e0:	96 a1       	lds	r25, 0x46
    26e2:	a7 a1       	lds	r26, 0x47
    26e4:	b0 a5       	lds	r27, 0x60
    26e6:	00 97       	sbiw	r24, 0x00	; 0
    26e8:	a1 05       	cpc	r26, r1
    26ea:	b1 05       	cpc	r27, r1
    26ec:	79 f4       	brne	.+30     	; 0x270c <ulTaskNotifyTake+0x44>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    26ee:	e0 91 ab 03 	lds	r30, 0x03AB
    26f2:	f0 91 ac 03 	lds	r31, 0x03AC
    26f6:	81 e0       	ldi	r24, 0x01	; 1
    26f8:	81 a7       	lds	r24, 0x71

				if( xTicksToWait > ( TickType_t ) 0 )
    26fa:	61 15       	cp	r22, r1
    26fc:	71 05       	cpc	r23, r1
    26fe:	31 f0       	breq	.+12     	; 0x270c <ulTaskNotifyTake+0x44>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2700:	cb 01       	movw	r24, r22
    2702:	61 e0       	ldi	r22, 0x01	; 1
    2704:	0e 94 34 0c 	call	0x1868	; 0x1868 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    2708:	0e 94 0d 07 	call	0xe1a	; 0xe1a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    270c:	0f 90       	pop	r0
    270e:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    2710:	0f b6       	in	r0, 0x3f	; 63
    2712:	f8 94       	cli
    2714:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    2716:	e0 91 ab 03 	lds	r30, 0x03AB
    271a:	f0 91 ac 03 	lds	r31, 0x03AC
    271e:	05 a1       	lds	r16, 0x45
    2720:	16 a1       	lds	r17, 0x46
    2722:	27 a1       	lds	r18, 0x47
    2724:	30 a5       	lds	r19, 0x60

			if( ulReturn != 0UL )
    2726:	01 15       	cp	r16, r1
    2728:	11 05       	cpc	r17, r1
    272a:	21 05       	cpc	r18, r1
    272c:	31 05       	cpc	r19, r1
    272e:	c1 f0       	breq	.+48     	; 0x2760 <ulTaskNotifyTake+0x98>
			{
				if( xClearCountOnExit != pdFALSE )
    2730:	cc 23       	and	r28, r28
    2732:	49 f0       	breq	.+18     	; 0x2746 <ulTaskNotifyTake+0x7e>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    2734:	e0 91 ab 03 	lds	r30, 0x03AB
    2738:	f0 91 ac 03 	lds	r31, 0x03AC
    273c:	15 a2       	lds	r17, 0x95
    273e:	16 a2       	lds	r17, 0x96
    2740:	17 a2       	lds	r17, 0x97
    2742:	10 a6       	lds	r17, 0xb0
    2744:	0d c0       	rjmp	.+26     	; 0x2760 <ulTaskNotifyTake+0x98>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    2746:	e0 91 ab 03 	lds	r30, 0x03AB
    274a:	f0 91 ac 03 	lds	r31, 0x03AC
    274e:	d9 01       	movw	r26, r18
    2750:	c8 01       	movw	r24, r16
    2752:	01 97       	sbiw	r24, 0x01	; 1
    2754:	a1 09       	sbc	r26, r1
    2756:	b1 09       	sbc	r27, r1
    2758:	85 a3       	lds	r24, 0x55
    275a:	96 a3       	lds	r25, 0x56
    275c:	a7 a3       	lds	r26, 0x57
    275e:	b0 a7       	lds	r27, 0x70
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2760:	e0 91 ab 03 	lds	r30, 0x03AB
    2764:	f0 91 ac 03 	lds	r31, 0x03AC
    2768:	11 a6       	lds	r17, 0xb1
		}
		taskEXIT_CRITICAL();
    276a:	0f 90       	pop	r0
    276c:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    276e:	60 2f       	mov	r22, r16
    2770:	71 2f       	mov	r23, r17
    2772:	82 2f       	mov	r24, r18
    2774:	93 2f       	mov	r25, r19
    2776:	cf 91       	pop	r28
    2778:	1f 91       	pop	r17
    277a:	0f 91       	pop	r16
    277c:	08 95       	ret

0000277e <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    277e:	8f 92       	push	r8
    2780:	9f 92       	push	r9
    2782:	af 92       	push	r10
    2784:	bf 92       	push	r11
    2786:	ef 92       	push	r14
    2788:	ff 92       	push	r15
    278a:	0f 93       	push	r16
    278c:	1f 93       	push	r17
    278e:	dc 01       	movw	r26, r24
    2790:	cb 01       	movw	r24, r22
    2792:	49 01       	movw	r8, r18
    2794:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    2796:	0f b6       	in	r0, 0x3f	; 63
    2798:	f8 94       	cli
    279a:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    279c:	e0 91 ab 03 	lds	r30, 0x03AB
    27a0:	f0 91 ac 03 	lds	r31, 0x03AC
    27a4:	21 a5       	lds	r18, 0x61
    27a6:	22 30       	cpi	r18, 0x02	; 2
    27a8:	19 f1       	breq	.+70     	; 0x27f0 <xTaskNotifyWait+0x72>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    27aa:	e0 91 ab 03 	lds	r30, 0x03AB
    27ae:	f0 91 ac 03 	lds	r31, 0x03AC
    27b2:	45 a1       	lds	r20, 0x45
    27b4:	56 a1       	lds	r21, 0x46
    27b6:	67 a1       	lds	r22, 0x47
    27b8:	70 a5       	lds	r23, 0x60
    27ba:	80 95       	com	r24
    27bc:	90 95       	com	r25
    27be:	a0 95       	com	r26
    27c0:	b0 95       	com	r27
    27c2:	84 23       	and	r24, r20
    27c4:	95 23       	and	r25, r21
    27c6:	a6 23       	and	r26, r22
    27c8:	b7 23       	and	r27, r23
    27ca:	85 a3       	lds	r24, 0x55
    27cc:	96 a3       	lds	r25, 0x56
    27ce:	a7 a3       	lds	r26, 0x57
    27d0:	b0 a7       	lds	r27, 0x70

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    27d2:	e0 91 ab 03 	lds	r30, 0x03AB
    27d6:	f0 91 ac 03 	lds	r31, 0x03AC
    27da:	81 e0       	ldi	r24, 0x01	; 1
    27dc:	81 a7       	lds	r24, 0x71

				if( xTicksToWait > ( TickType_t ) 0 )
    27de:	e1 14       	cp	r14, r1
    27e0:	f1 04       	cpc	r15, r1
    27e2:	31 f0       	breq	.+12     	; 0x27f0 <xTaskNotifyWait+0x72>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    27e4:	c7 01       	movw	r24, r14
    27e6:	61 e0       	ldi	r22, 0x01	; 1
    27e8:	0e 94 34 0c 	call	0x1868	; 0x1868 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    27ec:	0e 94 0d 07 	call	0xe1a	; 0xe1a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    27f0:	0f 90       	pop	r0
    27f2:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    27f4:	0f b6       	in	r0, 0x3f	; 63
    27f6:	f8 94       	cli
    27f8:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    27fa:	01 15       	cp	r16, r1
    27fc:	11 05       	cpc	r17, r1
    27fe:	69 f0       	breq	.+26     	; 0x281a <xTaskNotifyWait+0x9c>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    2800:	e0 91 ab 03 	lds	r30, 0x03AB
    2804:	f0 91 ac 03 	lds	r31, 0x03AC
    2808:	85 a1       	lds	r24, 0x45
    280a:	96 a1       	lds	r25, 0x46
    280c:	a7 a1       	lds	r26, 0x47
    280e:	b0 a5       	lds	r27, 0x60
    2810:	f8 01       	movw	r30, r16
    2812:	80 83       	st	Z, r24
    2814:	91 83       	std	Z+1, r25	; 0x01
    2816:	a2 83       	std	Z+2, r26	; 0x02
    2818:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    281a:	e0 91 ab 03 	lds	r30, 0x03AB
    281e:	f0 91 ac 03 	lds	r31, 0x03AC
    2822:	81 a5       	lds	r24, 0x61
    2824:	81 30       	cpi	r24, 0x01	; 1
    2826:	b1 f0       	breq	.+44     	; 0x2854 <xTaskNotifyWait+0xd6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    2828:	e0 91 ab 03 	lds	r30, 0x03AB
    282c:	f0 91 ac 03 	lds	r31, 0x03AC
    2830:	85 a1       	lds	r24, 0x45
    2832:	96 a1       	lds	r25, 0x46
    2834:	a7 a1       	lds	r26, 0x47
    2836:	b0 a5       	lds	r27, 0x60
    2838:	80 94       	com	r8
    283a:	90 94       	com	r9
    283c:	a0 94       	com	r10
    283e:	b0 94       	com	r11
    2840:	88 22       	and	r8, r24
    2842:	99 22       	and	r9, r25
    2844:	aa 22       	and	r10, r26
    2846:	bb 22       	and	r11, r27
    2848:	85 a2       	lds	r24, 0x95
    284a:	96 a2       	lds	r25, 0x96
    284c:	a7 a2       	lds	r26, 0x97
    284e:	b0 a6       	lds	r27, 0xb0
				xReturn = pdTRUE;
    2850:	81 e0       	ldi	r24, 0x01	; 1
    2852:	01 c0       	rjmp	.+2      	; 0x2856 <xTaskNotifyWait+0xd8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    2854:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2856:	e0 91 ab 03 	lds	r30, 0x03AB
    285a:	f0 91 ac 03 	lds	r31, 0x03AC
    285e:	11 a6       	lds	r17, 0xb1
		}
		taskEXIT_CRITICAL();
    2860:	0f 90       	pop	r0
    2862:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2864:	1f 91       	pop	r17
    2866:	0f 91       	pop	r16
    2868:	ff 90       	pop	r15
    286a:	ef 90       	pop	r14
    286c:	bf 90       	pop	r11
    286e:	af 90       	pop	r10
    2870:	9f 90       	pop	r9
    2872:	8f 90       	pop	r8
    2874:	08 95       	ret

00002876 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    2876:	0f 93       	push	r16
    2878:	1f 93       	push	r17
    287a:	cf 93       	push	r28
    287c:	df 93       	push	r29
    287e:	ec 01       	movw	r28, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
    2880:	0f b6       	in	r0, 0x3f	; 63
    2882:	f8 94       	cli
    2884:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    2886:	01 15       	cp	r16, r1
    2888:	11 05       	cpc	r17, r1
    288a:	49 f0       	breq	.+18     	; 0x289e <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    288c:	8d a1       	lds	r24, 0x4d
    288e:	9e a1       	lds	r25, 0x4e
    2890:	af a1       	lds	r26, 0x4f
    2892:	b8 a5       	lds	r27, 0x68
    2894:	f8 01       	movw	r30, r16
    2896:	80 83       	st	Z, r24
    2898:	91 83       	std	Z+1, r25	; 0x01
    289a:	a2 83       	std	Z+2, r26	; 0x02
    289c:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    289e:	39 a5       	lds	r19, 0x69

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    28a0:	82 e0       	ldi	r24, 0x02	; 2
    28a2:	89 a7       	lds	r24, 0x79

			switch( eAction )
    28a4:	22 30       	cpi	r18, 0x02	; 2
    28a6:	b9 f0       	breq	.+46     	; 0x28d6 <xTaskGenericNotify+0x60>
    28a8:	23 30       	cpi	r18, 0x03	; 3
    28aa:	18 f4       	brcc	.+6      	; 0x28b2 <xTaskGenericNotify+0x3c>
    28ac:	21 30       	cpi	r18, 0x01	; 1
    28ae:	51 f5       	brne	.+84     	; 0x2904 <xTaskGenericNotify+0x8e>
    28b0:	05 c0       	rjmp	.+10     	; 0x28bc <xTaskGenericNotify+0x46>
    28b2:	23 30       	cpi	r18, 0x03	; 3
    28b4:	e1 f0       	breq	.+56     	; 0x28ee <xTaskGenericNotify+0x78>
    28b6:	24 30       	cpi	r18, 0x04	; 4
    28b8:	29 f5       	brne	.+74     	; 0x2904 <xTaskGenericNotify+0x8e>
    28ba:	1e c0       	rjmp	.+60     	; 0x28f8 <xTaskGenericNotify+0x82>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    28bc:	8d a1       	lds	r24, 0x4d
    28be:	9e a1       	lds	r25, 0x4e
    28c0:	af a1       	lds	r26, 0x4f
    28c2:	b8 a5       	lds	r27, 0x68
    28c4:	48 2b       	or	r20, r24
    28c6:	59 2b       	or	r21, r25
    28c8:	6a 2b       	or	r22, r26
    28ca:	7b 2b       	or	r23, r27
    28cc:	4d a3       	lds	r20, 0x5d
    28ce:	5e a3       	lds	r21, 0x5e
    28d0:	6f a3       	lds	r22, 0x5f
    28d2:	78 a7       	lds	r23, 0x78
					break;
    28d4:	17 c0       	rjmp	.+46     	; 0x2904 <xTaskGenericNotify+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    28d6:	8d a1       	lds	r24, 0x4d
    28d8:	9e a1       	lds	r25, 0x4e
    28da:	af a1       	lds	r26, 0x4f
    28dc:	b8 a5       	lds	r27, 0x68
    28de:	01 96       	adiw	r24, 0x01	; 1
    28e0:	a1 1d       	adc	r26, r1
    28e2:	b1 1d       	adc	r27, r1
    28e4:	8d a3       	lds	r24, 0x5d
    28e6:	9e a3       	lds	r25, 0x5e
    28e8:	af a3       	lds	r26, 0x5f
    28ea:	b8 a7       	lds	r27, 0x78
					break;
    28ec:	0b c0       	rjmp	.+22     	; 0x2904 <xTaskGenericNotify+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    28ee:	4d a3       	lds	r20, 0x5d
    28f0:	5e a3       	lds	r21, 0x5e
    28f2:	6f a3       	lds	r22, 0x5f
    28f4:	78 a7       	lds	r23, 0x78
					break;
    28f6:	06 c0       	rjmp	.+12     	; 0x2904 <xTaskGenericNotify+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    28f8:	32 30       	cpi	r19, 0x02	; 2
    28fa:	41 f1       	breq	.+80     	; 0x294c <xTaskGenericNotify+0xd6>
					{
						pxTCB->ulNotifiedValue = ulValue;
    28fc:	4d a3       	lds	r20, 0x5d
    28fe:	5e a3       	lds	r21, 0x5e
    2900:	6f a3       	lds	r22, 0x5f
    2902:	78 a7       	lds	r23, 0x78

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2904:	31 30       	cpi	r19, 0x01	; 1
    2906:	21 f5       	brne	.+72     	; 0x2950 <xTaskGenericNotify+0xda>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2908:	8e 01       	movw	r16, r28
    290a:	0e 5f       	subi	r16, 0xFE	; 254
    290c:	1f 4f       	sbci	r17, 0xFF	; 255
    290e:	c8 01       	movw	r24, r16
    2910:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    2914:	8e 89       	ldd	r24, Y+22	; 0x16
    2916:	90 91 b4 03 	lds	r25, 0x03B4
    291a:	98 17       	cp	r25, r24
    291c:	10 f4       	brcc	.+4      	; 0x2922 <xTaskGenericNotify+0xac>
    291e:	80 93 b4 03 	sts	0x03B4, r24
    2922:	90 e0       	ldi	r25, 0x00	; 0
    2924:	9c 01       	movw	r18, r24
    2926:	22 0f       	add	r18, r18
    2928:	33 1f       	adc	r19, r19
    292a:	22 0f       	add	r18, r18
    292c:	33 1f       	adc	r19, r19
    292e:	22 0f       	add	r18, r18
    2930:	33 1f       	adc	r19, r19
    2932:	82 0f       	add	r24, r18
    2934:	93 1f       	adc	r25, r19
    2936:	82 54       	subi	r24, 0x42	; 66
    2938:	9c 4f       	sbci	r25, 0xFC	; 252
    293a:	b8 01       	movw	r22, r16
    293c:	0e 94 69 05 	call	0xad2	; 0xad2 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2940:	80 91 ab 03 	lds	r24, 0x03AB
    2944:	90 91 ac 03 	lds	r25, 0x03AC
    2948:	81 e0       	ldi	r24, 0x01	; 1
    294a:	03 c0       	rjmp	.+6      	; 0x2952 <xTaskGenericNotify+0xdc>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    294c:	80 e0       	ldi	r24, 0x00	; 0
    294e:	01 c0       	rjmp	.+2      	; 0x2952 <xTaskGenericNotify+0xdc>

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2950:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2952:	0f 90       	pop	r0
    2954:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2956:	df 91       	pop	r29
    2958:	cf 91       	pop	r28
    295a:	1f 91       	pop	r17
    295c:	0f 91       	pop	r16
    295e:	08 95       	ret

00002960 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    2960:	ef 92       	push	r14
    2962:	ff 92       	push	r15
    2964:	0f 93       	push	r16
    2966:	1f 93       	push	r17
    2968:	cf 93       	push	r28
    296a:	df 93       	push	r29
    296c:	ec 01       	movw	r28, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    296e:	01 15       	cp	r16, r1
    2970:	11 05       	cpc	r17, r1
    2972:	49 f0       	breq	.+18     	; 0x2986 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    2974:	8d a1       	lds	r24, 0x4d
    2976:	9e a1       	lds	r25, 0x4e
    2978:	af a1       	lds	r26, 0x4f
    297a:	b8 a5       	lds	r27, 0x68
    297c:	f8 01       	movw	r30, r16
    297e:	80 83       	st	Z, r24
    2980:	91 83       	std	Z+1, r25	; 0x01
    2982:	a2 83       	std	Z+2, r26	; 0x02
    2984:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    2986:	39 a5       	lds	r19, 0x69
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    2988:	82 e0       	ldi	r24, 0x02	; 2
    298a:	89 a7       	lds	r24, 0x79

			switch( eAction )
    298c:	22 30       	cpi	r18, 0x02	; 2
    298e:	b9 f0       	breq	.+46     	; 0x29be <xTaskGenericNotifyFromISR+0x5e>
    2990:	23 30       	cpi	r18, 0x03	; 3
    2992:	18 f4       	brcc	.+6      	; 0x299a <xTaskGenericNotifyFromISR+0x3a>
    2994:	21 30       	cpi	r18, 0x01	; 1
    2996:	59 f5       	brne	.+86     	; 0x29ee <xTaskGenericNotifyFromISR+0x8e>
    2998:	05 c0       	rjmp	.+10     	; 0x29a4 <xTaskGenericNotifyFromISR+0x44>
    299a:	23 30       	cpi	r18, 0x03	; 3
    299c:	e1 f0       	breq	.+56     	; 0x29d6 <xTaskGenericNotifyFromISR+0x76>
    299e:	24 30       	cpi	r18, 0x04	; 4
    29a0:	31 f5       	brne	.+76     	; 0x29ee <xTaskGenericNotifyFromISR+0x8e>
    29a2:	1e c0       	rjmp	.+60     	; 0x29e0 <xTaskGenericNotifyFromISR+0x80>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    29a4:	8d a1       	lds	r24, 0x4d
    29a6:	9e a1       	lds	r25, 0x4e
    29a8:	af a1       	lds	r26, 0x4f
    29aa:	b8 a5       	lds	r27, 0x68
    29ac:	84 2b       	or	r24, r20
    29ae:	95 2b       	or	r25, r21
    29b0:	a6 2b       	or	r26, r22
    29b2:	b7 2b       	or	r27, r23
    29b4:	8d a3       	lds	r24, 0x5d
    29b6:	9e a3       	lds	r25, 0x5e
    29b8:	af a3       	lds	r26, 0x5f
    29ba:	b8 a7       	lds	r27, 0x78
					break;
    29bc:	18 c0       	rjmp	.+48     	; 0x29ee <xTaskGenericNotifyFromISR+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    29be:	8d a1       	lds	r24, 0x4d
    29c0:	9e a1       	lds	r25, 0x4e
    29c2:	af a1       	lds	r26, 0x4f
    29c4:	b8 a5       	lds	r27, 0x68
    29c6:	01 96       	adiw	r24, 0x01	; 1
    29c8:	a1 1d       	adc	r26, r1
    29ca:	b1 1d       	adc	r27, r1
    29cc:	8d a3       	lds	r24, 0x5d
    29ce:	9e a3       	lds	r25, 0x5e
    29d0:	af a3       	lds	r26, 0x5f
    29d2:	b8 a7       	lds	r27, 0x78
					break;
    29d4:	0c c0       	rjmp	.+24     	; 0x29ee <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    29d6:	4d a3       	lds	r20, 0x5d
    29d8:	5e a3       	lds	r21, 0x5e
    29da:	6f a3       	lds	r22, 0x5f
    29dc:	78 a7       	lds	r23, 0x78
					break;
    29de:	07 c0       	rjmp	.+14     	; 0x29ee <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    29e0:	32 30       	cpi	r19, 0x02	; 2
    29e2:	09 f4       	brne	.+2      	; 0x29e6 <xTaskGenericNotifyFromISR+0x86>
    29e4:	41 c0       	rjmp	.+130    	; 0x2a68 <xTaskGenericNotifyFromISR+0x108>
					{
						pxTCB->ulNotifiedValue = ulValue;
    29e6:	4d a3       	lds	r20, 0x5d
    29e8:	5e a3       	lds	r21, 0x5e
    29ea:	6f a3       	lds	r22, 0x5f
    29ec:	78 a7       	lds	r23, 0x78

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    29ee:	31 30       	cpi	r19, 0x01	; 1
    29f0:	e9 f5       	brne	.+122    	; 0x2a6c <xTaskGenericNotifyFromISR+0x10c>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    29f2:	80 91 ad 03 	lds	r24, 0x03AD
    29f6:	88 23       	and	r24, r24
    29f8:	e9 f4       	brne	.+58     	; 0x2a34 <xTaskGenericNotifyFromISR+0xd4>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    29fa:	8e 01       	movw	r16, r28
    29fc:	0e 5f       	subi	r16, 0xFE	; 254
    29fe:	1f 4f       	sbci	r17, 0xFF	; 255
    2a00:	c8 01       	movw	r24, r16
    2a02:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2a06:	8e 89       	ldd	r24, Y+22	; 0x16
    2a08:	90 91 b4 03 	lds	r25, 0x03B4
    2a0c:	98 17       	cp	r25, r24
    2a0e:	10 f4       	brcc	.+4      	; 0x2a14 <xTaskGenericNotifyFromISR+0xb4>
    2a10:	80 93 b4 03 	sts	0x03B4, r24
    2a14:	90 e0       	ldi	r25, 0x00	; 0
    2a16:	9c 01       	movw	r18, r24
    2a18:	22 0f       	add	r18, r18
    2a1a:	33 1f       	adc	r19, r19
    2a1c:	22 0f       	add	r18, r18
    2a1e:	33 1f       	adc	r19, r19
    2a20:	22 0f       	add	r18, r18
    2a22:	33 1f       	adc	r19, r19
    2a24:	82 0f       	add	r24, r18
    2a26:	93 1f       	adc	r25, r19
    2a28:	82 54       	subi	r24, 0x42	; 66
    2a2a:	9c 4f       	sbci	r25, 0xFC	; 252
    2a2c:	b8 01       	movw	r22, r16
    2a2e:	0e 94 69 05 	call	0xad2	; 0xad2 <vListInsertEnd>
    2a32:	07 c0       	rjmp	.+14     	; 0x2a42 <xTaskGenericNotifyFromISR+0xe2>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2a34:	be 01       	movw	r22, r28
    2a36:	64 5f       	subi	r22, 0xF4	; 244
    2a38:	7f 4f       	sbci	r23, 0xFF	; 255
    2a3a:	8d ef       	ldi	r24, 0xFD	; 253
    2a3c:	93 e0       	ldi	r25, 0x03	; 3
    2a3e:	0e 94 69 05 	call	0xad2	; 0xad2 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2a42:	e0 91 ab 03 	lds	r30, 0x03AB
    2a46:	f0 91 ac 03 	lds	r31, 0x03AC
    2a4a:	9e 89       	ldd	r25, Y+22	; 0x16
    2a4c:	86 89       	ldd	r24, Z+22	; 0x16
    2a4e:	89 17       	cp	r24, r25
    2a50:	78 f4       	brcc	.+30     	; 0x2a70 <xTaskGenericNotifyFromISR+0x110>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    2a52:	e1 14       	cp	r14, r1
    2a54:	f1 04       	cpc	r15, r1
    2a56:	21 f0       	breq	.+8      	; 0x2a60 <xTaskGenericNotifyFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    2a58:	81 e0       	ldi	r24, 0x01	; 1
    2a5a:	f7 01       	movw	r30, r14
    2a5c:	80 83       	st	Z, r24
    2a5e:	09 c0       	rjmp	.+18     	; 0x2a72 <xTaskGenericNotifyFromISR+0x112>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    2a60:	81 e0       	ldi	r24, 0x01	; 1
    2a62:	80 93 b1 03 	sts	0x03B1, r24
    2a66:	05 c0       	rjmp	.+10     	; 0x2a72 <xTaskGenericNotifyFromISR+0x112>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    2a68:	80 e0       	ldi	r24, 0x00	; 0
    2a6a:	03 c0       	rjmp	.+6      	; 0x2a72 <xTaskGenericNotifyFromISR+0x112>

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2a6c:	81 e0       	ldi	r24, 0x01	; 1
    2a6e:	01 c0       	rjmp	.+2      	; 0x2a72 <xTaskGenericNotifyFromISR+0x112>
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2a70:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    2a72:	df 91       	pop	r29
    2a74:	cf 91       	pop	r28
    2a76:	1f 91       	pop	r17
    2a78:	0f 91       	pop	r16
    2a7a:	ff 90       	pop	r15
    2a7c:	ef 90       	pop	r14
    2a7e:	08 95       	ret

00002a80 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    2a80:	ef 92       	push	r14
    2a82:	ff 92       	push	r15
    2a84:	0f 93       	push	r16
    2a86:	1f 93       	push	r17
    2a88:	cf 93       	push	r28
    2a8a:	df 93       	push	r29
    2a8c:	ec 01       	movw	r28, r24
    2a8e:	8b 01       	movw	r16, r22

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    2a90:	29 a5       	lds	r18, 0x69
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    2a92:	82 e0       	ldi	r24, 0x02	; 2
    2a94:	89 a7       	lds	r24, 0x79

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    2a96:	8d a1       	lds	r24, 0x4d
    2a98:	9e a1       	lds	r25, 0x4e
    2a9a:	af a1       	lds	r26, 0x4f
    2a9c:	b8 a5       	lds	r27, 0x68
    2a9e:	01 96       	adiw	r24, 0x01	; 1
    2aa0:	a1 1d       	adc	r26, r1
    2aa2:	b1 1d       	adc	r27, r1
    2aa4:	8d a3       	lds	r24, 0x5d
    2aa6:	9e a3       	lds	r25, 0x5e
    2aa8:	af a3       	lds	r26, 0x5f
    2aaa:	b8 a7       	lds	r27, 0x78

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2aac:	21 30       	cpi	r18, 0x01	; 1
    2aae:	e9 f5       	brne	.+122    	; 0x2b2a <vTaskNotifyGiveFromISR+0xaa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2ab0:	80 91 ad 03 	lds	r24, 0x03AD
    2ab4:	88 23       	and	r24, r24
    2ab6:	01 f5       	brne	.+64     	; 0x2af8 <vTaskNotifyGiveFromISR+0x78>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2ab8:	ee 24       	eor	r14, r14
    2aba:	ff 24       	eor	r15, r15
    2abc:	68 94       	set
    2abe:	e1 f8       	bld	r14, 1
    2ac0:	ec 0e       	add	r14, r28
    2ac2:	fd 1e       	adc	r15, r29
    2ac4:	c7 01       	movw	r24, r14
    2ac6:	0e 94 ba 05 	call	0xb74	; 0xb74 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2aca:	8e 89       	ldd	r24, Y+22	; 0x16
    2acc:	90 91 b4 03 	lds	r25, 0x03B4
    2ad0:	98 17       	cp	r25, r24
    2ad2:	10 f4       	brcc	.+4      	; 0x2ad8 <vTaskNotifyGiveFromISR+0x58>
    2ad4:	80 93 b4 03 	sts	0x03B4, r24
    2ad8:	90 e0       	ldi	r25, 0x00	; 0
    2ada:	9c 01       	movw	r18, r24
    2adc:	22 0f       	add	r18, r18
    2ade:	33 1f       	adc	r19, r19
    2ae0:	22 0f       	add	r18, r18
    2ae2:	33 1f       	adc	r19, r19
    2ae4:	22 0f       	add	r18, r18
    2ae6:	33 1f       	adc	r19, r19
    2ae8:	82 0f       	add	r24, r18
    2aea:	93 1f       	adc	r25, r19
    2aec:	82 54       	subi	r24, 0x42	; 66
    2aee:	9c 4f       	sbci	r25, 0xFC	; 252
    2af0:	b7 01       	movw	r22, r14
    2af2:	0e 94 69 05 	call	0xad2	; 0xad2 <vListInsertEnd>
    2af6:	07 c0       	rjmp	.+14     	; 0x2b06 <vTaskNotifyGiveFromISR+0x86>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2af8:	be 01       	movw	r22, r28
    2afa:	64 5f       	subi	r22, 0xF4	; 244
    2afc:	7f 4f       	sbci	r23, 0xFF	; 255
    2afe:	8d ef       	ldi	r24, 0xFD	; 253
    2b00:	93 e0       	ldi	r25, 0x03	; 3
    2b02:	0e 94 69 05 	call	0xad2	; 0xad2 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2b06:	e0 91 ab 03 	lds	r30, 0x03AB
    2b0a:	f0 91 ac 03 	lds	r31, 0x03AC
    2b0e:	9e 89       	ldd	r25, Y+22	; 0x16
    2b10:	86 89       	ldd	r24, Z+22	; 0x16
    2b12:	89 17       	cp	r24, r25
    2b14:	50 f4       	brcc	.+20     	; 0x2b2a <vTaskNotifyGiveFromISR+0xaa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    2b16:	01 15       	cp	r16, r1
    2b18:	11 05       	cpc	r17, r1
    2b1a:	21 f0       	breq	.+8      	; 0x2b24 <vTaskNotifyGiveFromISR+0xa4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    2b1c:	81 e0       	ldi	r24, 0x01	; 1
    2b1e:	f8 01       	movw	r30, r16
    2b20:	80 83       	st	Z, r24
    2b22:	03 c0       	rjmp	.+6      	; 0x2b2a <vTaskNotifyGiveFromISR+0xaa>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    2b24:	81 e0       	ldi	r24, 0x01	; 1
    2b26:	80 93 b1 03 	sts	0x03B1, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    2b2a:	df 91       	pop	r29
    2b2c:	cf 91       	pop	r28
    2b2e:	1f 91       	pop	r17
    2b30:	0f 91       	pop	r16
    2b32:	ff 90       	pop	r15
    2b34:	ef 90       	pop	r14
    2b36:	08 95       	ret

00002b38 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    2b38:	00 97       	sbiw	r24, 0x00	; 0
    2b3a:	29 f4       	brne	.+10     	; 0x2b46 <xTaskNotifyStateClear+0xe>
    2b3c:	e0 91 ab 03 	lds	r30, 0x03AB
    2b40:	f0 91 ac 03 	lds	r31, 0x03AC
    2b44:	01 c0       	rjmp	.+2      	; 0x2b48 <xTaskNotifyStateClear+0x10>
    2b46:	fc 01       	movw	r30, r24

		taskENTER_CRITICAL();
    2b48:	0f b6       	in	r0, 0x3f	; 63
    2b4a:	f8 94       	cli
    2b4c:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    2b4e:	81 a5       	lds	r24, 0x61
    2b50:	82 30       	cpi	r24, 0x02	; 2
    2b52:	19 f4       	brne	.+6      	; 0x2b5a <xTaskNotifyStateClear+0x22>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2b54:	11 a6       	lds	r17, 0xb1
				xReturn = pdPASS;
    2b56:	81 e0       	ldi	r24, 0x01	; 1
    2b58:	01 c0       	rjmp	.+2      	; 0x2b5c <xTaskNotifyStateClear+0x24>
			}
			else
			{
				xReturn = pdFAIL;
    2b5a:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    2b5c:	0f 90       	pop	r0
    2b5e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2b60:	08 95       	ret

00002b62 <memcpy>:
    2b62:	fb 01       	movw	r30, r22
    2b64:	dc 01       	movw	r26, r24
    2b66:	02 c0       	rjmp	.+4      	; 0x2b6c <memcpy+0xa>
    2b68:	01 90       	ld	r0, Z+
    2b6a:	0d 92       	st	X+, r0
    2b6c:	41 50       	subi	r20, 0x01	; 1
    2b6e:	50 40       	sbci	r21, 0x00	; 0
    2b70:	d8 f7       	brcc	.-10     	; 0x2b68 <memcpy+0x6>
    2b72:	08 95       	ret

00002b74 <_exit>:
    2b74:	f8 94       	cli

00002b76 <__stop_program>:
    2b76:	ff cf       	rjmp	.-2      	; 0x2b76 <__stop_program>
